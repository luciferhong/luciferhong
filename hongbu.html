<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta id="dynamicViewport" name="viewport" content="width=device-width, initial-scale=0.85, user-scalable=no">

    <link rel="icon" href="route.png" type="image/png">
    <title>[루시퍼홍] 홍부가 기가막혀</title>
	<script src="https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=hcuap73kdc"></script>
	<script type="text/javascript" src="MarkerClustering.js"></script>



    <style>
        #map { width: 100%; height: calc(100vh - 150px); resize: both; }
        #controls { margin: 10px; }
        button { margin: 5px; padding: 10px; cursor: pointer; }

		/* 현재 위치 버튼 스타일 */
		#locationButton {
			position: absolute;
			top: 90px; /* 🔹 지도 내부의 상단 */
			left: 8px; /* 🔹 지도 내부의 왼쪽 */
			background-color: white;
			border: 2px solid gray;
			padding: 10px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 12px;
			text-align: center;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
			z-index: 1000; /* 🔹 지도 위에 표시 */
		}

		/* 위치 추적 종료 버튼 */
		#stopTrackingButton {
			position: absolute;
			top: 125px; /* 🔹 지도 내부의 상단 */
			left: 60px; /* 🔹 현재 위치 버튼과 간격 유지 */
			background-color: white;
			border: 2px solid gray;
			padding: 10px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 14px;
			text-align: center;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
			z-index: 1000; /* 🔹 지도 위에 표시 */
		}


		#unitFilter {
			width: 45px; /* 숫자 3자리(최대 999) 입력 가능 */
			height: 10px;
			font-size: 16px;
			text-align: center;
			border: 2px solid #4A90E2; /* 파란색 테두리 */
			border-radius: 8px;
			padding: 5px;
			outline: none;
			transition: all 0.3s ease-in-out;
		}

		#unitFilter:focus {
			border-color: #2D5DA7; /* 포커스 시 더 진한 파란색 */
			box-shadow: 0px 0px 5px rgba(74, 144, 226, 0.5);
		}

	#controls {
    display: flex; /* ✅ 가로 정렬 */
    align-items: center; /* ✅ 내부 요소 세로 정렬 */
    gap: 10px; /* ✅ 요소 간격 조정 */
	}

	#scaleControls {
		display: flex; /* ✅ 가로 정렬 */
		align-items: center; /* ✅ 버튼이 체크박스와 같은 높이로 */
		margin-left: 5px; /* ✅ 간격 조정 */
	}

	#scaleControls button {
		width: 30px;
		height: 30px;
		font-size: 16px;
		font-weight: bold;
		background-color: white;
		border: 2px solid gray;
		border-radius: 5px;
		cursor: pointer;
		text-align: center;
		margin-left: 5px; /* ✅ 버튼 사이 간격 */
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
		display: flex;
		justify-content: center;
		align-items: center;
	}

	#scaleControls button:hover {
		background-color: #f0f0f0;
	}
	.fullscreen-btn {
		position: fixed;
		top: 170px;
		left: 20px;
		background-color: white;
		border: 2px solid gray;
		padding: 10px;
		border-radius: 50%;
		cursor: pointer;
		font-size: 14px;
		text-align: center;
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
		z-index: 10000; /* ✅ 최상단 유지 */
	}
#apartmentInfo {
    position: fixed;
    top: 50%;
    left: 50%;
    
    background: white;
    border: 1px solid black;
    padding: 8px;
    width: auto;
    font-size: 16px;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    display: none;
    z-index: 10000;
     will-change: transform; /* GPU 렌더링 힌트 */
  contain: layout paint;  /* 레이아웃 변화 제한 */
    max-width: 90%;
    max-height: 70vh; /* ✅ 화면 높이의 80%까지 확장 */
    overflow-y: auto; /* ✅ 내부 스크롤 활성화 */
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch; /* ✅ iOS 부드러운 스크롤 */
 backface-visibility: hidden; /* 깜박임 방지 */
    transform: translateZ(0);    /* GPU 렌더링 안정화 */
}


#apartmentInfo table {
    width: auto; /* 🔹 표 크기를 내용에 맞게 자동 조정 */
    table-layout: auto; /* 🔹 테이블 레이아웃 자동 조정 */
    border-collapse: collapse;
}

#apartmentInfo th, #apartmentInfo td {
    border: 1px solid black;
    padding: 2px 5px; /* 🔹 내부 여백 최소화 */
    text-align: center;
    white-space: nowrap; /* 🔹 텍스트 줄바꿈 방지 */
}

#apartmentInfo th {
    background: #f0f0f0;
    font-weight: bold;
}

#apartmentInfo .close-button {
    position: absolute;
    top: 5px;
    right: 8px;
    background: red;
    color: white;
    border: none;
    font-size: 14px;
    padding: 3px 6px;
    cursor: pointer;
    border-radius: 3px;
}
table {
    border-collapse: collapse; /* ✅ 테두리 중복 제거 */
    width: 100%; /* ✅ 테이블 크기 조정 */
}

td, th {
    border: 1px solid black; /* ✅ 테두리 스타일 확인 */
    padding: 5px; /* ✅ 내부 여백 조정 */
    text-align: center;
    white-space: nowrap; /* ✅ 줄바꿈 방지 */
}
buttonContainer {
    display: flex;
    justify-content: center; /* ✅ 버튼들을 중앙 정렬 */
    gap: 10px; /* ✅ 버튼 간격 조정 */
    margin-top: 10px;
}
#imagePreview {
  width: 100%;
  height: 72px;              /* 고정 높이 */
  overflow-x: auto;
  white-space: nowrap;       /* 줄바꿈 방지 */
}

#imagePreview > div {
  display: inline-block;
}
#imageModal {
  display: none;
  justify-content: center;
  align-items: center;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  z-index: 99999;
  backface-visibility: hidden;
  will-change: opacity;
}

#modalCanvas {
  max-width: 90%;
  max-height: 90%;
  border-radius: 8px;
}


    </style>
</head>
<body>
<h1 style="font-size: 20px; font-weight: bold; text-align: left;">
    [루시퍼홍] 홍부가 기가막혀
</h1>

<div id="controls">
    <label for="unitFilter">최소세대수: </label>
    <input type="number" id="unitFilter" min="0" value="190">
    <label><input type="checkbox" id="toggleApartments" checked>아파트</label>
    <label><input type="checkbox" id="toggleSchools" >초</label>
	<label><input type="checkbox" id="toggleMiddleSchools" >중</label>
	<label><input type="checkbox" id="toggleFacilities">환경</label>
	<label><input type="checkbox" id="toggleStarbucks">스벅</label>
	<label><input type="checkbox" id="toggleMemoIcon" checked>메모 아이콘 표시</label>

	<label><input type="checkbox" id="toggleSiseMap" >시세지도</label>




    <!-- ✅ 스케일 조정 버튼을 '초등학교' 체크박스 옆으로 이동 
    <div id="scaleControls">
		<label>배율</label>
        <button id="scaleUpButton">+</button>
        <button id="scaleDownButton">-</button>
    </div>
-->
</div>



    <div id="map"></div>
    <div id="controls">
        <button id="startPolyline">경로 그리기</button>
		<button id="undoLastPointButton">직전 취소</button>
        <button id="completePolyline">경로 그리기 완료</button>
        <button id="downloadGPX">GPX 다운로드</button>
        <button id="uploadGPX">GPX 불러오기</button>
        <input type="file" id="gpxFileInput" style="display: none;" accept=".gpx">
        <button id="clearMap">경로 초기화</button>

<div style="margin-top: 0px;">
    <button onclick="backupMemoDB()">🗂️ 메모 백업</button>
    <button onclick="restoreMemoDB()">🗃️ 메모 복원</button>
	<button onclick="deleteMemoDB()">🗑️ 메모 일괄 삭제</button>

    <input type="file" id="memoRestoreInput" accept=".json" style="display: none" />
</div>


<button id="siseExportBtn" style="display: none;">시세지도 백업</button>
<button id="siseImportBtn" style="display: none;">시세지도 복원</button>
<button id="siseResetBtn" style="display: none;">시세지도 초기화</button>



    </div>
    <div id="locationButton" title="현재 위치">📍</div> <!-- ✅ 현재 위치 버튼 -->
    <div id="stopTrackingButton" style="display:none" title="위치 추적 중지">🛑</div> <!-- ✅ 위치 추적 중지 버튼 -->
    <span style="font-size: 14px; color: gray;">
        백스페이스 : 직전 취소<br>
        ESC, 마우스 우클릭, [경로 그리기 완료] 버튼 클릭 : 그리기 종료<br>
        모바일에서도 경로그리기, 다운로드 가능합니다
    </span>

<div id="apartmentInfo" style="border: 1px solid black; padding: 10px; display:none">
    <p>아파트 정보를 확인하려면 마커를 클릭하세요.</p>
</div>
<!-- 모달 최상단 + 배경 흐림 -->
<!-- 이미지 모달 (canvas로 변경) -->
<!-- 이미지 모달 -->
<div id="imageModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background-color:rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:99999;">
  <canvas id="modalCanvas" style="max-width:90vw; max-height:90vh; border-radius:8px;"></canvas>
  <button id="copyImageButton" style="position: absolute; top: 20px; right: 20px;  background: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">
    📋 복사
  </button>
  
</div>



<script>
//이미지 확대 여부
let imageModalShowYn = false;
 class MapHandler {

		

            constructor(map) {
                this.map = map;
                this.shapes = [];
                this.currentPath = [];
                this.currentPolyline = null;
                this.markers = [];
                this.initUI();
            }
				
            initUI() {
				document.getElementById("startPolyline").addEventListener("click", () => this.startPolylineMode());
				document.getElementById("undoLastPointButton").addEventListener("click", () => this.undoLastPoint());
				document.getElementById("completePolyline").addEventListener("click", () => this.completePolyline()); // ✅ 추가됨*				
				document.getElementById("downloadGPX").addEventListener("click", () => this.downloadGPX());
				 // ✅ 시세지도 백업 (익스포트)
				document.getElementById("siseExportBtn").addEventListener("click", () => {
					exportToJSON();
				});

				// ✅ 시세지도 복원 (임포트)
				document.getElementById("siseImportBtn").addEventListener("click", () => {
					const input = document.createElement('input');
					input.type = 'file';
					input.accept = 'application/json';
					input.onchange = function (event) {
						const file = event.target.files[0];
						if (file) {
							importFromJSON(file);
						}
					};
					input.click();
				});

				document.getElementById("siseResetBtn").addEventListener("click", () => {
				const confirmReset = confirm("⚠️ 시세 데이터를 초기화하면 복구할 수 없습니다. 시세지도 백업을 권장드립니다. \n계속하시겠습니까?");
				if (!confirmReset) return;

				const request = indexedDB.open("hongbu", 2);
				request.onsuccess = function(event) {
					const db = event.target.result;
					const transaction = db.transaction(["apartments"], "readwrite");
					const store = transaction.objectStore("apartments");

					const clearRequest = store.clear(); // ✅ 전체 삭제

					clearRequest.onsuccess = function() {
						alert("✅ 시세지도 데이터가 초기화되었습니다.");
						// 🔁 마커 업데이트
						prevSiseMapState = "초기화";
						updateMarkers(window.map.getBounds());
					};

					clearRequest.onerror = function(event) {
						console.error("❌ 시세지도 초기화 실패:", event.target.error);
						alert("❌ 초기화 중 오류가 발생했습니다.");
					};
				};
			});



				document.getElementById("uploadGPX").addEventListener("click", () => document.getElementById("gpxFileInput").click());

				// 🔹 `this`를 `MapHandler` 인스턴스로 유지
				document.getElementById("gpxFileInput").addEventListener("change", this.handleFileChange.bind(this));

				document.getElementById("clearMap").addEventListener("click", () => this.clearMap());
				
				document.addEventListener("keydown", (e) => {
					if (e.key === "Escape") {
						this.completePolyline();
					} else if (e.key === "Backspace") {
						this.undoLastPoint();
					}
				});

				naver.maps.Event.addListener(this.map, "click", (e) => {
					if (!this.currentPolyline) {
						console.warn("⚠️ 경로 그리기 모드가 아님");
						return; // 🚫 실행 중단 (오류 방지)
					}
					this.currentPath.push(e.coord);
					this.currentPolyline.setPath(this.currentPath);
					this.addMilestoneMarker(e.coord);
				});

				naver.maps.Event.addListener(this.map, "rightclick", () => {
					this.completePolyline();
				});

			
			}

			handleFileChange(event) {
				const file = event.target.files[0];
				if (!file) return; // 선택된 파일이 없으면 종료

				this.loadGPX(file);

				// 🔹 동일한 파일 다시 선택 가능하도록 input 값 초기화
				event.target.value = ""; 
			}


			startPolylineMode() {
				if (this.shapes.length > 0) {
					const userConfirmed = confirm("이전에 그린 경로가 삭제됩니다. 계속하시겠습니까?");
					if (!userConfirmed) return;

					this.clearMap(); // 기존 경로 초기화
				}

				this.currentPath = [];
				this.markers = [];
				this.currentPolyline = new naver.maps.Polyline({
					map: this.map,
					path: this.currentPath,
					strokeColor: "#FF0000",
					strokeWeight: 3.33,
					strokeOpacity: 0.8
				});	
			}
		
			downloadGPX() {
				if (this.shapes.length === 0) {
					alert("다운로드할 경로가 없습니다.");
					return;
				}

				let gpxData = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="MapHandler">\n  <trk>\n    <trkseg>\n`;
				
				this.shapes.forEach(({ polyline }) => {
					polyline.getPath().forEach((coord) => {
						gpxData += `      <trkpt lat="${coord.y}" lon="${coord.x}"></trkpt>\n`;
					});
				});

				gpxData += `    </trkseg>\n  </trk>\n</gpx>`;
				
				const blob = new Blob([gpxData], { type: "application/gpx+xml" });
				const a = document.createElement("a");
				a.href = URL.createObjectURL(blob);
				a.download = "route.gpx";
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
			}

            completePolyline() {
                if (this.currentPolyline && this.currentPath.length > 1) {
                    this.addStartEndMarkers();
                    this.shapes.push({ polyline: this.currentPolyline, markers: [...this.markers] });
                    this.currentPolyline = null;
                }
            }

            addMilestoneMarker(coord) {
                const marker = new naver.maps.Marker({
                    position: coord,
                    map: this.map,
                    icon: {
                        content: `<div style="width: 8px; height: 8px; background-color: #FF0000; border-radius: 50%; border: 2px solid #FFF;"></div>`,
                        anchor: new naver.maps.Point(4, 4)
                    }
                });
                this.markers.push(marker);
            }

            addStartEndMarkers() {
                if (this.currentPath.length < 2) return;
                this.createLabeledMarker(this.currentPath[0], "출발");
                this.createEndMarker(this.currentPath[this.currentPath.length - 1]);
            }

            createLabeledMarker(coord, label) {
                const marker = new naver.maps.Marker({
                    position: coord,
                    map: this.map,
                    icon: {
                        content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
                                    <span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
                                  </div>`
                    }
                });
                this.markers.push(marker);
            }
			clearMap() {
				if (!Array.isArray(this.shapes)) {
					this.shapes = []; // shapes가 배열이 아니면 초기화
				}

				// 기존 경로 및 마커 제거
				this.shapes.forEach(({ polyline, markers }) => {
					if (polyline) polyline.setMap(null);
					if (Array.isArray(markers)) {
						markers.forEach(marker => marker.setMap(null));
					}
				});

				// 🔹 출발 & 도착 마커 삭제
				if (Array.isArray(this.markers)) {
					this.markers.forEach(marker => marker.setMap(null));
				}

				// 🔹 도착 마커 삭제 추가
				if (this.endMarker) {
					this.endMarker.setMap(null);
					this.endMarker = null; // 도착 마커 변수 초기화
				}

				// 데이터 초기화
				this.shapes = [];
				this.markers = [];
				this.currentPath = [];
				this.currentPolyline = null;
			}

		loadGPX(file) {

			this.clearMap();
			const reader = new FileReader();
			reader.onload = (event) => {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

				const trkpts = xmlDoc.getElementsByTagName("trkpt");
				if (trkpts.length === 0) {
					alert("유효한 GPX 파일이 아닙니다.");
					return;
				}

				let path = [];
				for (let i = 0; i < trkpts.length; i++) {
					const lat = parseFloat(trkpts[i].getAttribute("lat"));
					const lon = parseFloat(trkpts[i].getAttribute("lon"));
					path.push(new naver.maps.LatLng(lat, lon));
				}

				this.drawGPXPath(path);
				this.updateEndMarker(path); // 🔹 GPX 로드 후 도착 마커 업데이트
			};
			reader.readAsText(file);
		}

		updateEndMarker(path) {
			if (path.length < 2) return; // 유효한 경로가 없으면 종료

			const totalDistance = this.calculateTotalDistance(path); // 거리 재계산
			const formattedDistance = totalDistance >= 1000 
				? (totalDistance / 1000).toFixed(2) + "km" 
				: totalDistance.toFixed(0) + "m";

			const estimatedTime = this.calculateWalkingTime(totalDistance / 1000); // 예상 시간 계산
			const label = `도착<br>${formattedDistance}<br>${estimatedTime}<br>(시속 4km 기준)`;

			// 기존 도착 마커 삭제
			if (this.endMarker) this.endMarker.setMap(null);

			// 새 도착 마커 추가
			this.endMarker = new naver.maps.Marker({
				position: path[path.length - 1],
				map: this.map,
				icon: {
					content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
								<span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
							  </div>`
				}
			});
		}




		drawGPXPath(path) {
			if (path.length < 2) {
				alert("경로 데이터가 충분하지 않습니다.");
				return;
			}

			const polyline = new naver.maps.Polyline({
				map: this.map,
				path: path,
				strokeColor: "#0000FF", // GPX 경로 색상 (파란색)
				strokeWeight: 3.33,
				strokeOpacity: 0.8
			});

			this.shapes.push({ polyline });

			this.createLabeledMarker(path[0], "출발");
			this.createEndMarker(path[path.length - 1]);
		}

		createEndMarker(coord) {
			const totalDistance = this.calculateTotalDistance(); // m 단위로 가져옴
			const formattedDistance = totalDistance >= 1000 
				? (totalDistance / 1000).toFixed(2) + "km" 
				: totalDistance.toFixed(0) + "m";

			const estimatedTime = this.calculateWalkingTime(totalDistance / 1000); // km 단위로 변환
			const label = `도착<br>${formattedDistance}<br>${estimatedTime}<br>(시속 4km 기준)`;

			const marker = new naver.maps.Marker({
				position: coord,
				map: this.map,
				icon: {
					content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
								<span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
							  </div>`
				}
			});
			this.markers.push(marker);
		}


		calculateTotalDistance(path = this.currentPath) {
			if (!Array.isArray(path) || path.length < 2) {
				return 0; // 🔹 경로가 없으면 거리 0 반환
			}

			let total = 0;
			for (let i = 1; i < path.length; i++) {
				total += this.computeDistance(path[i - 1], path[i]);
			}
			return total; // 거리 반환 (m 단위)
		}




		computeDistance(coord1, coord2) {
			const R = 6371000;
			const lat1 = coord1.y * Math.PI / 180;
			const lat2 = coord2.y * Math.PI / 180;
			const deltaLat = (coord2.y - coord1.y) * Math.PI / 180;
			const deltaLng = (coord2.x - coord1.x) * Math.PI / 180;

			const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
					  Math.cos(lat1) * Math.cos(lat2) *
					  Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return R * c;
		}

        calculateWalkingTime(distanceKm) { 
			const speed = 4; // 시속 4km
			const hours = Math.floor(distanceKm / speed);
			const minutes = Math.round((distanceKm % speed) * 60 / speed);
			return (hours > 0 ? `${hours}시간 ${minutes}분` : `${minutes}분`);
		}


        undoLastPoint() {
			if (this.currentPath.length > 0) {
				this.currentPath.pop(); // 마지막 좌표 삭제
				this.currentPolyline.setPath(this.currentPath); // 반영

				// 마지막 마커 삭제
				const lastMarker = this.markers.pop();
				if (lastMarker) lastMarker.setMap(null);
			}
		}

    }


	document.addEventListener("DOMContentLoaded", async () => {
		window.map = new naver.maps.Map("map", {
			center: new naver.maps.LatLng(37.5665, 126.9780),
			zoom: 15
		});

		// ✅ `MapHandler` 클래스 생성 후 지도 객체와 연결
		new MapHandler(window.map);

		// ✅ 아파트 데이터 불러오기
		await loadApartments();

		// ✅ 지도 이동 시 현재 범위 내 아파트 마커 업데이트
		naver.maps.Event.addListener(window.map, "idle", () => {
			const bounds = window.map.getBounds();
			updateMarkers(bounds);
		});

		console.log("✅ 네이버 지도 초기화 완료.");
	});



	const mapElement = document.getElementById('map');

	function getMapSize() {
		return new naver.maps.Size(mapElement.offsetWidth, mapElement.offsetHeight);
	}

	let isTracking = false; // ✅ 위치 추적 여부 (true: 추적 중)

	document.getElementById("locationButton").addEventListener("click", () => {
		if (!window.map || !(window.map instanceof naver.maps.Map)) {
			console.error("네이버 지도 객체가 올바르게 초기화되지 않았습니다.");
			return;
		}

		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(
				(position) => {
					updateUserLocation(position, true); // ✅ 강제 이동 (true)
					startTracking(); // ✅ 위치 추적 시작
				},
				(error) => {
					alert("현재 위치를 찾을 수 없습니다. 위치 권한을 확인하세요.");
				}
			);
		} else {
			alert("이 브라우저에서는 위치 정보를 지원하지 않습니다.");
		}
	});

	function startTracking() {
		if (navigator.geolocation) {
			isTracking = true; // ✅ 위치 추적 활성화
			window.watchId = navigator.geolocation.watchPosition(
				(position) => {
					updateUserLocation(position, false); // ✅ 센터 이동 X (false)
				},
				(error) => {
					alert("실시간 위치 추적에 실패했습니다.");
				},
				{ enableHighAccuracy: true }
			);
			//console.log("위치 추적 시작 (watchId):", window.watchId);
		}
	}

	function stopTracking() {
		if (window.watchId !== null) {
			navigator.geolocation.clearWatch(window.watchId);
			//console.log("위치 추적이 중지되었습니다. watchId:", window.watchId);
			window.watchId = null;
			isTracking = false; // ✅ 위치 추적 비활성화

			// ✅ 마커 제거
			if (window.currentLocationMarker) {
				window.currentLocationMarker.setMap(null);
				window.currentLocationMarker = null;
			}
		} else {
			console.warn("위치 추적이 이미 중지된 상태입니다.");
		}
	}

	// ✅ "위치 추적 중지" 버튼 이벤트
	document.getElementById("stopTrackingButton").addEventListener("click", stopTracking);

	function updateUserLocation(position, forceCenter = false) {
		const lat = position.coords.latitude;
		const lon = position.coords.longitude;
		const currentLocation = new naver.maps.LatLng(lat, lon);

		//console.log("현재 위치 업데이트:", currentLocation, "강제 이동 여부:", forceCenter);

		// ✅ 위치 추적 중이 아니거나, 강제 이동 플래그가 true일 때만 지도 중심 이동
		if (!isTracking || forceCenter) {
			window.map.setCenter(currentLocation);
			window.map.setZoom(16);
		}

		// ✅ 기존 마커 삭제
		if (window.currentLocationMarker) {
			window.currentLocationMarker.setMap(null);
		}

		// ✅ 현재 위치 마커 추가
		window.currentLocationMarker = new naver.maps.Marker({
			position: currentLocation,
			map: window.map,
			icon: {
				content: `<div style="width: 14px; height: 14px; background-color: red; border-radius: 50%; border: 3px solid white;"></div>`,
				anchor: new naver.maps.Point(7, 7)
			}
		});
	}


	let map; // ✅ 전역 변수 설정
	let watchId = null; // ✅ 전역 변수로 위치 추적 ID 저장

	let locationCircle = null; // ✅ 반경 500m 원 객체 저장
	let currentLocationMarker = null; // ✅ 현재 위치 마커 저장

	let apartmentData = []; // ✅ 전체 아파트 데이터 저장
	let apartmentMarkers = []; // ✅ 지도에 표시된 마커 저장
	let markerCluster = null; // ✅ 마커 클러스터링 객체

	// ✅ 2. 아파트 데이터를 fetch()로 가져오기
	async function loadApartments() { 
    
		try {
			//const response = await fetch("https://your-github-username.github.io/data/apt.json"); // ✅ JSON 파일 사용
			const response = await fetch("apt.json");
			const data = await response.json();

			apartmentData = data.map((apt, index) => ({
				id: apt.id,
				name: apt.name, // ✅ 올바른 속성 접근
				year: apt.year, // ✅ 올바른 속성 접근
				units: parseInt(apt.units, 10), // ✅ 올바른 속성 접근
				lat: parseFloat(apt.lat), // ✅ 올바른 속성 접근
				lng: parseFloat(apt.lng), // ✅ 올바른 속성 접근
				lease: apt.lease // ✅ 올바른 속성 접근
			}));

			
			//console.log("✅ 아파트 데이터 fetch 완료");
			updateMarkers(window.map.getBounds())
		} catch (error) {
			console.error("❌ 아파트 데이터 불러오기 실패:", error);
		}
	}



function closePopup() {
  //console.log("호출")
    isPopupOpen = false;
    if (activeMarkerSet) {

        activeMarkerSet = null;
    }
    //console.log("❌ 이동 모드 종료");
}

function makeModalDraggable(modal) {
        let isDragging = false;
        let offsetX, offsetY;

        const header = document.createElement('div');
        header.className = 'draggable';
        header.style.padding = '10px';
        header.style.cursor = 'move';
        header.style.backgroundColor = '#f1f1f1';
        header.style.borderBottom = '1px solid #ccc';
        header.textContent = 'Drag me';

        modal.insertBefore(header, modal.firstChild);

        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - modal.offsetLeft;
            offsetY = e.clientY - modal.offsetTop;
            document.addEventListener('mousemove', moveModal);
            document.addEventListener('mouseup', stopDragging);
        });

        function moveModal(e) {
            if (isDragging) {
                modal.style.left = `${e.clientX - offsetX}px`;
                modal.style.top = `${e.clientY - offsetY}px`;
            }
        }

        function stopDragging() {
            isDragging = false;
            document.removeEventListener('mousemove', moveModal);
            document.removeEventListener('mouseup', stopDragging);
        }
    }


// ✅ 시세 마커에서 테이블이 아닌 영역을 우클릭하면 색상 선택 모달 표시
function addSiseMapMarkerLeftClickEvent(marker, markerElement) {
//console.log("addSiseMapMarkerLeftClickEvent 실행됨");
    naver.maps.Event.addListener(marker, "click", (e) => {
        e.domEvent.preventDefault(); // 기본 우클릭 메뉴 방지
        e.domEvent.stopPropagation();

        const tableContainer = markerElement.querySelector(".tableContainer");

        // ✅ 테이블 영역을 클릭한 경우 색상 선택 모달을 띄우지 않음
        if (e.domEvent.target.closest(".tableContainer")) {
            return;
        }

        //console.log("🚀 마커 우클릭 감지:", markerElement.dataset);

        let apartmentId = markerElement.dataset.apartmentId;
        if (!apartmentId) {
            console.error("❌ apartmentId 찾을 수 없음!");
            return;
        }

        showColorPickerModal(apartmentId, markerElement.style.backgroundColor, markerElement.style.color, markerElement.style.fontSize, 
			(selectedColor, textColor, fontSize) => {
				markerElement.style.backgroundColor = selectedColor;
				markerElement.style.color = textColor;
				markerElement.style.fontSize = fontSize;

				updateMarkerStyleAndSave(apartmentId, selectedColor, textColor, fontSize); // ✅ apartmentId가 정상적으로 전달됨
			});



    });
}

function updateMarkerStyleAndSave(id, selectedColor, textColor, fontSize) {
    getFromIndexedDB(id, "시세1").then(existingData => {
        let existingText = existingData?.text || generateDefaultTable();

        // ✅ 기본값 강제 적용
        selectedColor = selectedColor?.trim() || '#9F9F9F';
        textColor = textColor?.trim() || '#FFFFFF';
        fontSize = fontSize?.trim() || '12px';

        //console.log(`🎨 마커 스타일 업데이트 시도 (ID: ${id})`, { selectedColor, textColor, fontSize });

        // ✅ IndexedDB 저장
        saveToIndexedDB(id, "시세1", existingText, selectedColor, textColor, fontSize);

        // ✅ 마커 스타일 즉시 업데이트
        let markerElement = document.querySelector(`[data-apartment-id='${id}']`);
        if (!markerElement) {
            console.error(`❌ 마커를 찾을 수 없습니다. ID: ${id}`);
            return;
        }

        // ✅ 💡 중요: 글자 색상 및 크기 즉시 반영
        markerElement.style.backgroundColor = selectedColor;
        markerElement.style.color = textColor;
        markerElement.style.setProperty("color", textColor, "important"); // ✅ 즉시 적용 (중요도 높이기)
        markerElement.style.setProperty("font-size", fontSize, "important");

        markerElement.style.setProperty("font-size", fontSize, "important"); // ✅ 즉시 적용 (중요도 높이기)


        // ✅ 내부 테이블의 글자색 & 크기 즉시 반영
        let tableContainer = markerElement.querySelector(".tableContainer");
        if (tableContainer) {
            tableContainer.style.color = textColor;
            tableContainer.style.fontSize = fontSize;
            tableContainer.style.setProperty("font-size", fontSize, "important");
        }

    }).catch(error => {
        console.error("❌ IndexedDB 불러오기 실패:", error);
    });
}








// ✅ 기본 마커 생성 (시세지도 체크 해제 시)
function createDefaultMarker(apartment) {
    let yearValue = parseInt(apartment.year.slice(2), 10);
    let bgColor = "#FFFA00"; // yellow
    let fongColor = "white";

    if (yearValue > 50) bgColor = "#5C6267";
    else if (yearValue >= 20) bgColor = "#3E24D7";
    else if (yearValue >= 10) bgColor = "#EE1A24";

    if (yearValue >= 00 && yearValue < 10) fongColor = "black"; 

    const markerElement = document.createElement("div");
	markerElement.style = `
		background-color: ${bgColor};
		color: ${fongColor};
		border-radius: 6px;
		padding: 0px;
		border: 3px  black;  /* ✅ 테두리 두께 2px, 검정색 */
		text-align: center;
		font-size: 12px;
		font-weight: bold;
		box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
		white-space: nowrap;
		display: inline-block;
	`;

	const nameElement = document.createElement("div");
	nameElement.style = `
		background: white;
		color: black;
		font-size: 12px;
		font-weight: bold;
		display: flex; /* ✅ Flexbox 사용 */
		align-items: center;
		justify-content: center;
		padding: 2px 5px; /* ✅ 최소 패딩 유지 */
		border-radius: 3px;
		min-width: 85px; /* ✅ 최소 너비 고정 */
		max-width: 85px; /* ✅ 최대 너비 고정 */
		overflow: hidden;
		text-overflow: ellipsis;
	`;

	const detailsElement = document.createElement("div");
	detailsElement.style = `
		font-size: 12px;
		padding: 2px 5px;
		min-width: 85px; /* ✅ 세부 정보도 최소 크기 동일 */
		max-width: 85px;
		display: flex;
		justify-content: center;
	`;


    nameElement.textContent = apartment.name.length > 7 ? apartment.name.slice(0, 6) + "..." : apartment.name;
    detailsElement.textContent = `${apartment.year.slice(-5)} ${apartment.units}세대`;

    markerElement.appendChild(nameElement);
    markerElement.appendChild(detailsElement);

getMemoFromIndexedDB(apartment.id).then(memo => {
    const hasMemo = memo?.memo?.trim()?.length > 0;
    const hasImages = Array.isArray(memo?.images) && memo.images.length > 0;
    const showMemoIcon = document.getElementById("toggleMemoIcon")?.checked;

    if (showMemoIcon && (hasMemo || hasImages)) {
        const memoIcon = document.createElement("img");
        memoIcon.src = "memo.png"; // 🔺 이미지 파일명
        memoIcon.style = `
            position: absolute;
            top: -16px;
            left: -20px;
            width: 28px;
            height: 28px;
            z-index: 10;
            pointer-events: none;
        `;
        markerElement.style.position = "relative";
        markerElement.appendChild(memoIcon);
    }
});




		// ✅ 마커 클릭 시 가로 길이 확장 → 3초 후 다시 축소
    

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: markerElement,
            anchor: new naver.maps.Point(10, 30)
        }
    });
	marker.apartmentId = apartment.id; // ✅ 마커 객체에 직접 ID 저장

	naver.maps.Event.addListener(marker, "click",  function(e) {
		showApartmentInfo(apartment.id, {
			x: e.offset.x,
			y: e.offset.y
		});
	});

	addMarkerRightClickEvent(marker, markerElement); // ✅ 마커 선택 이벤트 등록

	return marker;
}


let prevSiseMapState = null; // 🔹 전역 변수로 이전 시세지도 상태 저장

function removeLinesOutsideBounds(bounds) {
    Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        const position = marker.getPosition();
        const line = marker.lineToOrigin;

        const isMarkerInside = bounds.hasLatLng(position);

        // 마커가 bounds 바깥이면
        if (!isMarkerInside) {
            //console.log(`❌ 마커 제거됨: ${id}`);
			if(marker.movementLine){
				marker.movementLine.setMap(null);
				marker.movementLine = null;
			}
            marker.setMap(null);
            delete apartmentMarkers[id];

            // 선도 같이 제거
            if (line) {
                //console.log(`❌ 선도 같이 제거됨: ${id}`);
                line.setMap(null);
                delete marker.lineToOrigin;
            }
        }
    });
}

function removeAllLines() {
	
     Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        const position = marker.getPosition();
        const isMarkerInside = window.map.getBounds().hasLatLng(position);

        if (isMarkerInside) {
            // 🔥 범위 안의 마커에 연결된 이동선 제거
            if (marker.movementLine) {
                marker.movementLine.setMap(null);
                marker.movementLine = null;
                //console.log(`🧹 ${id}의 이동선 제거됨`);
            }
        }
    });
}

	// ✅ 3. 지도 이동할 때마다 범위 내 아파트만 마커로 표시
	function updateMarkers(bounds) {


const showApartments = document.getElementById("toggleApartments").checked;
    if (!showApartments) {
        Object.values(apartmentMarkers).forEach(marker => {
            if (marker instanceof naver.maps.Marker) {
                marker.setMap(null);
            }
        });
        apartmentMarkers = {}; // 캐시 초기화
        return; // ✅ 마커 제거 후 더 이상 작업하지 않음
    }


//범위 벗어나면 마커 삭제
removeLinesOutsideBounds(bounds)

		const minUnits = parseInt(document.getElementById("unitFilter").value, 10) || 0;
		//const showApartments = document.getElementById("toggleApartments").checked;
		const isSiseMapActive = document.getElementById("toggleSiseMap").checked;

		if (!showApartments || window.map.getZoom() < 14) return;

		const filtered = apartmentData.filter(apartment =>
			bounds.hasLatLng(new naver.maps.LatLng(apartment.lat, apartment.lng)) &&
			apartment.units >= minUnits
		);

		const newMarkers = [];

		// ✅ 시세지도 체크 상태가 바뀐 경우 → 모든 마커 제거
		if (prevSiseMapState !== isSiseMapActive) {
			Object.values(apartmentMarkers).forEach(marker => {
				if (marker instanceof naver.maps.Marker) {
					naver.maps.Event.clearInstanceListeners(marker);
					marker.setMap(null);
				}
			});
			apartmentMarkers = {}; // 캐시 초기화
			prevSiseMapState = isSiseMapActive; // 상태 갱신
		}

		// ✅ 새 마커 생성 or 재사용
		filtered.forEach(apartment => {
			if (apartment.name.includes("도시형") || apartment.name.includes("생활형")) return;
			let marker = apartmentMarkers[apartment.id];

			if (!marker) {
				marker = isSiseMapActive
					? renderSiseMapMarker(apartment)
					: createDefaultMarker(apartment);

				marker.__siseMap = isSiseMapActive;
				apartmentMarkers[apartment.id] = marker;
			}

			newMarkers.push(marker);
		});


		if (markerCluster) {
			markerCluster.setMarkers(newMarkers);
		}



	}




let schoolMarkers = []; // ✅ 지도에 표시된 학교 마커 저장

async function loadSchools() {
    try {
        const response = await fetch("eliSchools.json");
        const schools = await response.json();
        
        //console.log("✅ 학교 데이터 로드 완료", schools);

        window.schoolData = schools; // ✅ 전체 학교 데이터 저장

        // ✅ 초기 마커 업데이트
        updateSchoolMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 학교 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateSchoolMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 학교 데이터 로드 실패:", error);
    }
}

function updateSchoolMarkers() {
    const showSchools = document.getElementById("toggleSchools").checked;

    // ✅ 기존 학교 마커 제거
    schoolMarkers.forEach(marker => marker.setMap(null));
    schoolMarkers = [];

    if (!showSchools) return; // 초등학교 표시 체크 해제 시 종료
	if (window.map.getZoom() < 14) { 
			return; // ✅ 줌 레벨이 14보다 작으면 실행 중단
	}
    let bounds = window.map.getBounds();
    let filteredSchools = window.schoolData.filter(school =>
        bounds.hasLatLng(new naver.maps.LatLng(school.latitude, school.longitude))
    );

    filteredSchools.forEach(school => {
    // ✅ 마커 컨테이너를 markerElement로 활용
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = "eliSchool.png";
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;
    infoBox.textContent = `${school.schoolName.replace(/등학교/g, "")} (${school.studentCountPerClassroom}/${school.totalStudentCount})`;

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(school.latitude, school.longitude),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // ✅ 우클릭 이벤트에 markerElement 전달 (테두리 활성화 가능)
    addMarkerRightClickEvent(marker, markerElement);

    schoolMarkers.push(marker);
});

}


// ✅ 페이지 로드 시 실행
document.addEventListener("DOMContentLoaded", async () => {
	await loadApartments();
    await loadSchools();
    await loadMiddleSchools();
	await loadApartmentsDetail();
    await loadFacilities();
    await loadStarbucks();
	await initIndexedDB();
	await initMemoIndexedDB();

	if (window.map) {
        setupRightClickEvent();
    } else {
        // ✅ 지도 로드 후 이벤트를 추가하는 방식
        const checkMapLoaded = setInterval(() => {
            if (window.map) {
                clearInterval(checkMapLoaded);
                setupRightClickEvent();
            }
        }, 100); // 🔹 100ms 간격으로 지도 로드 확인
    }


    const metaViewport = document.querySelector("meta[name='viewport']");


    function updateViewportScale(scale) {
		const metaViewport = document.querySelector("meta[name='viewport']");
		currentScale = Math.max(0.5, Math.min(1.5, scale)); // ✅ 최소 0.5 ~ 최대 1.5 제한
		metaViewport.setAttribute("content", `width=device-width, initial-scale=${currentScale}, user-scalable=no`);

		//console.log("📌 새로운 Viewport Scale:", currentScale);

		// ✅ 강제로 화면 확대/축소 효과 적용
		document.documentElement.style.zoom = 1; // **Reflow**
		document.documentElement.style.zoom = currentScale; // **즉시 반영**

		// ✅ 가로 스크롤 방지 (zoom 변경 후 body, html 크기 조정)
		document.documentElement.style.overflow = "hidden";
		document.body.style.overflow = "hidden";
		document.body.style.width = "100vw"; // **📌 강제 조정하여 가로 스크롤 제거**

		// ✅ 지도 크기 강제 업데이트 (idle 이벤트 발생 유도)
		if (window.map) {
			setTimeout(() => {
				let mapElement = document.getElementById("map");
				let width = mapElement.clientWidth;
				let height = mapElement.clientHeight;
				window.map.setSize(new naver.maps.Size(width, height));
				//console.log("🔄 지도 크기 변경됨:", width, height);
			}, 200); // ✅ 브라우저 리플로우 후 실행
		}
	}

//이동시 선 긋기
naver.maps.Event.addListener(window.map, "click", function(e) {
    if (activeMarker && activeMarker instanceof naver.maps.Marker) {
        const newPosition = e.coord;

        const origin = activeMarker.originPosition;
        if (origin) {
            // 🔴 이전 선이 있다면 지도에서 제거
            if (activeMarker.movementLine) {
                activeMarker.movementLine.setMap(null);
            }

            // 🔵 새 선 생성 및 마커에 저장
            const line = new naver.maps.Polyline({
                map: window.map,
                path: [origin, newPosition],
                strokeColor: "#000000",
                strokeOpacity: 0.8,
                strokeWeight: 2
            });

            activeMarker.movementLine = line;
        }

        activeMarker.setPosition(newPosition);
        //console.log("📌 마커 이동됨:", newPosition.toString());
    }
});




});

document.getElementById("toggleApartments").addEventListener("change", () => {
    updateMarkers(window.map.getBounds()); // ✅ 즉시 업데이트
});


document.getElementById("toggleMemoIcon").addEventListener("change", () => {
Object.values(apartmentMarkers).forEach(marker => {
        if (marker instanceof naver.maps.Marker) {
            marker.setMap(null);
        }
    });
    apartmentMarkers = {}; // ✅ 마커 캐시도 초기화

    // ✅ 다시 그리기
    
    updateMarkers(window.map.getBounds()); // ✅ 즉시 업데이트
});


document.getElementById("toggleSchools").addEventListener("change", () => {
    updateSchoolMarkers(); // ✅ 즉시 업데이트
});

let observer = new ResizeObserver(() => {
    if (window.map) {
        let mapElement = document.getElementById("map");
        //let width = mapElement.clientWidth;
        //let height = mapElement.clientHeight;
        //window.map.setSize(new naver.maps.Size(width, height)); // 지도 크기 업데이트
		//console.log("지도 변함");
    }
});

// `#map` 요소의 크기 변화를 감지하여 자동 업데이트
observer.observe(document.getElementById("map"));

let isFullscreen = false; // 현재 전체 화면 여부 저장
let originalHeight = document.getElementById("map").style.height; // 기존 지도 높이 저장

function toggleFullscreen() {
    let mapElement = document.getElementById("map");

    if (!isFullscreen) {
        // 🔹 전체 화면 모드로 전환
        originalHeight = mapElement.style.height; // 원래 높이 저장
        mapElement.style.position = "fixed";
        mapElement.style.top = "0";
        mapElement.style.left = "0";
        mapElement.style.width = "100vw";
        mapElement.style.height = "100vh";
        mapElement.style.zIndex = "9999";
        document.body.style.overflow = "hidden"; // 스크롤 방지
        isFullscreen = true;
    } else {
        // 🔹 원래 상태로 복귀
        mapElement.style.position = "";
        mapElement.style.top = "";
        mapElement.style.left = "";
        mapElement.style.width = "100%";
        mapElement.style.height = originalHeight; // 저c장된 높이 복원
        mapElement.style.zIndex = "";
        document.body.style.overflow = ""; // 스크롤 가능하게 설정
        isFullscreen = false;
    }

    // 지도 크기 갱신
    window.map.setSize(new naver.maps.Size(mapElement.clientWidth, mapElement.clientHeight));
}






let apartmentDetailData = {};

// JSON 데이터 로드
async function loadApartmentsDetail() {
    try {
        //console.log("📌 JSON 데이터 로드 시작");

        // 🔹 두 개의 JSON 파일 fetch()
        const [res1, res2] = await Promise.all([
            fetch("apartments1.json").then(res => res.json()),
            fetch("apartments2.json").then(res => res.json())
        ]);

        // 🔹 JSON 병합 (Object.assign() 사용)
        apartmentDetailData = Object.assign({}, res1, res2);

        //console.log("✅ 아파트 데이터 로드 완료:", apartmentDetailData);

        // 🔹 마커 업데이트
        updateMarkers(window.map.getBounds());

    } catch (error) {
        console.error("❌ 아파트 데이터 불러오기 실패:", error);
    }
}
// 맨 위 전역에 추가
const aptMemoImageList = {};

   // 마커 클릭 시 정보 표시
// 마커 클릭 시 정보 표시

async function compressImage(base64, maxSize = 600, quality = 0.8) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement("canvas");
            let [w, h] = [img.width, img.height];
            if (w > h && w > maxSize) {
                h *= maxSize / w;
                w = maxSize;
            } else if (h >= w && h > maxSize) {
                w *= maxSize / h;
                h = maxSize;
            }
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);
            const compressedBase64 = canvas.toDataURL("image/jpeg", quality);
            resolve(compressedBase64);
        };
        img.src = base64;
    });
}



 function showApartmentInfo(apartmentId, markerPosition) {
  event?.stopPropagation();
  if (document.getElementById("toggleSiseMap").checked) return;

  apartmentId = String(apartmentId);
  if (!apartmentDetailData[apartmentId]) {
    alert("데이터를 찾을 수 없습니다.");
    return;
  }

  let apt = apartmentDetailData[apartmentId];
  let aptInfo = apartmentData.find(apartment => String(apartment.id) === apartmentId);
  let leaseInfo = aptInfo ? aptInfo.lease : "정보 없음";
  let typeInfo = apt.타입정보 || [];

apartmentInfo.setAttribute("data-id", apartmentId);


  let infoHtml = `
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h3 style="margin: 0; text-align: left;">${apt.아파트명}</h3>
      <button onclick="openNaverRealEstate(${apartmentId})" 
        style="padding: 8px; background: #4A90E2; color: white; border: none; border-radius: 4px; cursor: pointer;">
        네부 바로가기
      </button>
    </div>
    <p>입주시기: ${apt.입주시기}</p>
    <p>총세대수: ${apt.총세대수} (임대 : ${leaseInfo})</p>
    <table style="width: 100%; border-collapse: collapse;">
      <tr>
        <th>공급평수</th>
        <th>공급㎡</th>
        <th>전용㎡</th>
        <th>구조</th>
        <th>방</th>
        <th>화</th>
        <th>타입</th>
        <th>세대수</th>
      </tr>`;

  typeInfo.forEach(type => {
    infoHtml += `
      <tr>
        <td>${type["공급평수"]}</td>
        <td>${type["공급면적"]}</td>
        <td>${type["전용면적"]}</td>
        <td>${type["구조"]}</td>
        <td>${type["방 갯수"]}</td>
        <td>${type["화장실 갯수"]}</td>
        <td>${type["타입"]}</td>
        <td>${type["평형 세대수"]}</td>
      </tr>`;
  });

  infoHtml += `
    </table>
    <div style="margin-top: 20px;">
      <label>메모:</label>
      <textarea id="noteText" rows="5" style="width: 100%; box-sizing: border-box;"></textarea>
      <div id="imagePreview" style="margin-top: 10px; display: none; flex-wrap: wrap; gap: 8px;"></div>
      <div style="display: flex; gap: 15px; align-items: center; margin-top: 10px;">

        <label style="cursor: pointer; background: white; color: black; padding: 8px 4px; border-radius: 4px;">
          📷 사진 찍기
          <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display: none;" />
        </label>

        <label style="cursor: pointer; background: white; color: black; padding: 8px 4px; border-radius: 4px;">
          📁 파일 선택
          <input type="file" id="imageInput" accept="image/*" multiple style="display: none;" />
        </label>
<!-- 
        <label style="cursor: pointer; background: white; color: black; padding: 8px 6px; border-radius: 4px;">
          💾 저장
          <button onclick="saveNote('${apartmentId}')" style="display: none;"></button>
        </label> -->

		<label style="cursor: pointer; background: white; color: black; padding: 8px 5px; border-radius: 4px;">
		  🗑 초기화
		  <button onclick="deleteNote('${apartmentId}')" style="display: none;"></button>
		</label>
      </div>
    </div>`;

  const infoDiv = document.getElementById("apartmentInfo");
  if (!infoDiv.dataset.positioned) {
    infoDiv.style.top = "50%";
    infoDiv.style.left = "50%";
    infoDiv.style.transform = "translate(-50%, -50%)";
    infoDiv.dataset.positioned = "true";
  }
  infoDiv.innerHTML = infoHtml;
  infoDiv.style.display = "block";

  loadNote(apartmentId);

  setTimeout(() => { 
    const imageInput = document.getElementById("imageInput");
    const cameraInput = document.getElementById("cameraInput");
    const preview = document.getElementById("imagePreview");

    const handleImageFiles = (files) => {
      if (!files.length) return;
      preview.style.display = "flex";
      for (const file of files) {
        const reader = new FileReader();
        reader.onload = async function (event) {

          const imageDataUrl = event.target.result;
          if (!aptMemoImageList[apartmentId]) {
            aptMemoImageList[apartmentId] = [];
          }
			aptMemoImageList[apartmentId].push(imageDataUrl);


/*
const originalBase64 = event.target.result;

  // ✅ 압축
  const compressedBase64 = await compressImage(originalBase64, 600, 1.0);

  if (!aptMemoImageList[apartmentId]) {
    aptMemoImageList[apartmentId] = [];
  }
  aptMemoImageList[apartmentId].push(compressedBase64);
*/
          const wrapper = document.createElement("div");
          wrapper.style.position = "relative";
          wrapper.style.display = "inline-block";
          wrapper.style.marginRight = "6px";
          wrapper.style.width = "60px";
          wrapper.style.height = "60px";

          const canvas = document.createElement("canvas");
          canvas.width = 60;
          canvas.height = 60;
          canvas.style.border = "1px solid #ccc";
          canvas.style.borderRadius = "4px";
          canvas.style.cursor = "pointer";
          canvas.title = "미리보기";

          const ctx = canvas.getContext("2d");
          const img = new Image();
          img.onload = () => ctx.drawImage(img, 0, 0, 60, 60);
          img.src = imageDataUrl;

          canvas.onclick = (e) => {
            e.stopPropagation();
            const modal = document.getElementById("imageModal");
            const modalCanvas = document.getElementById("modalCanvas");
            const modalCtx = modalCanvas.getContext("2d");
            const previewImg = new Image();
            previewImg.onload = () => {
              modalCanvas.width = previewImg.width;
              modalCanvas.height = previewImg.height;
              modalCtx.drawImage(previewImg, 0, 0);
              modal.style.display = "flex";
              window.imageModalShowYn = true;
            };
            previewImg.src = imageDataUrl;
          };

          const deleteBtn = document.createElement("div");
          deleteBtn.textContent = "✕";
          deleteBtn.style.position = "absolute";
          deleteBtn.style.top = "2px";
          deleteBtn.style.right = "2px";
          deleteBtn.style.background = "rgba(0,0,0,0.6)";
          deleteBtn.style.color = "white";
          deleteBtn.style.borderRadius = "50%";
          deleteBtn.style.width = "16px";
          deleteBtn.style.height = "16px";
          deleteBtn.style.display = "flex";
          deleteBtn.style.alignItems = "center";
          deleteBtn.style.justifyContent = "center";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.fontSize = "12px";

          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm("사진을 삭제합니다")) {
              aptMemoImageList[apartmentId] = aptMemoImageList[apartmentId].filter(img => img !== imageDataUrl);
              wrapper.remove();
              if (preview.children.length === 0) {
                preview.style.display = "none";
              }
            }
          };

          wrapper.appendChild(canvas);
          wrapper.appendChild(deleteBtn);
          preview.appendChild(wrapper);
        };
        reader.readAsDataURL(file);
      }
    };

    if (imageInput) {
      imageInput.addEventListener("change", (e) => {
        handleImageFiles(e.target.files);
        e.target.value = "";
      });
    }

    if (cameraInput) {
      cameraInput.addEventListener("change", (e) => {
        handleImageFiles(e.target.files);
        e.target.value = "";
      });
    }
  }, 0);
}






// ✅ 네이버 부동산 링크 열기 함수 추가
	function openNaverRealEstate(apartmentId) {
		let url = `https://new.land.naver.com/complexes/${apartmentId}`;
		window.open(url, "_blank");
	}


document.addEventListener("click", (event) => {
    const apartmentInfo = document.getElementById("apartmentInfo");
    const imageModal = document.getElementById("imageModal");

    // apartmentInfo가 존재하지 않으면 리턴
    if (!apartmentInfo) return;

    setTimeout(() => {
        // 🔒 모달이 열려있으면 닫지 않음

        if (imageModalShowYn === true) {imageModalShowYn = false; return;}

        // apartmentInfo 내부 클릭이면 닫지 않음
        if (apartmentInfo.contains(event.target)) return;

        // 그 외엔 닫기
        if (apartmentInfo.style.display === "block") {
//console.log("실행됨");

 const apartmentInfo = document.getElementById("apartmentInfo");
 const id = apartmentInfo.getAttribute("data-id");
      const memo = document.getElementById("noteText")?.value?.trim();
      const images = aptMemoImageList?.[id] ?? [];
console.log(id);
console.log(memo);
console.log(images);
      //if ((memo && memo !== "") || images.length > 0) {
        saveNote(id); // ✅ 자동 저장
      //}




            apartmentInfo.style.display = "none";
        }
    }, 0);
});



document.getElementById("apartmentInfo").addEventListener("touchstart", function(event) {
    const infoDiv = event.currentTarget;
    infoDiv.dataset.startY = event.touches[0].clientY;
    infoDiv.dataset.startScrollTop = infoDiv.scrollTop;
}, { passive: false });

document.getElementById("apartmentInfo").addEventListener("touchmove", function(event) {
    const infoDiv = event.currentTarget;
    
    // 내부 스크롤이 가능한 경우
    if (infoDiv.scrollHeight > infoDiv.clientHeight) {
        let startY = parseFloat(infoDiv.dataset.startY);
        let startScrollTop = parseFloat(infoDiv.dataset.startScrollTop);
        let currentY = event.touches[0].clientY;
        let scrollDiff = startScrollTop + (startY - currentY);

        // ✅ 최상단에서 아래로 당기려고 할 때
        if (infoDiv.scrollTop <= 0 && scrollDiff < 0) {
            event.preventDefault();
        }
        
         // ✅ 최하단에서 위로 스크롤할 때 제한을 해제
		if (infoDiv.dataset.atBottom === "true" && scrollDiff > 0) {
			event.preventDefault();
			infoDiv.scrollTop = infoDiv.scrollHeight - infoDiv.clientHeight - 1; // ✅ 스크롤을 조정하여 정상 작동
		}

    } else {
        // ✅ 내부 스크롤이 없는 경우 바디 스크롤 차단
        event.preventDefault();
    }
}, { passive: false });

document.addEventListener("touchmove", function(event) {
    const infoDiv = document.getElementById("apartmentInfo");

    if (infoDiv.style.display === "block") {
        if (infoDiv.scrollHeight <= infoDiv.clientHeight) {
            event.preventDefault(); // 내부 스크롤이 없으면 바디 스크롤 막기
        }
    }
}, { passive: false });

let middleSchoolMarkers = []; // ✅ 지도에 표시된 중학교 마커 저장
/*
async function loadMiddleSchools() {
    try {
        const response = await fetch("middleSchools.json");
        const middleSchools = await response.json();
        
        console.log("✅ 중학교 데이터 로드 완료", middleSchools);

        window.middleSchoolData = middleSchools; // ✅ 전체 중학교 데이터 저장

        // ✅ 초기 마커 업데이트
        updateMiddleSchoolMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 중학교 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateMiddleSchoolMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 중학교 데이터 로드 실패:", error);
    }
}
*/

async function loadMiddleSchools() {
    try {
        const response = await fetch("middleSchools.json");
        let middleSchools = await response.json();

        // ✅ 중복 제거: 학교 ID를 기준으로 첫 번째 값만 유지
        const uniqueSchools = [];
        const seenIds = new Set();

        middleSchools.forEach(school => {
            if (!seenIds.has(school["학교 ID"])) {
                seenIds.add(school["학교 ID"]);
                uniqueSchools.push(school);
            }
        });

        //console.log("✅ 중복 제거 완료: 총", uniqueSchools.length, "개 학교 로드됨");

        window.middleSchoolData = uniqueSchools; // ✅ 중복 제거된 데이터 저장

        // ✅ 마커 업데이트
        updateMiddleSchoolMarkers();

        // ✅ 지도 이동 시 현재 범위 내 중학교 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            updateMiddleSchoolMarkers();
        });

    } catch (error) {
        console.error("❌ 중학교 데이터 로드 실패:", error);
    }
}



function updateMiddleSchoolMarkers() {
    const showMiddleSchools = document.getElementById("toggleMiddleSchools").checked;
	
    // ✅ 기존 중학교 마커 제거
    middleSchoolMarkers.forEach(marker => marker.setMap(null));
    middleSchoolMarkers = [];

    if (!showMiddleSchools) return; // 중학교 표시 체크 해제 시 종료
	
	if (window.map.getZoom() < 14) { 
        return; // ✅ 줌 레벨이 14보다 작으면 실행 중단
    }

    let bounds = window.map.getBounds();
    let filteredSchools = window.middleSchoolData.filter(school =>
        bounds.hasLatLng(new naver.maps.LatLng(school["위도"], school["경도"]))
    );

    filteredSchools.forEach(school => {
    // ✅ 마커 컨테이너를 markerElement로 활용
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = "midSchool.png";
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;
    infoBox.textContent = `${school["학교명"]} (${school["학업성취도"]})`;

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(school["위도"], school["경도"]),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // ✅ 우클릭 이벤트에 markerElement 전달 (테두리 활성화 가능)
    addMarkerRightClickEvent(marker, markerElement);

    middleSchoolMarkers.push(marker);
});

}


// ✅ 중학교 체크박스 변경 시 마커 업데이트
document.getElementById("toggleMiddleSchools").addEventListener("change", () => {
    updateMiddleSchoolMarkers(); // ✅ 즉시 업데이트
});

let facilityMarkers = []; // ✅ 지도에 표시된 시설 마커 저장

async function loadFacilities() {
    try {
        const response = await fetch("facility.json");
        const facilities = await response.json();

        //console.log("✅ 시설 데이터 로드 완료", facilities);
        window.facilityData = facilities; // ✅ 전체 시설 데이터 저장

        // ✅ 초기 마커 업데이트
        updateFacilityMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 시설 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateFacilityMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 시설 데이터 로드 실패:", error);
    }
}

function updateFacilityMarkers() {
    const showFacilities = document.getElementById("toggleFacilities").checked;

    // ✅ 기존 시설 마커 제거
    facilityMarkers.forEach(marker => marker.setMap(null));
    facilityMarkers = [];

    if (!showFacilities) return; // 체크 해제 시 종료
    if (window.map.getZoom() < 14) return; // ✅ 줌 레벨이 14보다 작으면 실행 중단

    let bounds = window.map.getBounds();
    let filteredFacilities = window.facilityData.filter(facility =>
        bounds.hasLatLng(new naver.maps.LatLng(facility.lat, facility.lng))
    );

    filteredFacilities.forEach(facility => {
    let iconSrc = "default.png"; // 기본 아이콘 (예외처리)
    if (facility.category === 10) {
        iconSrc = facility.description.includes("백화점") ? "depart.png" : "mart.png";
    } else if (facility.category === 9) {
        iconSrc = "hospital.png";
    }

    // ✅ 마커 컨테이너를 markerElement로 활용
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = iconSrc;
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;

    if (facility.category === 10) {
        infoBox.textContent = `${facility.description} (${facility.name})`;
    } else if (facility.category === 9) {
        infoBox.textContent = `${facility.name}`;
    }

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(facility.lat, facility.lng),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // ✅ 우클릭 이벤트에 markerElement 전달 (테두리 활성화 가능)
    addMarkerRightClickEvent(marker, markerElement);

    facilityMarkers.push(marker);
});

}

// ✅ 시설 체크박스 변경 시 마커 업데이트
document.getElementById("toggleFacilities").addEventListener("change", () => {
    updateFacilityMarkers(); // ✅ 즉시 업데이트
});

let starbucksMarkers = []; // ✅ 지도에 표시된 스타벅스 마커 저장

async function loadStarbucks() {
    try {
        const response = await fetch("starbucks.json");
        const starbucks = await response.json();

        //console.log("✅ 스타벅스 데이터 로드 완료", starbucks);
        window.starbucksData = starbucks; // ✅ 전체 스타벅스 데이터 저장

        // ✅ 초기 마커 업데이트
        updateStarbucksMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 스타벅스 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateStarbucksMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 스타벅스 데이터 로드 실패:", error);
    }
}

function updateStarbucksMarkers() {
    const showStarbucks = document.getElementById("toggleStarbucks").checked;

    // ✅ 기존 스타벅스 마커 제거
    starbucksMarkers.forEach(marker => marker.setMap(null));
    starbucksMarkers = [];

    if (!showStarbucks) return; // 체크 해제 시 종료
    if (window.map.getZoom() < 14) return; // ✅ 줌 레벨이 14보다 작으면 실행 중단

    let bounds = window.map.getBounds();
    let filteredStarbucks = window.starbucksData.filter(store =>
        bounds.hasLatLng(new naver.maps.LatLng(store.lat, store.lot))
    );

     filteredStarbucks.forEach(store => {
        let iconSrc = store.s_name.includes("R") ? "starbucksReserve.png" : "starbucks.png";

        // ✅ 마커 컨테이너를 markerElement로 활용
        const markerElement = document.createElement("div");
        markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

        const markerIcon = document.createElement("img");
        markerIcon.src = iconSrc;
        markerIcon.style = "width: 32px; height: 32px;";

        markerElement.appendChild(markerIcon);

        const marker = new naver.maps.Marker({
            position: new naver.maps.LatLng(store.lat, store.lot),
            map: window.map,
            icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
        });

        // ✅ 우클릭 이벤트에 markerElement 전달
        addMarkerRightClickEvent(marker, markerElement);

        starbucksMarkers.push(marker);
    });
}

// ✅ 스타벅스 체크박스 변경 시 마커 업데이트
document.getElementById("toggleStarbucks").addEventListener("change", () => {
    updateStarbucksMarkers(); // ✅ 즉시 업데이트
});


////////////////////////// 이동 이벤트 //////////////////////////
var activeMarker = null; // ✅ 현재 선택된 마커
var activeMarkerElement = null; // ✅ 현재 선택된 마커의 요소 (테두리 변경용)

// ✅ 🔥 마커 스타일 업데이트 함수 (선택된 경우 강조)
function updateMarkerSelection(markerElement, isSelected) {
    if (markerElement) {
        setTimeout(() => {
            markerElement.style.outline = isSelected ? "3px solid red" : "";
        }, 50); // ✅ DOM 업데이트 대기 후 스타일 적용
    }
}


function addMarkerRightClickEvent(marker, markerElement) {
    naver.maps.Event.addListener(marker, "rightclick", (e) => {
        e.domEvent.preventDefault();
        e.domEvent.stopPropagation();

        const isSiseMapActive = document.getElementById("toggleSiseMap").checked;

        console.log("🚀 마커 우클릭 감지 (ID: " + marker.apartmentId + ")");

        // ✅ 기존 선택된 마커 테두리 제거
        if (activeMarkerElement) {
            updateMarkerSelection(activeMarkerElement, false);
        }

        // ✅ 현재 선택된 마커 업데이트
        activeMarker = marker;
        activeMarkerElement = markerElement; // ✅ 기존 방식
        updateMarkerSelection(activeMarkerElement, true);

        // ✅ 만약 마커가 시세지도 마커이면 `.siseMapMarker`를 다시 찾고 스타일 적용
        if (isSiseMapActive) {
            setTimeout(() => {
                const updatedMarkerElement = markerElement.querySelector(".siseMapMarker");
                if (updatedMarkerElement) {
                    activeMarkerElement = updatedMarkerElement;
                    updateMarkerSelection(updatedMarkerElement, true);
                }
            }, 100); // ✅ DOM 업데이트 대기 후 스타일 적용
        }
    });
}





// ✅ 키보드 이벤트 등록
document.removeEventListener("keydown", handleKeyDown);
document.addEventListener("keydown", handleKeyDown);



function setupRightClickEvent() {
    let radiusCircle = null; // ✅ 반경 원 객체
    let centerMarker = null; // ✅ 반경 중심 마커

    // ✅ 지도에서 우클릭 시 (반경 1km 원 + 중심 빨간 점 추가)
    naver.maps.Event.addListener(window.map, "mousedown", function (e) {
        if (e.domEvent.button !== 2) return; // ✅ 우클릭이 아닐 경우 무시

        let clickedPosition = e.coord; // ✅ 우클릭한 위치의 좌표
        //console.log("📍 우클릭 위치:", clickedPosition);

        // ✅ 이미 반경 원이 있는 경우, 제거 후 종료 (토글 방식)
        if (radiusCircle) {
            radiusCircle.setMap(null);
            radiusCircle = null;
        }
        if (centerMarker) {
            centerMarker.setMap(null);
            centerMarker = null;
            return; // ✅ 삭제 후 새로 생성하지 않음
        }

        // ✅ 반경 1km 원 추가
        radiusCircle = new naver.maps.Circle({
            map: window.map,
            center: clickedPosition,
            radius: 1000, // ✅ 반경 1km
            strokeColor: "#FF0000",
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: "#FF0000",
            fillOpacity: 0.08
        });

        // ✅ 반경 중심에 빨간색 작은 점 추가
        centerMarker = new naver.maps.Marker({
            position: clickedPosition,
            map: window.map,
            icon: {
                content: `<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%; border: 1px solid white;"></div>`,
                anchor: new naver.maps.Point(4, 4) // ✅ 중심 정렬
            }
        });

        // ✅ 지도 중심을 클릭한 위치로 이동
        window.map.panTo(clickedPosition);
    });

    // ✅ 기본적인 우클릭 메뉴 방지
    document.addEventListener("contextmenu", function (e) {
        e.preventDefault();
    });

    //console.log("✅ 지도 로드 완료 후 우클릭 이벤트 등록됨");
}

//////////////////////////////////시세 지도 ////////////////////////////




var activeMarkerSet = null;

// ✅ IndexedDB 초기화
function initIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('hongbu', 2);

        request.onupgradeneeded = function(event) {
            const db = event.target.result;

            if (!db.objectStoreNames.contains('apartments')) {
                const store = db.createObjectStore('apartments', { keyPath: 'idType' });
                store.createIndex('id', 'id', { unique: false });
                console.log('✅ IndexedDB 업그레이드 완료: apartments store 생성됨');
            }
        };

        request.onsuccess = function(event) {
            console.log('📌 hongbu 연결 성공 (DB: hongbu)');
            resolve(event.target.result);
        };

        request.onerror = function(event) {
            console.error('❌ IndexedDB 연결 실패:', event.target.error);
            reject(event.target.error);
        };
    });
}

function initMemoIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('hongbuMemo', 2);

        request.onupgradeneeded = function(event) {
            const db = event.target.result;

           

			 if (!db.objectStoreNames.contains("apartmentNotes")) {
				db.createObjectStore("apartmentNotes", { keyPath: "id" });
			}
        };

        request.onsuccess = function(event) {
            console.log('📌 hongbuMemo 연결 성공 (DB: hongbu)');
            resolve(event.target.result);
        };

        request.onerror = function(event) {
            console.error('❌ IndexedDB 연결 실패:', event.target.error);
            reject(event.target.error);
        };
    });
}

// ✅ IndexedDB 저장 함수
function saveToIndexedDB(id, type, text, color, textColor, fontSize) {
    const request = indexedDB.open("hongbu", 2);
    request.onsuccess = function(event) {
        const db = event.target.result;
        const transaction = db.transaction(["apartments"], "readwrite");
        const store = transaction.objectStore("apartments");

        store.put({ idType: `${id}-${type}`, text, color, textColor, fontSize });

        transaction.oncomplete = () => console.log(`✅ IndexedDB 저장 완료: ${id}`);
        transaction.onerror = (e) => console.error(`❌ IndexedDB 저장 오류: ${e.target.error}`);

    };
	markerElement = document.querySelector(`[data-apartment-id='${id}']`);
	markerElement.style.maxWidth = '160px';


}

// ✅ IndexedDB에서 데이터 가져오기
function getFromIndexedDB(id, type) {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("hongbu", 2);

        request.onerror = (event) => {
            reject("❌ IndexedDB 열기 오류: " + event.target.errorCode);
        };

        request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(["apartments"], "readonly");
            const store = transaction.objectStore("apartments");

            const idType = `${id}-${type}`;
            const getRequest = store.get(idType);

            getRequest.onsuccess = () => {
                if (getRequest.result) {
                    resolve(getRequest.result);
                } else {
                    resolve({ text: "", color: "#9F9F9F", textColor: "#ffffff", fontSize: "12px" });
                }
            };

            getRequest.onerror = () => {
                reject("❌ IndexedDB 데이터 가져오기 실패");
            };
        };
    });
}
document.getElementById("toggleSiseMap").addEventListener("change", function() {
    const isChecked = this.checked;

	document.getElementById("siseExportBtn").style.display = isChecked ? "inline-block" : "none";
    document.getElementById("siseImportBtn").style.display = isChecked ? "inline-block" : "none";
	document.getElementById("siseResetBtn").style.display = isChecked ? "inline-block" : "none";
	if(!isChecked){
		removeAllLines(window.map.getBounds());
	}
    updateMarkers(window.map.getBounds())
	
});



function renderSiseMapMarker(apartment) {
    // ✅ 기존 마커가 있으면 삭제
    if (apartmentMarkers[apartment.id]) {
        naver.maps.Event.clearInstanceListeners(apartmentMarkers[apartment.id]); // 🔥 기존 리스너 제거
        apartmentMarkers[apartment.id].setMap(null); // 🔥 지도에서 삭제
        delete apartmentMarkers[apartment.id]; // 🔥 메모리에서 제거
    }

    const markerElement = document.createElement("div");
    markerElement.className = "siseMapMarker";
    markerElement.style = `
    background: #fff;
    border: 2px solid black;
    padding: 0px;
    font-size: 12px;
    text-align: center;
    border-radius: 6px;
    display: inline-block;  /* ✅ 자동 너비 설정 */
    max-width: 200px;        /* ✅ 필요하면 최대 너비 제한 */
min-width: 120px;
    word-break: keep-all;   /* ✅ 줄바꿈 방지 */
`;


    markerElement.setAttribute("data-apartment-id", apartment.id);

    const nameElement = document.createElement("div");
    nameElement.innerHTML = `${apartment.name}<br>${apartment.year.slice(-5)} ${apartment.units}세대`;
    nameElement.style = `
        font-weight: bold;
        font-size: 12px;
        margin: 5px;
overflow: hidden; /* ✅ 넘치는 내용 숨김 */
    white-space: nowrap; /* ✅ 한 줄 유지 */
    text-overflow: ellipsis; /* ✅ 말줄임 (...) 처리 */
    `;

    const tableContainer = document.createElement("div");
    tableContainer.className = "tableContainer";
    tableContainer.style = `
    background: white;
    padding: 0px;
    font-size: 12px;
min-height: 24px;
    display: block;
    width: auto;           /* ✅ 마커가 내용에 맞게 늘어나도록 */
    max-width: none;       /* ✅ 제한 제거 */
    overflow: visible;     /* ✅ 넘침 허용 */
`;


    markerElement.appendChild(nameElement);
    markerElement.appendChild(tableContainer);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: markerElement,
            anchor: new naver.maps.Point(10, 30)
        }
    });
	marker.originPosition = new naver.maps.LatLng(apartment.lat, apartment.lng); // ✅ 최초 위치 저장
    marker.apartmentId = apartment.id;

    // ✅ 중복 이벤트 방지 위해 기존 리스너 제거 후 다시 추가
    addSiseMapMarkerLeftClickEvent(marker, markerElement);
    addMarkerRightClickEvent(marker, markerElement);

    // ✅ IndexedDB에서 데이터 불러오기
    updateT2FromIndexedDB(apartment.id, markerElement, tableContainer);

    return marker;
}


// ✅ IndexedDB에서 데이터 가져와 테이블 업데이트 + 수정 가능하게 적용
function updateT2FromIndexedDB(id, markerElement, tableContainer) {
	let siseChecked = document.getElementById("toggleSiseMap").checked;
    if (!siseChecked) return;
	

    getFromIndexedDB(id, "시세1").then(data => {
        let tableData = data?.text || generateDefaultTable();
        tableContainer.innerHTML = createEditableTableHTML(id, tableData);

        let bgColor = data?.color?.trim() || '#9F9F9F';
		let textColor = data?.textColor?.trim() || '#FFFFFF';
		let fontSize = data?.fontSize?.trim();

		if (!fontSize || fontSize === "undefined" || fontSize === "") {
			fontSize = "12px";
		}


        // ✅ IndexedDB에서 가져온 값 디버깅 출력
        //console.log(`🎨 IndexedDB 불러온 데이터 (ID: ${id}):`, data);
        //console.log(`🔹 적용할 색상: 배경색=${bgColor}, 글자색=${textColor}, 글자 크기=${fontSize}`);

        markerElement.style.backgroundColor = bgColor;
        markerElement.style.color = textColor;
        markerElement.style.fontSize = fontSize;
		tableContainer.style.fontSize = fontSize;

        // ✅ 강제 적용 후 확인
        //console.log(`🟢 적용된 markerElement.style.color: ${markerElement.style.color}`);

        // ✅ 만약 color가 빈 값이면 기본값 강제 적용
        if (!markerElement.style.color || markerElement.style.color === "" || markerElement.style.color === "undefined") {
            markerElement.style.color = "#FFFFFF"; 
            //console.log(`⚠️ 강제 적용 후 markerElement.style.color: ${markerElement.style.color}`);
        }

		// ✅ tableData 값을 검사해서 값이 있으면 → 160px, 없으면 → 120px
let maxWidth = 120;

if (data?.text?.trim()) {
    // ✅ 텍스트가 비어 있지 않으면 너비를 늘림
    maxWidth = 200;
}

// ✅ markerElement에 max-width 반영
markerElement.style.maxWidth = `${maxWidth}px`;



        makeTableEditable(tableContainer); // ✅ 테이블을 수정 가능하게 설정
    }).catch(console.error);
}



// ✅ 기본 3x4 테이블 생성
function generateDefaultTable() {
    let defaultTable = [];
    for (let i = 0; i < 3; i++) {
        let row = [];
        for (let j = 0; j < 4; j++) {
            row.push("");  // 기본값 설정
        }
        defaultTable.push(row.join('\t'));
    }
    return defaultTable.join('\n'); // 줄바꿈 포함하여 저장
}

// ✅ 수정 가능한 테이블을 생성하는 함수
function createEditableTableHTML(id, textData) {
    let rows = textData.split('\n').map(row => row.split('\t'));
    const table = document.createElement("table");
    table.style.borderCollapse = "collapse";
    table.style.width = "100%";             // ✅ 자동 너비
    table.style.tableLayout = "auto";       // ✅ 열마다 유동적 너비
    table.style.color = "black";

    rows.forEach((row, rowIndex) => {
        const tr = document.createElement("tr");
        row.forEach((cell, colIndex) => {
            const td = document.createElement("td");
            td.dataset.id = id;
            td.dataset.row = rowIndex;
            td.dataset.col = colIndex;
            td.textContent = cell.trim();

            td.style = `
				border: 1px solid black;
				padding: 2px 4px;
				text-align: center;
				height: 24px;

				vertical-align: middle;
				white-space: normal;  /* ✅ 줄바꿈 허용 */
				word-break: break-word; /* ✅ 텍스트 줄바꿈 */
			`;


            tr.appendChild(td);
        });
        table.appendChild(tr);
    });

    return table.outerHTML;
}



// ✅ IndexedDB에 테이블 데이터 저장 (tableContainer가 없을 경우 복구)
function saveTableToIndexedDB(id, tableContainer) {
    if (!tableContainer) {
        console.warn(`⚠️ [saveTableToIndexedDB] tableContainer가 없습니다. ID: ${id || "undefined"}`);
        return;
    }

    // ✅ 이미 저장 중인지 체크하여 중복 실행 방지
    if (window.isSaving) {
        console.warn("⚠️ IndexedDB 저장 중, 중복 호출 방지");
        return;
    }
    window.isSaving = true;  // ✅ 저장 중 상태 플래그 설정

    let tableData = [];
    tableContainer.querySelectorAll("tr").forEach(row => {
        let rowData = [];
        row.querySelectorAll("td").forEach(td => {
            rowData.push(td.textContent.trim());
        });
        tableData.push(rowData.join('\t'));
    });

    // ✅ IndexedDB에서 기존 색상 데이터를 불러와 유지
    getFromIndexedDB(id, "시세1").then(existingData => {
        let existingColor = existingData?.color || "#9F9F9F"; // ✅ 기존 배경색 유지
        let existingTextColor = existingData?.textColor || "#ffffff"; // ✅ 기존 글자색 유지
        let existingFontSize = existingData?.fontSize || "12px"; // ✅ 기존 폰트 크기 유지

        saveToIndexedDB(id, "시세1", tableData.join('\n'), existingColor, existingTextColor, existingFontSize);
    }).catch(error => {
        console.error("❌ IndexedDB 불러오기 실패:", error);
    }).finally(() => {
        setTimeout(() => {
            window.isSaving = false;  // ✅ 일정 시간 후 다시 저장 가능하게 설정
        }, 100);
    });
}




// ✅ 셀 삭제 함수 수정 (삭제 후 오류 방지)
function deleteSelectedCells() {
    if (!selectedCells || selectedCells.size === 0) {
        console.warn("⚠️ 선택된 셀이 없음");
        return;
    }

    selectedCells.forEach(td => {
        if (td && td instanceof HTMLElement) {
            td.textContent = ""; // ✅ 내용만 삭제
        }
    });

    // ❗ activeMarkerElement가 없을 경우 복구 시도
    if (!activeMarkerElement && selectedCells.size > 0) {
        let firstCell = Array.from(selectedCells)[0];
        activeMarkerElement = firstCell.closest(".siseMapMarker");
    }

    if (activeMarkerElement) {
        let tableContainer = activeMarkerElement.querySelector(".tableContainer");
        let id = activeMarkerElement.dataset.apartmentId;

        if (!id || id === "undefined") {
            console.warn("⚠️ 삭제 후 저장할 ID가 없음.");
            return;
        }

        if (tableContainer) {
            // ✅ 불필요한 setTimeout 제거 (즉시 저장)
            saveTableToIndexedDB(id, tableContainer);
        } else {
            console.warn("⚠️ tableContainer 찾을 수 없음");
        }
    } else {
        console.warn("⚠️ activeMarkerElement가 없음");
    }
}

// ✅ 셀을 수정 가능하도록 설정 + IME 한글 입력 처리 (중복 방지)
function makeTableEditable(tableContainer) {
    let isComposing = false; // ✅ 한글 입력 중인지 확인
    let lastFocusedTd = null; // ✅ 마지막으로 포커스된 셀 저장

    tableContainer.querySelectorAll("td").forEach(td => {
        // ✅ 기존 이벤트 제거 (중복 방지)
        td.removeEventListener("click", handleTdClick);
        td.removeEventListener("compositionstart", handleCompositionStart);
        td.removeEventListener("compositionend", handleCompositionEnd);
        //td.removeEventListener("keydown", handleKeyDown);
        td.removeEventListener("blur", handleTdBlur);
        td.removeEventListener("paste", handlePaste);

        // ✅ 새로운 이벤트 추가
        td.addEventListener("click", handleTdClick);
        td.addEventListener("compositionstart", handleCompositionStart);
        td.addEventListener("compositionend", handleCompositionEnd);
        //td.addEventListener("keydown", handleKeyDown);
        td.addEventListener("blur", handleTdBlur);
        td.addEventListener("paste", handlePaste);
    });

    // ✅ 클릭 이벤트 핸들러 (셀을 클릭하면 편집 가능)
    function handleTdClick(event) {
		const td = event.target;
		td.setAttribute("contenteditable", "true");
		td.focus();
		lastFocusedTd = td;

		// ✅ 커서를 제일 오른쪽으로 이동시키기
		const range = document.createRange();
		const selection = window.getSelection();

		range.selectNodeContents(td);
		range.collapse(false); // false → 커서를 끝으로 보냄
		selection.removeAllRanges();
		selection.addRange(range);
	}


    // ✅ 한글 입력 시작 (IME 입력 감지)
    function handleCompositionStart() {
        isComposing = true;
    }

    // ✅ 한글 입력 완료 (포커스 유지 중이면 저장 안 함)
    function handleCompositionEnd(event) {
    isComposing = false; // ✅ 조합 종료 플래그
    setTimeout(() => {
        saveTableToIndexedDB(event.target.dataset.id, event.target.closest(".tableContainer"));
    }, 50);
}


    

    // ✅ 포커스 아웃 시 저장 (IME 입력 중이면 저장 방지)
    function handleTdBlur(event) {
        setTimeout(() => {
            if (isComposing) return; // ✅ IME 입력 중이면 blur 저장 방지
            isComposing = false; // ✅ 포커스가 아웃되었을 때 입력 종료
            saveTableToIndexedDB(event.target.dataset.id, event.target.closest(".tableContainer"));
        }, 50);
    }

    // ✅ 붙여넣기 이벤트 (붙여넣기 후 즉시 저장)
     function handlePaste(event) {
        event.preventDefault();
        let clipboardData = event.clipboardData || window.clipboardData;
        let pastedText = clipboardData.getData("text");

        if (!pastedText.includes("\t") && !pastedText.includes("\n")) {
            // ✅ 일반 텍스트 붙여넣기
            document.execCommand("insertText", false, pastedText);
            return;
        }

        // ✅ 엑셀에서 복사한 데이터를 테이블에 맞춰 삽입
        let rows = pastedText.split("\n").map(row => row.split("\t"));
        let startRow = parseInt(lastFocusedTd.dataset.row, 10);
        let startCol = parseInt(lastFocusedTd.dataset.col, 10);
        let table = lastFocusedTd.closest("table");

        rows.forEach((row, rowIndex) => {
            row.forEach((cellText, colIndex) => {
                let targetRow = startRow + rowIndex;
                let targetCol = startCol + colIndex;
                let targetCell = table.querySelector(`td[data-row="${targetRow}"][data-col="${targetCol}"]`);
                
                if (targetCell) {
                    targetCell.textContent = cellText.trim();
                }
            });
        });

        // ✅ 저장
        saveTableToIndexedDB(lastFocusedTd.dataset.id, lastFocusedTd.closest(".tableContainer"));
    }

/*
    // ✅ 테이블 너비 조정
    setTimeout(() => {
        adjustTableColumnWidths(tableContainer.querySelector("table"));
    }, 100);
*/    
    //enableArrowKeyNavigation(tableContainer);
    enableMultiCellSelection(tableContainer);
}



// ✅ 테이블을 수정 가능하도록 이벤트 추가 (방향키 이동 포함)
// ✅ 테이블 셀의 너비를 동적으로 조정하는 함수
// ✅ 테이블의 각 열 너비를 동적으로 조정하는 함수
// ✅ 테이블의 각 열 너비를 데이터 길이에 맞게 조정하는 함수
function adjustTableColumnWidths(table) {
    let colWidths = [];
    let totalWidth = 190; // ✅ 테이블 전체 너비 (기본값)
    let minWidth = 30;    // ✅ 최소 열 너비
    let maxWidth = 100;   // ✅ 최대 열 너비

    // 1️⃣ 각 열의 최대 텍스트 길이 계산
    table.querySelectorAll("tr").forEach(row => {
        row.querySelectorAll("td").forEach((cell, colIndex) => {
            let contentWidth = getTextWidth(cell.textContent.trim(), window.getComputedStyle(cell).font);
            colWidths[colIndex] = Math.max(colWidths[colIndex] || minWidth, contentWidth + 10); // 🔹 패딩 추가
        });
    });

    // 2️⃣ 가장 긴 열 찾기
    let totalContentWidth = colWidths.reduce((sum, w) => sum + w, 0);
    let scaleFactor = totalWidth / totalContentWidth;

    // 3️⃣ 비율에 맞춰 열 너비 조정 (최대 너비 제한)
    colWidths = colWidths.map(w => Math.min(maxWidth, Math.max(minWidth, Math.floor(w * scaleFactor))));

    // 4️⃣ 각 열에 계산된 너비 적용
    table.querySelectorAll("tr").forEach(row => {
        row.querySelectorAll("td").forEach((cell, colIndex) => {
            cell.style.minWidth = colWidths[colIndex] + "px"; // ✅ 최소 너비 적용
            cell.style.maxWidth = colWidths[colIndex] + "px"; // ✅ 최대 너비 적용
            cell.style.wordBreak = "break-word"; // ✅ 텍스트가 길면 자동 줄바꿈
        });
    });
}


// ✅ 텍스트의 실제 픽셀 너비를 계산하는 함수
function getTextWidth(text, font) {
    let canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    let context = canvas.getContext("2d");
    context.font = font || "12px Arial";
    return context.measureText(text).width;
}


// ✅ 현재 선택된 셀 목록
let selectedCells = new Set();
let lastSelectedCell = null;

// ✅ 셀 선택 기능 (Shift 키 지원)
function enableMultiCellSelection(tableContainer) {
    let isMouseDown = false;

    // ✅ 기존 이벤트 제거 (중복 방지)
    document.removeEventListener("mouseup", handleMouseUp);
    //document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("click", handleOutsideClick);

    // ✅ 이벤트 핸들러 재등록
    document.addEventListener("mouseup", handleMouseUp);
    //document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("click", handleOutsideClick);

    tableContainer.querySelectorAll("td").forEach(td => {
        td.addEventListener("mousedown", function(event) {
            event.preventDefault();
            isMouseDown = true;

            if (event.shiftKey && lastSelectedCell) {
                selectRangeCells(lastSelectedCell, td, tableContainer);
            } else {
                clearSelectedCells();
                toggleCellSelection(td);
                lastSelectedCell = td;
            }
        });

        td.addEventListener("mouseover", function(event) {
            if (isMouseDown) {
                if (event.shiftKey && lastSelectedCell) {
                    selectRangeCells(lastSelectedCell, td, tableContainer);
                } else {
                    clearSelectedCells();
                    toggleCellSelection(td);
                }
            }
        });

        td.addEventListener("mouseup", function() {
            isMouseDown = false;
        });

        td.addEventListener("click", function(event) {
            event.stopPropagation();
        });
    });
}

// ✅ 마우스 업 이벤트 핸들러 (중복 방지)
function handleMouseUp() {
    isMouseDown = false;
}
function handleKeyDown(event) {
    const activeElement = document.activeElement;

	// ✅ case 2: 지도 마커 이동용 WASD

    if (activeMarker) {
        let position = activeMarker.getPosition();
        let lat = position.lat();
        let lng = position.lng();
        let step = 0.0004;

        switch (event.key) {
            case "w": case "ㅈ": lat += step; break;
            case "s": case "ㄴ": lat -= step; break;
            case "a": case "ㅁ": lng -= step; break;
            case "d": case "ㅇ": lng += step; break;
            case "Escape":
                updateMarkerSelection(activeMarkerElement, false);
                activeMarker = null;
                activeMarkerElement = null;
                return;
            default:
                return;
        }

        let newPosition = new naver.maps.LatLng(lat, lng);
console.log(newPosition);
        activeMarker.setPosition(newPosition);
    }

    // ✅ case 1: 테이블 셀 안에서 키보드 이벤트
    if (activeElement && activeElement.tagName === "TD") {
        // IME 한글 입력 중이면 무시
        if (window.isComposing) return;

        const tableContainer = activeElement.closest(".tableContainer");
        const currentRow = parseInt(activeElement.dataset.row, 10);
        const currentCol = parseInt(activeElement.dataset.col, 10);
        const table = tableContainer.querySelector("table");

        switch (event.key) {
            case "ArrowUp":
                event.preventDefault();
                moveToCell(table, currentRow - 1, currentCol);
                return;
            case "ArrowDown":
                event.preventDefault();
                moveToCell(table, currentRow + 1, currentCol);
                return;
            case "ArrowLeft":
                event.preventDefault();
                moveToCell(table, currentRow, currentCol - 1);
                console.log("왼쪽");
                return;
            case "ArrowRight":
                event.preventDefault();
                moveToCell(table, currentRow, currentCol + 1);
                console.log("오른쪽");
                return;
            case "Delete":
            case "Backspace":
                if (selectedCells.size > 1) {
                    event.preventDefault();
                    deleteSelectedCells();
                }
                return;
        }

        // ✅ Ctrl+C 또는 Cmd+C 복사 처리
        if ((event.ctrlKey || event.metaKey) && event.key === "c") {
            if (selectedCells.size > 0) {
                event.preventDefault();

                const cellsArray = Array.from(selectedCells);
                cellsArray.sort((a, b) => {
                    const rowA = parseInt(a.dataset.row, 10);
                    const rowB = parseInt(b.dataset.row, 10);
                    if (rowA !== rowB) return rowA - rowB;
                    return parseInt(a.dataset.col, 10) - parseInt(b.dataset.col, 10);
                });

                const maxRow = Math.max(...cellsArray.map(td => parseInt(td.dataset.row)));
                const minRow = Math.min(...cellsArray.map(td => parseInt(td.dataset.row)));
                const maxCol = Math.max(...cellsArray.map(td => parseInt(td.dataset.col)));
                const minCol = Math.min(...cellsArray.map(td => parseInt(td.dataset.col)));

                const rowCount = maxRow - minRow + 1;
                const colCount = maxCol - minCol + 1;
                const grid = Array.from({ length: rowCount }, () => Array(colCount).fill(""));

                cellsArray.forEach(td => {
                    const r = parseInt(td.dataset.row) - minRow;
                    const c = parseInt(td.dataset.col) - minCol;
                    grid[r][c] = td.textContent.trim();
                });

                const tsv = grid.map(row => row.join("\t")).join("\n");

                navigator.clipboard.writeText(tsv).then(() => {
                    console.log("✅ 셀 복사 완료");
                }).catch(err => {
                    console.error("❌ 클립보드 복사 실패:", err);
                });
            }
        }
    }

    
}



// ✅ 마커 외부 클릭 시 블록 해제 (중복 방지)
function handleOutsideClick(event) {
    if (!event.target.closest(".siseMapMarker")) {
        clearSelectedCells();
    }
}

function clearSelectedCells() {
    if (!selectedCells) return;
    selectedCells.forEach(cell => {
        cell.style.backgroundColor = ""; // ✅ 기존 선택 해제
    });
    selectedCells.clear(); // ✅ Set 초기화
}


// ✅ 범위 선택 기능 (Shift 키 사용)
function selectRangeCells(startCell, endCell, tableContainer) {
    let table = tableContainer.querySelector("table");
    let startRow = parseInt(startCell.dataset.row);
    let startCol = parseInt(startCell.dataset.col);
    let endRow = parseInt(endCell.dataset.row);
    let endCol = parseInt(endCell.dataset.col);

    let minRow = Math.min(startRow, endRow);
    let maxRow = Math.max(startRow, endRow);
    let minCol = Math.min(startCol, endCol);
    let maxCol = Math.max(startCol, endCol);

    selectedCells.clear();

    for (let row = minRow; row <= maxRow; row++) {
        for (let col = minCol; col <= maxCol; col++) {
            let targetCell = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
            if (targetCell) {
                selectedCells.add(targetCell);
                targetCell.style.backgroundColor = "#FFD700"; // ✅ 노란색 블록 표시
            }
        }
    }
}

// ✅ 셀 선택/해제 기능 (Shift 미사용 시 단일 선택)
function toggleCellSelection(td) {
    if (selectedCells.has(td)) {
        selectedCells.delete(td);
        td.style.backgroundColor = ""; // ✅ 선택 해제
    } else {
        selectedCells.add(td);
        td.style.backgroundColor = "#FFD700"; // ✅ 노란색 블록 지정
    }
}


function enableArrowKeyNavigation(tableContainer) {
    const table = tableContainer.querySelector("table");
    if (!table) return;

    // ✅ 기존 td 이벤트 제거
    table.querySelectorAll("td").forEach(td => {
        td.removeEventListener("keydown", handleArrowKey); // 중복 제거
        td.addEventListener("keydown", handleArrowKey);     // 새로 등록
    });
}

function handleArrowKey(event) {
    const td = event.currentTarget;
    const currentRow = parseInt(td.dataset.row, 10);
    const currentCol = parseInt(td.dataset.col, 10);
    const table = td.closest("table");

    switch (event.key) {
        case "ArrowUp":
            event.preventDefault();
            moveToCell(table, currentRow - 1, currentCol);
            break;
        case "ArrowDown":
            event.preventDefault();
            moveToCell(table, currentRow + 1, currentCol);
            break;
        case "ArrowLeft":
            event.preventDefault();
            moveToCell(table, currentRow, currentCol - 1);
console.log("왼쪽");
            break;
        case "ArrowRight":
            event.preventDefault();
            moveToCell(table, currentRow, currentCol + 1);
console.log("오른쪽");
            break;
        case "Delete":
        case "Backspace":
            if (selectedCells && selectedCells.size > 1) {
                event.preventDefault();
                deleteSelectedCells();
            }
            break;
    }
}
function moveToCell(table, row, col) {
    console.log("➡ moveToCell 호출:", row, col);

    let maxRows = table.rows.length;
    let maxCols = table.rows[0].cells.length;

    if (row < 0 || row >= maxRows || col < 0 || col >= maxCols) {
        console.warn(`⚠️ 유효하지 않은 이동 위치: row=${row}, col=${col}`);
        return;
    }

    let targetCell = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
    console.log("🎯 targetCell:", targetCell);

    if (targetCell) {
        targetCell.setAttribute("contenteditable", "true");
        setTimeout(() => {
            targetCell.focus();

            // ✅ 커서를 텍스트 끝으로 이동
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(targetCell);
            range.collapse(false); // 끝으로 이동
            selection.removeAllRanges();
            selection.addRange(range);
        }, 10);
    }
}






function rgbToHex(rgb) {
    let rgbArray = rgb.match(/\d+/g);
    if (!rgbArray || rgbArray.length < 3) return "#000000"; // 기본값

    return `#${rgbArray
        .slice(0, 3)
        .map(x => parseInt(x).toString(16).padStart(2, "0"))
        .join("")}`.toUpperCase();
}

function showColorPickerModal(apartmentId, defaultColor, defaultTextColor, defaultFontSize, callback) {

    // ✅ 기존 모달 제거 (중복 방지)
    const existingModal = document.querySelector('.custom-modal-siseMap');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    // ✅ RGB 색상이 들어오면 HEX로 변환
    if (defaultColor.startsWith("rgb")) defaultColor = rgbToHex(defaultColor);
    if (defaultTextColor.startsWith("rgb")) defaultTextColor = rgbToHex(defaultTextColor);

    // ✅ 모달 생성
    const modal = document.createElement('div');
    modal.className = 'custom-modal-siseMap';
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = 'white';
    modal.style.border = '1px solid #ccc';
    modal.style.padding = '20px';
    modal.style.zIndex = '10000';
    modal.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
    modal.style.width = '300px';

    makeModalDraggable(modal);

    // ✅ 색상 선택 블록 추가 (14개)
    const colorDiv = document.createElement('div');
    colorDiv.className = 'color-div';
    colorDiv.style.display = 'flex';
    colorDiv.style.flexWrap = 'wrap';
    colorDiv.style.marginTop = '10px';

    const colors = ['#000000', '#454648', '#474C4F', '#FF0000', '#FF6600', '#FFFF00', 
                    '#92D050', '#00B050', '#00B0F0', '#0070C0', '#000099', '#7030A0', 
                    '#CC3399', '#FF66CC'];

    colors.forEach(color => {
        const smallSquare = document.createElement('div');
        smallSquare.className = 'small-square';
        smallSquare.style.backgroundColor = color;
        smallSquare.style.width = '24px';
        smallSquare.style.height = '24px';
        smallSquare.style.margin = '2px';
        smallSquare.style.cursor = 'pointer';
        smallSquare.style.border = '1px solid #000';

        // ✅ 블록 클릭 시 배경색 변경
        smallSquare.onclick = () => {
            colorInput.value = color;
            colorPicker.value = color;
        };

        colorDiv.appendChild(smallSquare);
    });

    modal.appendChild(colorDiv);

    // ✅ 배경색 선택 (컬러 선택기 + 직접 입력)
    const colorPickerWrapper = document.createElement('div');
    colorPickerWrapper.className = 'color-picker-wrapper';

    const colorPickerLabel = document.createElement('label');
    colorPickerLabel.textContent = '배경색 : ';
    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = defaultColor || '#1C32F7';

    const colorInput = document.createElement('input');
    colorInput.type = 'text';
    colorInput.className = 'color-input';
    colorInput.placeholder = '색상값 입력 #000000';
    colorInput.value = defaultColor || '#1C32F7';
    colorInput.style.width = '80px';
    colorInput.style.marginTop = '0px';

    colorPicker.oninput = () => {
        colorInput.value = colorPicker.value.toUpperCase();
    };

    colorPickerWrapper.appendChild(colorPickerLabel);
    colorPickerWrapper.appendChild(colorPicker);
    colorPickerWrapper.appendChild(colorInput);

    modal.appendChild(colorPickerWrapper);

    colorInput.addEventListener('input', () => {
        if (/^#[0-9A-F]{6}$/i.test(colorInput.value)) {
            colorPicker.value = colorInput.value.toUpperCase();
        }
    });

    // ✅ 글자색 선택 (컬러 선택기 + 직접 입력)
    const textColorPickerWrapper = document.createElement('div');
    textColorPickerWrapper.className = 'color-picker-wrapper';

    const textColorPickerLabel = document.createElement('label');
    textColorPickerLabel.textContent = '글자색 : ';
    const textColorPicker = document.createElement('input');
textColorPicker.type = 'color';
defaultTextColor = defaultTextColor?.trim() || '#FFFFFF'; // ✅ 기본값 강제 적용
textColorPicker.value = defaultTextColor;


const textColorInput = document.createElement('input');
textColorInput.type = 'text';
textColorInput.className = 'color-input';
textColorInput.placeholder = '색상값 입력 #FFFFFF';
textColorInput.value = defaultTextColor;

    textColorInput.style.width = '80px';
    textColorInput.style.marginTop = '0px';

    textColorPicker.oninput = () => {
        textColorInput.value = textColorPicker.value.toUpperCase();
    };

    textColorInput.addEventListener('input', () => {
        if (/^#[0-9A-F]{6}$/i.test(textColorInput.value)) {
            textColorPicker.value = textColorInput.value.toUpperCase();
        }
    });

    textColorPickerWrapper.appendChild(textColorPickerLabel);
    textColorPickerWrapper.appendChild(textColorPicker);
    textColorPickerWrapper.appendChild(textColorInput);

    modal.appendChild(textColorPickerWrapper);

    // ✅ 글자 크기 조절
    const fontSizeWrapper = document.createElement('div');
    fontSizeWrapper.className = 'font-size-wrapper';

    const fontSizeLabel = document.createElement('label');
    fontSizeLabel.textContent = '글자 크기 : ';
    const fontSizeInput = document.createElement('input');
    fontSizeInput.type = 'number';
    fontSizeInput.className = 'font-size-input';
    fontSizeInput.value = parseInt(defaultFontSize) || '13';
    fontSizeInput.style.width = '80px';

    fontSizeWrapper.appendChild(fontSizeLabel);
    fontSizeWrapper.appendChild(fontSizeInput);

    modal.appendChild(fontSizeWrapper);



const rowButtonContainer = document.createElement('div');
    rowButtonContainer.style.marginTop = '10px';


    // ✅ 버튼 컨테이너
    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '10px';
    buttonContainer.style.textAlign = 'right';

    const saveButton = document.createElement('button');
    saveButton.textContent = ' 확인 ';
    saveButton.style.marginRight = '10px';
		saveButton.onclick = () => {
		updateMarkerStyleAndSave(apartmentId, colorInput.value, textColorInput.value, fontSizeInput.value + 'px');
		closePopup();
		document.body.removeChild(modal);
	};

 const addRowButton = document.createElement('button');
    addRowButton.textContent = '행 추가';
    addRowButton.onclick = () => addRowToTable(apartmentId);
    rowButtonContainer.appendChild(addRowButton);

    const removeRowButton = document.createElement('button');
    removeRowButton.textContent = '행 제거';
    removeRowButton.onclick = () => removeRowFromTable(apartmentId);
    rowButtonContainer.appendChild(removeRowButton);

    modal.appendChild(rowButtonContainer);



const resetButton = document.createElement('button');
resetButton.textContent = ' 초기화 ';
resetButton.style.marginRight = '10px';
resetButton.onclick = () => {
    // ✅ IndexedDB에서 해당 데이터 삭제
    const request = indexedDB.open("hongbu", 2);
    request.onsuccess = function(event) {
        const db = event.target.result;
        const transaction = db.transaction(["apartments"], "readwrite");
        const store = transaction.objectStore("apartments");
        store.delete(`${apartmentId}-시세1`);
        transaction.oncomplete = () => {
            console.log("✅ 초기화 완료 (IndexedDB 삭제됨)");

            // ✅ 마커 스타일도 기본값으로 리셋
            const markerElement = document.querySelector(`[data-apartment-id='${apartmentId}']`);
            if (markerElement) {
                markerElement.style.backgroundColor = "#9F9F9F";
                markerElement.style.color = "#ffffff";
                markerElement.style.fontSize = "12px";

                const tableContainer = markerElement.querySelector(".tableContainer");
                if (tableContainer) {
                    tableContainer.innerHTML = createEditableTableHTML(apartmentId, generateDefaultTable());
                    makeTableEditable(tableContainer);
                }
            }

            // ✅ 모달 닫기
            closePopup();
            document.body.removeChild(modal);
        };
    };
};

buttonContainer.appendChild(resetButton);  // ⬅ 초기화 버튼 먼저
    buttonContainer.appendChild(saveButton);

    const cancelButton = document.createElement('button');
    cancelButton.textContent = ' 닫기 ';
    cancelButton.onclick = () => {
        document.body.removeChild(modal);
        closePopup();
    };
    buttonContainer.appendChild(cancelButton);

    modal.appendChild(buttonContainer);

    // ✅ 모달을 body에 추가
    document.body.appendChild(modal);



}

function addRowToTable(apartmentId) {
    // 해당 apartmentId의 테이블을 찾아서 새로운 행 추가
    const tableContainer = document.querySelector(`[data-apartment-id='${apartmentId}'] .tableContainer`);
    if (tableContainer) {
        const table = tableContainer.querySelector("table");

        if (table) {
            const newRow = table.insertRow();
            // 각 셀에 기본값 추가 (예: 빈 텍스트)
            for (let i = 0; i < table.rows[0].cells.length; i++) {
                const newCell = newRow.insertCell();
                newCell.textContent = ""; // 기본적으로 빈 텍스트
                newCell.style.border = "1px solid black";
                newCell.style.padding = "0px";
                newCell.style.textAlign = "center";
				newCell.style.height = "24px";
            }
			saveTableToIndexedDB(apartmentId, tableContainer);
        }
    }
}

function removeRowFromTable(apartmentId) {
    // 해당 apartmentId의 테이블을 찾아서 선택된 행 제거
    const tableContainer = document.querySelector(`[data-apartment-id='${apartmentId}'] .tableContainer`);
    if (tableContainer) {
        const table = tableContainer.querySelector("table");

        if (table && table.rows.length > 1) {
            // 마지막 행을 삭제 (최소 1개 행이 남아야 하므로)
            table.deleteRow(table.rows.length - 1);
// ✅ 삭제 후 바로 IndexedDB에 저장
            saveTableToIndexedDB(apartmentId, tableContainer);
        }
    }
}

function parsePriceDataFromTable(tableContainer) {
    const rows = tableContainer.querySelectorAll("tr");
    const parsed = [];

    rows.forEach(row => {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 3) {
            const 평형 = cells[0].textContent.trim();
            const 매매 = parseFloat(cells[1].textContent.trim());
            const 전세 = parseFloat(cells[2].textContent.trim());

            if (!isNaN(매매) && !isNaN(전세)) {
                parsed.push({ 평형, 매매, 전세 });
            }
        }
    });

    return parsed;
}

function renderPriceChart(container, data) {
    const canvas = document.createElement("canvas");
    canvas.width = 200;
    canvas.height = data.length * 25 + 20; // 평형 수에 따라 높이 조정
    canvas.style.margin = "5px";

    const ctx = canvas.getContext("2d");

    const maxPrice = Math.max(...data.flatMap(d => [d.매매, d.전세]));
    const barMaxWidth = 80;

    data.forEach((d, i) => {
        const y = i * 25 + 20;
        const label = d.평형;
        ctx.fillStyle = "#000";
        ctx.font = "12px sans-serif";
        ctx.fillText(label, 0, y);

        const saleWidth = (d.매매 / maxPrice) * barMaxWidth;
        const leaseWidth = (d.전세 / maxPrice) * barMaxWidth;

        ctx.fillStyle = "#ff4d4d"; // 빨간색 매매
        ctx.fillRect(40, y - 10, saleWidth, 8);

        ctx.fillStyle = "#4d79ff"; // 파란색 전세
        ctx.fillRect(40, y, leaseWidth, 8);
    });

    container.appendChild(canvas);
}

async function exportToJSON() {
    try {
        const db = await initIndexedDB();
        const transaction = db.transaction(['apartments'], 'readonly');
        const store = transaction.objectStore('apartments');
        const request = store.getAll();

        request.onsuccess = async function(event) {
            const data = event.target.result;
            const jsonData = JSON.stringify(data, null, 2);

            // 💾 저장할 파일 이름
            const now = new Date();
            const formattedDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
            const formattedTime = `${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const defaultFilename = `홍부_시세지도_백업_${formattedDate}_${formattedTime}.json`;

            // ✅ showSaveFilePicker로 저장 위치 선택
            const handle = await window.showSaveFilePicker({
                suggestedName: defaultFilename,
                types: [
                    {
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] }
                    }
                ]
            });

            const writable = await handle.createWritable();
            await writable.write(jsonData);
            await writable.close();

            console.log('✅ 저장 완료:', handle.name);
        };

        request.onerror = function(event) {
            console.error('❌ Export transaction error: ', event.target.errorCode);
        };
    } catch (error) {
        console.error('❌ 오류 발생:', error);
    }
}


function importFromJSON(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        const data = JSON.parse(event.target.result);

        initIndexedDB().then(db => {
            const transaction = db.transaction(['apartments'], 'readwrite');
            const store = transaction.objectStore('apartments');

            data.forEach(item => {
                // ✅ 누락된 필드 보완
                if (!item.type) item.type = '시세1';
                if (!item.idType) item.idType = `${item.id}-${item.type}`;
                store.put(item);
            });

            transaction.oncomplete = function() {
				alert('✅ 시세 데이터를 성공적으로 가져왔습니다.');

				// ❗ 시세지도 활성화 상태일 경우, 마커 다시 그리기
				if (document.getElementById("toggleSiseMap").checked && window.map) {
					prevSiseMapState = "초기화";
					updateMarkers(window.map.getBounds());
				}
			};


            transaction.onerror = function(event) {
                console.error('❌ Import transaction error:', event.target.errorCode);
            };
        }).catch(error => {
            console.error('❌ Failed to initialize hongbu DB:', error);
        });
    };

    reader.readAsText(file);
}


/////////////////////////////////////////////////////////////////////////////////////////
let deletedImages = []; // 삭제된 이미지 목록
function saveNote(id) {
  const memo = document.getElementById("noteText").value;
  const images = (aptMemoImageList && aptMemoImageList[id]) ? aptMemoImageList[id] : [];

  const request = indexedDB.open("hongbuMemo", 2);
  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readwrite");
    const store = transaction.objectStore("apartmentNotes");

    const getRequest = store.get(id);
    getRequest.onsuccess = function () {
      let existing = getRequest.result || { id, memo: "", images: [] };

      existing.images = images;
      existing.memo = memo;

      store.put(existing);

      //alert("저장되었습니다!");
      loadNote(id);

      // ✅ 마커 갱신 처리
      const marker = apartmentMarkers[id];
      if (marker) {
        marker.setMap(null);  // 기존 마커 제거
        delete apartmentMarkers[id];  // 캐시 삭제

        const apartment = apartmentData.find(a => String(a.id) === String(id));
        if (apartment) {
          const isSiseMap = document.getElementById("toggleSiseMap")?.checked;
          const newMarker = isSiseMap
            ? renderSiseMapMarker(apartment)
            : createDefaultMarker(apartment);
          newMarker.__siseMap = isSiseMap;
          apartmentMarkers[id] = newMarker;
        }
      }
    };
  };
}




function base64ToBlobUrl(base64) {
    const byteString = atob(base64.split(',')[1]);
    const mimeString = base64.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    const blob = new Blob([ab], { type: mimeString });
    return URL.createObjectURL(blob);
}

function createCanvasThumbnail(blobUrl, base64, idx, onDelete) {
    const wrapper = document.createElement("div");
    wrapper.style.position = "relative";
    wrapper.style.display = "inline-block";
    wrapper.style.marginRight = "6px";
    wrapper.style.width = "60px";
    wrapper.style.height = "60px";

    const canvas = document.createElement("canvas");
    canvas.width = 60;
    canvas.height = 60;
    canvas.style.border = "1px solid #ccc";
    canvas.style.borderRadius = "4px";
    canvas.style.cursor = "pointer";
    canvas.title = `사진 ${idx + 1}`;

    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
        ctx.drawImage(img, 0, 0, 60, 60);
    };
    img.src = blobUrl;

    canvas.onclick = (e) => {
	  e.stopPropagation();

	  const modal = document.getElementById("imageModal");
	  const modalCanvas = document.getElementById("modalCanvas");
	  const ctx = modalCanvas.getContext("2d");

	  const img = new Image();
	  img.onload = () => {
		// 이미지 크기에 맞게 캔버스 조절
		modalCanvas.width = img.width;
		modalCanvas.height = img.height;
		ctx.drawImage(img, 0, 0);
		modal.style.display = "flex";
		window.imageModalShowYn = true;
	  };
	  img.src = blobUrl;
	};


    const deleteBtn = document.createElement("div");
    deleteBtn.textContent = "✕";
    deleteBtn.style.position = "absolute";
    deleteBtn.style.top = "2px";
    deleteBtn.style.right = "2px";
    deleteBtn.style.background = "rgba(0,0,0,0.6)";
    deleteBtn.style.color = "white";
    deleteBtn.style.borderRadius = "50%";
    deleteBtn.style.width = "16px";
    deleteBtn.style.height = "16px";
    deleteBtn.style.display = "flex";
    deleteBtn.style.alignItems = "center";
    deleteBtn.style.justifyContent = "center";
    deleteBtn.style.cursor = "pointer";
    deleteBtn.style.fontSize = "12px";

    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        if (confirm("사진을 삭제합니다")) {
            onDelete(base64);
            wrapper.remove();
        }
    };

    wrapper.appendChild(canvas);
    wrapper.appendChild(deleteBtn);
    return wrapper;
}

function loadNote(id) {
  const request = indexedDB.open("hongbuMemo", 2);
  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readonly");
    const store = transaction.objectStore("apartmentNotes");

    const getRequest = store.get(id);
    getRequest.onsuccess = function () {
      const result = getRequest.result;
      //if (!result) return;
	const noteEl = document.getElementById("noteText");
      const preview = document.getElementById("imagePreview");
    

 if (!result) {
        // ✅ 데이터가 없는 경우 UI 초기화
        if (noteEl) noteEl.value = "";
        if (preview) {
          preview.innerHTML = "";
          preview.style.display = "none";
        }
        aptMemoImageList[id] = [];
        return;
      }


  
preview.innerHTML = "";
      document.getElementById("noteText").value = result.memo || "";
	  if(result.images.length > 0){
		preview.style.display = "flex";
	 }
      aptMemoImageList[id] = result.images || [];

      
    

      for (const imageDataUrl of aptMemoImageList[id]) {
        const wrapper = document.createElement("div");
        wrapper.style.position = "relative";
        wrapper.style.display = "inline-block";
        wrapper.style.marginRight = "6px";
        wrapper.style.width = "60px";
        wrapper.style.height = "60px";

        const canvas = document.createElement("canvas");
        canvas.width = 60;
        canvas.height = 60;
        canvas.style.border = "1px solid #ccc";
        canvas.style.borderRadius = "4px";
        canvas.style.cursor = "pointer";
        canvas.title = "미리보기";

        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, 60, 60);
        };
        img.src = imageDataUrl;

       canvas.onclick = (e) => {
  e.stopPropagation();
  const modal = document.getElementById("imageModal");
  const modalCanvas = document.getElementById("modalCanvas");
  const modalCtx = modalCanvas.getContext("2d");

  const fullImage = new Image();
  fullImage.onload = () => {
    modalCanvas.width = fullImage.width;
    modalCanvas.height = fullImage.height;
    modalCtx.drawImage(fullImage, 0, 0);
    modal.style.display = "flex";
    window.imageModalShowYn = true;
  };
  fullImage.src = img.src; // ✅ 썸네일 이미지 말고 원본으로 새로 로드
};


        const deleteBtn = document.createElement("div");
        deleteBtn.textContent = "✕";
        deleteBtn.style.position = "absolute";
        deleteBtn.style.top = "2px";
        deleteBtn.style.right = "2px";
        deleteBtn.style.background = "rgba(0,0,0,0.6)";
        deleteBtn.style.color = "white";
        deleteBtn.style.borderRadius = "50%";
        deleteBtn.style.width = "16px";
        deleteBtn.style.height = "16px";
        deleteBtn.style.display = "flex";
        deleteBtn.style.alignItems = "center";
        deleteBtn.style.justifyContent = "center";
        deleteBtn.style.cursor = "pointer";
        deleteBtn.style.fontSize = "12px";

        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm("사진을 삭제합니다")) {
            aptMemoImageList[id] = aptMemoImageList[id].filter(img => img !== imageDataUrl);
            wrapper.remove();
          }
        };

        wrapper.appendChild(canvas);
        wrapper.appendChild(deleteBtn);
        preview.appendChild(wrapper);
      }
    };
  };
}




// ✅ 모달 닫기 이벤트도 등록
document.getElementById("imageModal").addEventListener("click", () => {
    document.getElementById("imageModal").style.display = "none";
	imageModalShowYn = true;
});


function showImageModal(src) {
    const modal = document.getElementById("imageModal");
    const modalImg = document.getElementById("modalImage");
    modalImg.src = src;
    modal.style.display = "flex";
}

// ✅ 메모 백업
function backupMemoDB() {
    const request = indexedDB.open("hongbuMemo", 2);
    request.onsuccess = function (event) {
        const db = event.target.result;
        const transaction = db.transaction(["apartmentNotes"], "readonly");
        const store = transaction.objectStore("apartmentNotes");

        const allData = [];
        store.openCursor().onsuccess = function (event) {
            const cursor = event.target.result;
            if (cursor) {
                allData.push(cursor.value);
                cursor.continue();
            } else {
                const blob = new Blob([JSON.stringify(allData, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `홍부_메모백업_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        };
    };
}

// ✅ 메모 복원
function restoreMemoDB() {
    document.getElementById("memoRestoreInput").click();

    document.getElementById("memoRestoreInput").onchange = function (e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
            try {
                const jsonData = JSON.parse(event.target.result);
                if (!Array.isArray(jsonData)) {
                    alert("유효하지 않은 백업 파일입니다.");
                    return;
                }

                const request = indexedDB.open("hongbuMemo", 2);
                request.onsuccess = function (event) {
                    const db = event.target.result;
                    const transaction = db.transaction(["apartmentNotes"], "readwrite");
                    const store = transaction.objectStore("apartmentNotes");

                    jsonData.forEach(entry => store.put(entry));
                    alert("메모 복원이 완료되었습니다.");
                };
            } catch (err) {
                alert("파일 읽기 오류: " + err.message);
            }
        };
        reader.readAsText(file);
    };
}

document.getElementById("copyImageButton").onclick = async () => {
  const canvas = document.getElementById("modalCanvas");

  canvas.toBlob(async (blob) => {
    try {
      await navigator.clipboard.write([
        new ClipboardItem({ "image/png": blob })
      ]);
      //alert("이미지를 클립보드에 복사했습니다!");
    } catch (err) {
      console.error("이미지 복사 실패:", err);
      alert("복사에 실패했습니다. 브라우저가 지원하지 않을 수 있습니다.");
    }
  }, "image/png");
};

function deleteMemoDB() {
  const confirmDelete = confirm("⚠️ 모든 메모와 이미지가 삭제됩니다. 계속하시겠습니까?");
  if (!confirmDelete) return;

  const deleteRequest = indexedDB.deleteDatabase("hongbuMemo");
  deleteRequest.onsuccess = () => {
    alert("✅ 메모 DB가 삭제되었습니다. 페이지를 새로고침합니다.");
    location.reload();
  };
  deleteRequest.onerror = (event) => {
    console.error("❌ DB 삭제 실패:", event.target.error);
    //alert("❌ 메모 DB 삭제 중 오류가 발생했습니다.");328
  };
}

function deleteNote(id) {
  if (!confirm("정말 이 메모와 이미지를 삭제하시겠습니까?")) return;

  const request = indexedDB.open("hongbuMemo", 2);
  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readwrite");
    const store = transaction.objectStore("apartmentNotes");

    const deleteRequest = store.delete(id);
    deleteRequest.onsuccess = function () {
      //alert("해당 아파트 메모가 초기화되었습니다.");
      loadNote(id);
    };
  };
}
function getMemoFromIndexedDB(id) {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("hongbuMemo", 2);
        request.onerror = () => reject("DB 열기 실패");
        request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(["apartmentNotes"], "readonly"); // ✅ 정확한 store 이름
            const store = transaction.objectStore("apartmentNotes");
            const getRequest = store.get(String(id));
            getRequest.onsuccess = () => resolve(getRequest.result);
            getRequest.onerror = () => reject("데이터 가져오기 실패");
        };
    });
}


</script>





</body>
</html>
