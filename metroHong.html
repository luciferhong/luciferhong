<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<link rel="icon" href="metro.png" type="image/png">
  <title>[ë£¨ì‹œí¼í™] 27íƒ„ ì§€í•˜ì²˜ë¥´í™</title>
  <script type="text/javascript" src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=9t8y33hyq8"></script>
  <style>
   
#map { width: 100%; height: calc(100vh - 65px); resize: both; }
    #checkbox-container {
      position: absolute;
      top: 65px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-family: sans-serif;
      font-size: 13px;
      max-height: 90vh;
      overflow-y: auto;
    }

    #checkbox-container label {
      display: block;
      margin-bottom: 4px;
    }

    /* âœ… ê²½ê³„ì„  ë¼ë²¨ ìŠ¤íƒ€ì¼ */
    .emd-label{
      font-weight: 800;
      color: #0b1b3a;
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      box-shadow: none;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 0 2px rgba(255,255,255,0.9), 0 0 6px rgba(255,255,255,0.7);
    }

    .sig-label{
      font-weight: 800;
      color: #111;
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      box-shadow: none;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 0 2px rgba(255,255,255,0.9), 0 0 6px rgba(255,255,255,0.7);
    }
  </style>
</head>
<body>
<h1 style="font-size: 20px; font-weight: bold; text-align: left; margin-left:10px">
    [ë£¨ì‹œí¼í™] 27íƒ„ ì§€í•˜ì²˜ë¥´í™(ê·¸ ì–´ë””ì—ë„ ì—†ëŠ” ì§€í•˜ì²  ë…¸ì„ ë„)
</h1>
<div id="map"></div>
<div id="checkbox-container"></div>

<!-- 
<div id="control-panel" style="position:absolute; top:10px; right:10px; background:white; padding:10px; border-radius:6px; z-index:1000; box-shadow:0 2px 6px rgba(0,0,0,0.2); font-family:sans-serif; font-size:13px;">
  <button id="start-btn">ì‹œì‘</button>
  <button id="reset-btn">ë¦¬ì…‹</button>
  <button id="copy-btn">ë³µì‚¬</button>
  <pre id="output" style="margin-top:10px; max-height:300px; overflow:auto; white-space:pre-wrap;"></pre>
</div>  -->

<script>
const map = new naver.maps.Map('map', {
  center: new naver.maps.LatLng(37.5665, 126.9780),
  zoom: 13
});

const SIG_GEOJSON_PARTS = ["sig_from_emd_wgs84_utf8_2025-11-01_sggfields_part01.geojson", "sig_from_emd_wgs84_utf8_2025-11-01_sggfields_part02.geojson"];

let emdGeojsonRaw = null;
let emdPrepared = null;
let emdPolygons = [];
let emdLabels = [];
let emdRedrawTimer = null;
let emdBoundMap = null;

let sigGeojsonRaw = null;
let sigPrepared = null;
let sigPolygons = [];
let sigLabels = [];
let sigStyleMode = "default";

const lineCheckboxes = {};
const lineLayers = {};
const markers = [];
let lastLoadedData = null;

const container = document.getElementById('checkbox-container');

// ìŠ¬ë¼ì´ë” UI
const opacityWrapper = document.createElement('div');
opacityWrapper.style.marginBottom = '10px';

const opacityLabel = document.createElement('div');
opacityLabel.textContent = 'ì§€ë„ íˆ¬ëª…ë„';
opacityLabel.style.marginBottom = '4px';
opacityLabel.style.fontWeight = 'bold';

const opacityInput = document.createElement('input');
opacityInput.type = 'range';
opacityInput.min = 0;
opacityInput.max = 100;
opacityInput.value = 45; // âœ… ì´ˆê¸°ê°’ì„ 30ìœ¼ë¡œ ì„¤ì •
opacityInput.style.width = '100%';
opacityInput.title = 'ì§€ë„ ì´ë¯¸ì§€ íˆ¬ëª…ë„';

opacityWrapper.appendChild(opacityLabel);
opacityWrapper.appendChild(opacityInput);
container.prepend(opacityWrapper);

applyOpacity(); // âœ… ì´ˆê¸° íˆ¬ëª…ë„ ì ìš©


// ì—­ëª… í‘œê¸° ì²´í¬ë°•ìŠ¤
const stationLabelToggle = document.createElement('label');
stationLabelToggle.style.display = 'block';
stationLabelToggle.style.marginTop = '10px';

const stationCheckbox = document.createElement('input');
stationCheckbox.type = 'checkbox';
stationCheckbox.checked = true;
stationCheckbox.style.marginRight = '4px';

stationLabelToggle.appendChild(stationCheckbox);
stationLabelToggle.appendChild(document.createTextNode('ì—­ëª… í‘œê¸°'));
opacityWrapper.appendChild(stationLabelToggle);

// íˆ¬ëª…ë„ ì ìš© í•¨ìˆ˜
function applyOpacity() {
  const opacity = opacityInput.value / 100;
  document.querySelectorAll('#map img').forEach(img => {
    img.style.opacity = opacity;
  });
}

opacityInput.addEventListener('input', applyOpacity);

// ì§€ë„ í™•ëŒ€/ì¶•ì†Œ ì‹œì—ë„ ìœ ì§€
const observer = new MutationObserver(() => {
  setTimeout(applyOpacity, 10);
});
observer.observe(document.getElementById('map'), { childList: true, subtree: true });

// ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
fetch('data-metro-line-1.0.0.json')
  .then(res => res.json())
  .then(data => {
    lastLoadedData = data;
    const lines = data.DATA;

    // ì „ì²´ ì„ íƒ/í•´ì œ
    const allLabel = document.createElement('label');
    const allCheckbox = document.createElement('input');
    allCheckbox.type = 'checkbox';
    allCheckbox.checked = true;
    allLabel.appendChild(allCheckbox);
    allLabel.append(' ì „ì²´ ì„ íƒ / í•´ì œ');
    container.appendChild(allLabel);
    container.appendChild(document.createElement('hr'));

    allCheckbox.addEventListener('click', () => {
      const isChecked = allCheckbox.checked;
      Object.entries(lineCheckboxes).forEach(([lineId, checkbox]) => {
        checkbox.checked = isChecked;
        lineLayers[lineId].forEach(obj => obj.setMap(isChecked ? map : null));
      });
      updateMarkers(lastLoadedData);
    });

    // ë…¸ì„ ë³„ UI ë° ë ˆì´ì–´
    lines.forEach(line => {
      const sections = line.node;
      const firstStation = sections[0]?.station[0];
      const lineId = firstStation?.line || 'ë…¸ì„ ';

      if (!lineLayers[lineId]) {
        lineLayers[lineId] = [];

        const label = document.createElement('label');
label.style.display = 'flex';
label.style.alignItems = 'center';
label.style.gap = '6px';  // ì²´í¬ë°•ìŠ¤ì™€ ë„¤ëª¨ ì‚¬ì´ ê°„ê²©

const checkbox = document.createElement('input');
checkbox.type = 'checkbox';
checkbox.checked = true;
checkbox.dataset.line = lineId;
lineCheckboxes[lineId] = checkbox;

// ìƒ‰ìƒ ë°•ìŠ¤
const colorBox = document.createElement('span');
colorBox.style.width = '12px';
colorBox.style.height = '12px';
colorBox.style.backgroundColor = line.color || '#000';
colorBox.style.borderRadius = '2px';
colorBox.style.flexShrink = '0';

// ë…¸ì„  í…ìŠ¤íŠ¸
const labelText = document.createElement('span');
labelText.textContent = `${lineId}`;

// ì¡°ë¦½
label.appendChild(checkbox);
label.appendChild(colorBox);
label.appendChild(labelText);
container.appendChild(label);



        checkbox.addEventListener('change', () => {
          const isVisible = checkbox.checked;
          lineLayers[lineId].forEach(obj => obj.setMap(isVisible ? map : null));

          // ì „ì²´ ì„ íƒ ìƒíƒœ ë°˜ì˜
          allCheckbox.checked = Object.values(lineCheckboxes).every(cb => cb.checked);

          // ë§ˆì»¤ ê°±ì‹ 
          updateMarkers(lastLoadedData);
        });
      }

      sections.forEach(section => {
        // ì„  (NewVia ê¸°ì¤€)
        if (Array.isArray(section.NewVia)) {
          section.NewVia.forEach(pathArray => {
            const path = pathArray.map(([lat, lng]) => new naver.maps.LatLng(lat, lng));
            const polyline = new naver.maps.Polyline({
              path,
              map: map,
              strokeColor: line.color || '#000000',
              strokeWeight: 4,
              strokeOpacity: 1
            });
            lineLayers[lineId].push(polyline);
          });
        }
      });
    });

    // ìµœì´ˆ ë§ˆì»¤ í‘œì‹œ
    updateMarkers(lastLoadedData);
  });


// ë§ˆì»¤ ê°±ì‹  í•¨ìˆ˜
function updateMarkers(data) {
  markers.forEach(({ marker }) => marker.setMap(null));
  markers.length = 0;

  const showStations = stationCheckbox.checked;

  Object.entries(lineCheckboxes).forEach(([lineId, checkbox]) => {
    if (checkbox.checked) {
      const line = data.DATA.find(l => l.node[0]?.station[0]?.line === lineId);
      if (line) {
        line.node.forEach(section => {
          section.station.forEach(station => {
            const isDuplicate = markers.some(m => m.name === station.name);
            if (!isDuplicate && showStations) {
              const marker = new naver.maps.Marker({
                position: new naver.maps.LatLng(station.lat, station.lng),
                map: map,
                icon: {
                  content: `
                    <div style="
                      background: white;
                      padding: 2px 6px;
                      border: 1px solid #555;
                      border-radius: 3px;
                      font-size: 12px;
                      font-weight: bold;
                      color: black;
                      white-space: nowrap;
                      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
                    ">${station.name}</div>`,
                  size: new naver.maps.Size(80, 20),
                  anchor: new naver.maps.Point(40, 10)
                }
              });
              markers.push({ marker, name: station.name });
            }
          });
        });
      }
    }
  });
}

// ì—­ëª… í‘œê¸° í† ê¸€ ì‹œ ë§ˆì»¤ ê°±ì‹ 
stationCheckbox.addEventListener('change', () => {
  updateMarkers(lastLoadedData);
});


/// ì¢Œí‘œêµ¬í•˜ê¸°
let isRecording = false;
const coords = [];
const outputEl = document.getElementById('output');

// ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì‹œ ê¸°ë¡ ì‹œì‘
if (document.getElementById('start-btn')) {
  document.getElementById('start-btn').addEventListener('click', () => {
    isRecording = true;
  });
}

// ë¦¬ì…‹ ë²„íŠ¼ í´ë¦­ ì‹œ ì´ˆê¸°í™”
if (document.getElementById('reset-btn')) {
  document.getElementById('reset-btn').addEventListener('click', () => {
    isRecording = false;
    coords.length = 0;
    if (outputEl) outputEl.textContent = '';
  });
}

// ë³µì‚¬ ë²„íŠ¼ í´ë¦­ ì‹œ í´ë¦½ë³´ë“œë¡œ ë³µì‚¬
if (document.getElementById('copy-btn')) {
  document.getElementById('copy-btn').addEventListener('click', () => {
    const text = outputEl && outputEl.textContent ? outputEl.textContent.trim() : '';
    if (!text) {
      alert("ë³µì‚¬í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }
    navigator.clipboard.writeText(text)
      .then(() => alert("ì¢Œí‘œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!"))
      .catch(err => alert("ë³µì‚¬ ì‹¤íŒ¨: " + err));
  });
}

// ì§€ë„ í´ë¦­ ì‹œ ì¢Œí‘œ ì €ì¥ ë° ë§ˆì»¤ í‘œì‹œ
naver.maps.Event.addListener(map, 'click', function(e) {
  if (!isRecording) return;

  const lat = parseFloat(e.coord.lat().toFixed(5));
  const lng = parseFloat(e.coord.lng().toFixed(5));
  coords.push([lat, lng]);

  // í´ë¦­í•œ ìœ„ì¹˜ì— ë§ˆì»¤ í‘œì‹œ
  new naver.maps.Marker({
    position: new naver.maps.LatLng(lat, lng),
    map: map,
    icon: {
      content: `<div style="
        background: yellow;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: bold;
        color: black;
        border: 1px solid #333;
      ">ğŸ“</div>`,
      size: new naver.maps.Size(24, 24),
      anchor: new naver.maps.Point(12, 12)
    }
  });

  // ì¶œë ¥ì°½ì— ëˆ„ì  ì¢Œí‘œ í‘œì‹œ
  outputEl.textContent = coords.map(c => `[${c[0]}, ${c[1]}]`).join(',\n') + ',';
});

// ==============================
// âœ… ê²½ê³„ì„  ë Œë”ë§ í•¨ìˆ˜ (hongbutest.htmlì—ì„œ ì¶”ì¶œ)
// ==============================

function bboxIntersects(bounds, bbox) {
  const sw = bounds.getSW();
  const ne = bounds.getNE();
  const minLng = bbox[0], minLat = bbox[1], maxLng = bbox[2], maxLat = bbox[3];
  if (maxLng < sw.lng()) return false;
  if (minLng > ne.lng()) return false;
  if (maxLat < sw.lat()) return false;
  if (minLat > ne.lat()) return false;
  return true;
}

function _prepareFeatureBBoxes(featureCollection) {
  const feats = featureCollection?.features || [];
  return feats.map(f => {
    const geom = f.geometry;
    const polys = (geom.type === "MultiPolygon") ? geom.coordinates : [geom.coordinates];
    let minLng=Infinity, minLat=Infinity, maxLng=-Infinity, maxLat=-Infinity;
    for (const poly of polys) {
      const ring = poly[0];
      for (const pt of ring) {
        const lng = pt[0], lat = pt[1];
        if (lng < minLng) minLng = lng;
        if (lat < minLat) minLat = lat;
        if (lng > maxLng) maxLng = lng;
        if (lat > maxLat) maxLat = lat;
      }
    }
    return { geometry: geom, properties: f.properties || {}, bbox: [minLng, minLat, maxLng, maxLat] };
  });
}

function prepareSigPreparedOnce() {
  if (sigPrepared) return;
  if (!sigGeojsonRaw) throw new Error("SIG GeoJSON not loaded");
  sigPrepared = _prepareFeatureBBoxes(sigGeojsonRaw);
}

function prepareEmdPreparedOnce() {
  if (emdPrepared) return;
  if (!emdGeojsonRaw) throw new Error("EMD GeoJSON not loaded");
  emdPrepared = _prepareFeatureBBoxes(emdGeojsonRaw);
}

// âœ… polylabel ì•Œê³ ë¦¬ì¦˜ê³¼ ì§€ì˜¤ë©”íŠ¸ë¦¬ í—¬í¼ í•¨ìˆ˜ë“¤
function _emd_pointToPolygonDist(x, y, polygon) {
  let inside = false;
  let minDistSq = Infinity;
  for (let k = 0; k < polygon.length; k++) {
    const ring = polygon[k];
    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      const ax = ring[i][0], ay = ring[i][1];
      const bx = ring[j][0], by = ring[j][1];
      const intersect = ((ay > y) !== (by > y)) && (x < (bx - ax) * (y - ay) / (by - ay + 0.0) + ax);
      if (intersect) inside = !inside;
      const dx = bx - ax, dy = by - ay;
      let t = ((x - ax) * dx + (y - ay) * dy) / (dx * dx + dy * dy);
      t = Math.max(0, Math.min(1, t));
      const px = ax + t * dx, py = ay + t * dy;
      const distSq = (x - px) * (x - px) + (y - py) * (y - py);
      if (distSq < minDistSq) minDistSq = distSq;
    }
  }
  const dist = Math.sqrt(minDistSq);
  return inside ? dist : -dist;
}

function _emd_polylabel(polygon, precision = 1e-5) {
  const outer = polygon[0];
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const p of outer) {
    const x = p[0], y = p[1];
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
  }
  const width = maxX - minX;
  const height = maxY - minY;
  const cellSize = Math.min(width, height);
  if (!isFinite(cellSize) || cellSize === 0) return outer[0];
  function Cell(x, y, h, d) {
    this.x = x; this.y = y; this.h = h;
    this.d = d;
    this.max = this.d + this.h * Math.SQRT2;
  }
  let h = cellSize / 2;
  let cells = [];
  for (let x = minX; x < maxX; x += cellSize) {
    for (let y = minY; y < maxY; y += cellSize) {
      const cx = x + h, cy = y + h;
      const d = _emd_pointToPolygonDist(cx, cy, polygon);
      cells.push(new Cell(cx, cy, h, d));
    }
  }
  let best = new Cell((minX + maxX) / 2, (minY + maxY) / 2, 0, _emd_pointToPolygonDist((minX + maxX) / 2, (minY + maxY) / 2, polygon));
  const fp = outer[0];
  const fpCell = new Cell(fp[0], fp[1], 0, _emd_pointToPolygonDist(fp[0], fp[1], polygon));
  if (fpCell.d > best.d) best = fpCell;
  cells.sort((a, b) => b.max - a.max);
  while (cells.length) {
    const cell = cells.shift();
    if (cell.d > best.d) best = cell;
    if (cell.max - best.d <= precision) continue;
    const h2 = cell.h / 2;
    const children = [[cell.x - h2, cell.y - h2], [cell.x + h2, cell.y - h2], [cell.x - h2, cell.y + h2], [cell.x + h2, cell.y + h2]];
    for (const c of children) {
      const cx = c[0], cy = c[1];
      const d = _emd_pointToPolygonDist(cx, cy, polygon);
      const child = new Cell(cx, cy, h2, d);
      let idx = 0;
      while (idx < cells.length && cells[idx].max > child.max) idx++;
      cells.splice(idx, 0, child);
    }
  }
  return [best.x, best.y];
}

function _emd_clamp(v, a, b) {
  return Math.max(a, Math.min(b, v));
}

function _emd_aspectFromBbox(bbox){
  const [minLng, minLat, maxLng, maxLat] = bbox;
  const w = Math.max(1e-12, (maxLng - minLng));
  const h = Math.max(1e-12, (maxLat - minLat));
  return w > h ? (w / h) : (h / w);
}

function _emd_lerp(a, b, t){
  return [a[0] + (b[0]-a[0])*t, a[1] + (b[1]-a[1])*t];
}

function _emd_ringCentroidLngLat(ring){
  let area = 0, cx = 0, cy = 0;
  const n = ring.length;
  if (n < 3) return null;
  for (let i=0;i<n;i++){
    const [x1,y1]=ring[i];
    const [x2,y2]=ring[(i+1)%n];
    const a = x1*y2 - x2*y1;
    area += a;
    cx += (x1+x2)*a;
    cy += (y1+y2)*a;
  }
  area *= 0.5;
  if (Math.abs(area) < 1e-12) return null;
  return [cx/(6*area), cy/(6*area)];
}

function getLabelLatLngByPolylabel(geometry, bbox) {
  const polys = (geometry.type === "MultiPolygon") ? geometry.coordinates : [geometry.coordinates];
  let bestPoly = polys[0];
  let bestArea = -1;
  for (const p of polys) {
    const ring = p[0];
    let a = 0;
    for (let i = 0; i < ring.length; i++) {
      const [x1, y1] = ring[i];
      const [x2, y2] = ring[(i + 1) % ring.length];
      a += (x1 * y2 - x2 * y1);
    }
    a = Math.abs(a * 0.5);
    if (a > bestArea) {
      bestArea = a;
      bestPoly = p;
    }
  }
  const pl = _emd_polylabel(bestPoly, 1e-5);
  const ct = _emd_ringCentroidLngLat(bestPoly[0]) || pl;
  const ar = _emd_aspectFromBbox(bbox);
  const t = _emd_clamp((ar - 1) / 3, 0.2, 0.8);
  const blended = _emd_lerp(pl, ct, t);
  return new naver.maps.LatLng(blended[1], blended[0]);
}

// âœ… ë¼ë²¨ í°íŠ¸ í¬ê¸° ìë™ ê³„ì‚°
function _label_getBboxPixelSize(bbox, map){
  try{
    const proj = map && map.getProjection && map.getProjection();
    if (!proj) return null;
    const sw = proj.fromCoordToOffset(new naver.maps.LatLng(bbox[1], bbox[0]));
    const ne = proj.fromCoordToOffset(new naver.maps.LatLng(bbox[3], bbox[2]));
    return { width: Math.abs(ne.x - sw.x), height: Math.abs(ne.y - sw.y) };
  }catch(e){
    return null;
  }
}

function _label_measureTextPx(text, fontSizePx, fontWeight = 800, fontFamily = "sans-serif") {
  const canvas = _label_measureTextPx._canvas || (_label_measureTextPx._canvas = document.createElement("canvas"));
  const ctx = canvas.getContext("2d");
  ctx.font = `${fontWeight} ${fontSizePx}px ${fontFamily}`;
  const w = ctx.measureText(text).width;
  const h = fontSizePx * 1.15;
  return { w, h };
}

function _label_calcFitFontSize({
  bbox,
  text,
  map,
  paddingPx = 8,
  min = 8,
  max = 40,
  fontWeight = 800,
  fontFamily = "sans-serif",
  hideIfTooSmall = true
}) {
  const px = _label_getBboxPixelSize(bbox, map);
  if (!px) return min;
  const availW = Math.max(0, px.width  - paddingPx * 2);
  const availH = Math.max(0, px.height - paddingPx * 2);
  if (hideIfTooSmall && (availW < 10 || availH < 10)) return 0;
  let lo = min, hi = max, best = 0;
  while (lo <= hi) {
    const mid = (lo + hi) >> 1;
    const m = _label_measureTextPx(text, mid, fontWeight, fontFamily);
    if (m.w <= availW && m.h <= availH) {
      best = mid;
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }
  if (best === 0) return hideIfTooSmall ? 0 : min;
  return best;
}

// âœ… EMD(ë²•ì •ë™) ë¼ë²¨ ì¶”ê°€
function addEmdLabel(latlng, text, bbox, forcedFontSizePx) {
  if (!text || !bbox || !map) return;
  const fs = (typeof forcedFontSizePx === "number")
    ? forcedFontSizePx
    : _label_calcFitFontSize({
        bbox,
        text,
        map,
        paddingPx: 8,
        min: 9,
        max: 20,
        hideIfTooSmall: true
      });
  if (fs <= 0) return;
  const marker = new naver.maps.Marker({
    position: latlng,
    map,
    clickable: false,
    zIndex: 999999,
    icon: {
      content: `<div class="emd-label" style="font-size:${fs}px">${text}</div>`,
      anchor: new naver.maps.Point(0, 0)
    }
  });
  emdLabels.push(marker);
}

// âœ… EMD í´ë¦¬ê³¤/ë¼ë²¨ ì •ë¦¬
function clearEmdPolygons() {
  if (emdPolygons && emdPolygons.length) {
    emdPolygons.forEach(p => { try { p.setMap(null); } catch(e){} });
    emdPolygons = [];
  }
  if (emdLabels && emdLabels.length) {
    emdLabels.forEach(m => { try { m.setMap(null); } catch(e){} });
    emdLabels = [];
  }
}

function clearEmdLabels() {
  if (!emdLabels || emdLabels.length === 0) return;
  emdLabels.forEach(o => { try { o.setMap && o.setMap(null); } catch(e){} });
  emdLabels = [];
}

// âœ… EMD ì§€ì˜¤ë©”íŠ¸ë¦¬ ê·¸ë¦¬ê¸°
function drawEmdGeometry(geom) {
  const type = geom.type;
  const coords = geom.coordinates;
  const polygons = (type === "MultiPolygon") ? coords : [coords];
  polygons.forEach(poly => {
    if (!poly || !poly[0] || poly[0].length < 3) return;
    const ring = poly[0];
    const path = ring.map(c => new naver.maps.LatLng(c[1], c[0]));
    const polygon = new naver.maps.Polygon({
      map,
      paths: path,
      strokeColor: "#000000",
      strokeOpacity: 0.9,
      strokeWeight: 2,
      fillColor: "#000000",
      fillOpacity: 0.01
    });
    emdPolygons.push(polygon);
  });
}

// âœ… EMD ê²½ê³„ ë¡œë“œ
async function loadEmdBoundaryOnce() {
  if (emdPrepared) return;
  const parts = EMD_GEOJSON_PARTS;
  const results = await Promise.all(parts.map(p => fetch(p).then(r => {
    if (!r.ok) throw new Error(`Fetch failed: ${p} ${r.status}`);
    return r.json();
  })));
  const merged = { type: "FeatureCollection", features: [] };
  for (const fc of results) {
    if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
      merged.features.push(...fc.features);
    }
  }
  emdGeojsonRaw = merged;
}

// âœ… SIG(ì‹œêµ°êµ¬) ë¼ë²¨ ì¶”ê°€
function addSigLabel(latlng, text, bbox, forcedFontSizePx) {
  if (!text || !bbox || !map) return;
  const fs = (typeof forcedFontSizePx === "number")
    ? forcedFontSizePx
    : _label_calcFitFontSize({
        bbox,
        text,
        map,
        paddingPx: 10,
        min: 10,
        max: 20,
        hideIfTooSmall: true
      });
  if (fs <= 0) return;
  const color = (sigStyleMode === "admin") ? "#1e40af" : "#000000";
  const marker = new naver.maps.Marker({
    position: latlng,
    map,
    clickable: false,
    zIndex: 999998,
    icon: {
      content: `<div class="sig-label" style="font-size:${fs}px; color:${color};">${text}</div>`,
      anchor: new naver.maps.Point(0, 0)
    }
  });
  sigLabels.push(marker);
}

// âœ… SIG í´ë¦¬ê³¤/ë¼ë²¨ ì •ë¦¬
function clearSigPolygons() {
  if (sigPolygons && sigPolygons.length) {
    sigPolygons.forEach(p => { try { p.setMap(null); } catch(e){} });
    sigPolygons = [];
  }
}

function clearSigLabels() {
  if (sigLabels && sigLabels.length) {
    sigLabels.forEach(m => { try { m.setMap(null); } catch(e){} });
    sigLabels = [];
  }
}

// âœ… SIG ì§€ì˜¤ë©”íŠ¸ë¦¬ ê·¸ë¦¬ê¸°
function drawSigGeometry(geometry) {
  const polys = (geometry.type === "MultiPolygon") ? geometry.coordinates : [geometry.coordinates];
  polys.forEach(poly => {
    const ring = poly[0];
    const path = ring.map(c => new naver.maps.LatLng(c[1], c[0]));
    const isAdminStyle = (sigStyleMode === "admin");
    const polygon = new naver.maps.Polygon({
      map,
      paths: path,
      strokeColor: isAdminStyle ? "#1e40af" : "#000000",
      strokeOpacity: isAdminStyle ? 0.85 : 1,
      strokeWeight: 3,
      fillColor: isAdminStyle ? "#1e40af" : "#000000",
      fillOpacity: isAdminStyle ? 0.01 : 0
    });
    sigPolygons.push(polygon);
  });
}

// âœ… SIG ê²½ê³„ ë¡œë“œ
async function loadSigBoundaryOnce() {
  if (sigPrepared) return;
  const parts = SIG_GEOJSON_PARTS;
  const results = await Promise.all(parts.map(p => fetch(p).then(r => {
    if (!r.ok) throw new Error(`Fetch failed: ${p} ${r.status}`);
    return r.json();
  })));
  const merged = { type: "FeatureCollection", features: [] };
  for (const fc of results) {
    if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
      merged.features.push(...fc.features);
    }
  }
  sigGeojsonRaw = merged;
}

// âœ… ì²´í¬ë°•ìŠ¤ í™•ì¸ í•¨ìˆ˜
function isBoundaryCheckboxOn() {
  const cb = document.getElementById("toggleEmdBoundary");
  return !!(cb && cb.checked);
}

function shouldShowEmdBoundary() {
  // EMD(ìë©´ë™) í‘œì‹œ ë¹„í™œì„±í™” - ì‹œêµ°êµ¬ë§Œ í‘œì‹œ
  return false;
}

function shouldShowSigBoundary() {
  if (!map) return false;
  return isBoundaryCheckboxOn();
}

// âœ… EMD ê²½ê³„ì„  ë‹¤ì‹œ ê·¸ë¦¬ê¸°
function redrawEmdByBounds() {
  try { prepareEmdPreparedOnce(); } catch(e) { console.error('redrawEmdByBounds prepare ì‹¤íŒ¨:', e); return; }
  if (!map) return;
  if (!shouldShowEmdBoundary()) {
    clearEmdPolygons();
    clearEmdLabels();
    return;
  }
  const bounds = map.getBounds();
  if (!bounds) return;
  clearEmdPolygons();
  clearEmdLabels();
  const labelCap = 200;
  const labelCandidates = [];
  for (const f of emdPrepared) {
    if (!bboxIntersects(bounds, f.bbox)) continue;
    drawEmdGeometry(f.geometry);
    if (map.getZoom() >= 15 && labelCandidates.length < labelCap) {
      const name = (f.properties && (f.properties.A2 || f.properties.name || f.properties.EMD_NM)) || "";
      if (name) labelCandidates.push({ name, bbox: f.bbox, geometry: f.geometry });
    }
  }
  let minFit = Infinity;
  for (const c of labelCandidates) {
    const fs = _label_calcFitFontSize({
      bbox: c.bbox,
      text: c.name,
      map,
      paddingPx: 8,
      min: 9,
      max: 20,
      hideIfTooSmall: true
    });
    if (fs > 0 && fs < minFit) minFit = fs;
  }
  if (!isFinite(minFit) || minFit <= 0) return;
  let uniformFit = minFit;
  const maxLabelSize = window.matchMedia && window.matchMedia('(max-width: 768px)').matches ? 18 : 20;
  uniformFit = Math.min(uniformFit, maxLabelSize);
  for (const c of labelCandidates) {
    const latlng = getLabelLatLngByPolylabel(c.geometry, c.bbox);
    addEmdLabel(latlng, c.name, c.bbox, uniformFit);
  }
}

// âœ… SIG ê²½ê³„ì„  ë‹¤ì‹œ ê·¸ë¦¬ê¸°
function redrawSigByBounds() {
  try { prepareSigPreparedOnce(); } catch(e) { console.error('redrawSigByBounds prepare ì‹¤íŒ¨:', e); return; }
  if (!map || !sigPrepared) return;
  const bounds = map.getBounds();
  if (!bounds) return;
  clearSigPolygons();
  clearSigLabels();
  const labelCap = 60;
  const labelCandidates = [];
  for (const f of sigPrepared) {
    if (!bboxIntersects(bounds, f.bbox)) continue;
    drawSigGeometry(f.geometry);
    if (labelCandidates.length < labelCap) {
      const name = f.properties?.sgg_nm || f.properties?.A2 || f.properties?.SIG_KOR_NM || f.properties?.NAME || "";
      if (name) labelCandidates.push({ name, bbox: f.bbox, geometry: f.geometry });
    }
  }
  let minFit = Infinity;
  for (const c of labelCandidates) {
    const fs = _label_calcFitFontSize({
      bbox: c.bbox,
      text: c.name,
      map,
      paddingPx: 10,
      min: 10,
      max: 20,
      hideIfTooSmall: true
    });
    if (fs > 0 && fs < minFit) minFit = fs;
  }
  if (!isFinite(minFit) || minFit <= 0) return;
  let uniformFit = minFit;
  const maxLabelSize = window.matchMedia && window.matchMedia('(max-width: 768px)').matches ? 18 : 20;
  uniformFit = Math.min(uniformFit, maxLabelSize);
  for (const c of labelCandidates) {
    const center = getLabelLatLngByPolylabel(c.geometry, c.bbox);
    addSigLabel(center, c.name, c.bbox, uniformFit);
  }
}

// âœ… ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ê²½ê³„ í‘œì‹œ ì œì–´
function redrawBoundaryByZoom() {
  if (!map) return;
  const z = map.getZoom();
  const boundaryOn = isBoundaryCheckboxOn();
  
  // EMD(ìë©´ë™) í•­ìƒ ë¹„í™œì„±í™” - SIG(ì‹œêµ°êµ¬)ë§Œ í‘œì‹œ
  clearEmdPolygons(); clearEmdLabels();
  
  if (boundaryOn) {
    sigStyleMode = "default";
    loadSigBoundaryOnce().then(() => { try { redrawSigByBounds(); } catch(e){ console.error("SIG redraw ì‹¤íŒ¨:", e);} });
  } else {
    clearSigPolygons(); clearSigLabels();
  }
}

function scheduleEmdRedraw() {
  if (emdRedrawTimer) clearTimeout(emdRedrawTimer);
  emdRedrawTimer = setTimeout(() => {
    try { redrawBoundaryByZoom(); } catch (e) { console.error("Boundary redraw ì‹¤íŒ¨:", e); }
  }, 120);
}

async function ensureEmdLayerBoundToMap() {
  await loadEmdBoundaryOnce();
  if (emdBoundMap !== map) {
    emdBoundMap = map;
    naver.maps.Event.addListener(map, "idle", scheduleEmdRedraw);
    naver.maps.Event.addListener(map, "zoom_changed", scheduleEmdRedraw);
  }
  scheduleEmdRedraw();
}

// âœ… ê²½ê³„ì„  ì²´í¬ë°•ìŠ¤ ì¶”ê°€
const boundaryLabel = document.createElement('label');
boundaryLabel.style.marginTop = '10px';

const boundaryCheckbox = document.createElement('input');
boundaryCheckbox.type = 'checkbox';
boundaryCheckbox.id = 'toggleEmdBoundary';
boundaryCheckbox.checked = false;
boundaryCheckbox.style.marginRight = '4px';

boundaryLabel.appendChild(boundaryCheckbox);
boundaryLabel.appendChild(document.createTextNode('ì‹œêµ°êµ¬ê²½ê³„'));
container.appendChild(boundaryLabel);

boundaryCheckbox.addEventListener('change', () => {
  scheduleEmdRedraw();
});

// âœ… ì´ˆê¸° ê²½ê³„ì„  ë¡œë“œ ë° ë°”ì¸ë”©
ensureEmdLayerBoundToMap().catch(err => console.error("EMD layer binding failed:", err));

</script>
</body>
</html>
