<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>[루시퍼홍] PDF to JPG</title>

  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <!-- JSZip + FileSaver -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    input, button { margin: 10px; }
    #progress { font-size: 16px; margin-top: 10px; white-space: pre-line; }

    .btnrow { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
    button { padding: 10px 16px; font-size: 14px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    #passwordContainer { display: none; margin-top: 10px; }
    #pdfPassword { padding: 8px 10px; font-size: 14px; width: 240px; }

    #fileName { margin-top: 6px; font-size: 13px; color: #555; word-break: break-all; }

    .rangeBox {
      margin-top: 10px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 14px;
    }
    .rangeBox input[type="number"] { width: 90px; padding: 6px 8px; }
    .small { font-size: 12px; color: #666; margin-top: 6px; }
  </style>
</head>

<body>
  <h1>[루시퍼홍] PDF to JPG</h1>

  <input type="file" id="pdfInput" accept="application/pdf" />
  <div id="fileName"></div>

  <!-- ✅ 페이지 범위(선택) -->
  <div class="rangeBox">
    <span>페이지 범위</span>
    <input type="number" id="fromPage" min="1" placeholder="시작" />
    <span>~</span>
    <input type="number" id="toPage" min="1" placeholder="끝" />
  </div>
  <div class="small">
    
  </div>

  <div class="btnrow">
    <button id="convertBtn" disabled>JPG 변환(Zip)</button>
  </div>

  <!-- ✅ 암호 입력(UI는 남김: 암호 PDF도 변환 가능) -->
  <div id="passwordContainer">
    <input type="text" id="pdfPassword" placeholder="PDF 비밀번호 입력" />
    <button id="passwordApplyBtn">비밀번호 적용</button>
  </div>

  <div class="btnrow">
    <button id="downloadZipBtn" style="display:none;">ZIP 다운로드</button>
  </div>

  <div id="progress">파일을 선택하세요</div>

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js";

    const pdfInput = document.getElementById('pdfInput');
    const fileNameEl = document.getElementById('fileName');
    const progressEl = document.getElementById('progress');

    const fromPageEl = document.getElementById('fromPage');
    const toPageEl = document.getElementById('toPage');

    const convertBtn = document.getElementById('convertBtn');

    const passwordContainer = document.getElementById('passwordContainer');
    const pdfPasswordInput = document.getElementById('pdfPassword');
    const passwordApplyBtn = document.getElementById('passwordApplyBtn');

    const downloadZipBtn = document.getElementById('downloadZipBtn');

    let currentPdfData = null; // Uint8Array
    let latestZipBlob = null;
    let baseFileName = "converted";

    // ✅ pdf.js의 "현재" updatePassword 1개만 유지(누적 방지)
    let activeUpdatePassword = null;

    // ✅ 캔버스 폭발 방지(가로*세로 최대 픽셀)
    const MAX_CANVAS_PIXELS = 12_000_000; // 12MP (보수적으로)
    // ✅ pdf.js 내부 이미지 디코딩 제한(완화)
    const MAX_IMAGE_SIZE = 8_000_000;

    function setStatus(msg) { progressEl.innerText = msg; }
    function getBaseName(name) { return name.replace(/\.[^.]+$/, ''); }

    function showPasswordUI(message) {
      passwordContainer.style.display = 'block';
      setStatus(message || "비밀번호가 필요한 PDF입니다. 비밀번호를 입력하세요.");
      pdfPasswordInput.focus();
    }
    function hidePasswordUI() { passwordContainer.style.display = 'none'; }

    function resetUIOnNewFile() {
      hidePasswordUI();
      pdfPasswordInput.value = "";
      activeUpdatePassword = null;

      latestZipBlob = null;
      downloadZipBtn.style.display = 'none';
      downloadZipBtn.onclick = null;
    }

    function disableActions(disabled) {
      convertBtn.disabled = disabled;
    }

    // 비밀번호 적용: 항상 "현재" PDF에만 적용
    passwordApplyBtn.onclick = () => {
      if (typeof activeUpdatePassword === "function") {
        activeUpdatePassword(pdfPasswordInput.value || "");
      } else {
        setStatus("현재 비밀번호를 요구하는 작업이 없습니다.");
      }
    };
    pdfPasswordInput.onkeydown = (e) => { if (e.key === "Enter") passwordApplyBtn.click(); };

    function openPdfWithPdfjs(pdfData) {
      return new Promise((resolve, reject) => {
        const task = pdfjsLib.getDocument({
          data: pdfData,
          disableFontFace: true,
          useSystemFonts: true,
          enableXfa: true,
          maxImageSize: MAX_IMAGE_SIZE,
        });

        task.onPassword = (updatePassword, reason) => {
          activeUpdatePassword = updatePassword;
          showPasswordUI(
            reason === 2
              ? "비밀번호가 틀렸습니다. 다시 입력하세요."
              : "비밀번호가 걸린 PDF입니다. 비밀번호를 입력하세요."
          );
        };

        task.promise.then(pdf => {
          activeUpdatePassword = null;
          resolve(pdf);
        }).catch(err => {
          activeUpdatePassword = null;
          reject(err);
        });
      });
    }

    function clampRange(numPages) {
      let from = parseInt(fromPageEl.value, 10);
      let to = parseInt(toPageEl.value, 10);

      if (!from || from < 1) from = 1;
      if (!to || to < 1) to = numPages;

      if (from > numPages) from = numPages;
      if (to > numPages) to = numPages;
      if (from > to) [from, to] = [to, from];

      return { from, to };
    }

    function fitScaleToMaxPixels(page, desiredScale) {
      const vp = page.getViewport({ scale: desiredScale });
      const pixels = Math.floor(vp.width) * Math.floor(vp.height);
      if (pixels <= MAX_CANVAS_PIXELS) return desiredScale;

      const ratio = Math.sqrt(MAX_CANVAS_PIXELS / pixels);
      return Math.max(0.5, desiredScale * ratio);
    }

    async function renderPageToJpegBase64(page, desiredScale, quality) {
      const scale = fitScaleToMaxPixels(page, desiredScale);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { alpha: false });

      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({
        canvasContext: ctx,
        viewport,
        intent: 'display',
        enableWebGL: false,
      }).promise;

      const dataUrl = canvas.toDataURL('image/jpeg', quality);
      const base64 = dataUrl.split(',')[1];

      // 메모리 해제
      ctx && ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvas.width = 0;
      canvas.height = 0;

      return { base64, scaleUsed: scale };
    }

    async function convertPdfToZipJpg(pdf, from, to) {
      const zip = new JSZip();

      // ✅ 기본 프리셋(안정/용량/품질 밸런스)
      const SCALE = 1.3;
      const QUALITY = 0.8;

      for (let i = from; i <= to; i++) {
        setStatus(`JPG 변환 중... (${i}/${to})`);
        const page = await pdf.getPage(i);

        const { base64 } = await renderPageToJpegBase64(page, SCALE, QUALITY);
        zip.file(`page_${i}.jpg`, base64, { base64: true });

        // 브라우저 GC 텀(약간의 안정성 향상)
        await new Promise(r => setTimeout(r, 0));
      }

      return zip.generateAsync({ type: "blob" });
    }

    async function handleConvert() {
      if (!currentPdfData) return;

      disableActions(true);
      downloadZipBtn.style.display = 'none';
      latestZipBlob = null;

      try {
        hidePasswordUI();
        setStatus("PDF 여는 중...");
        const pdf = await openPdfWithPdfjs(currentPdfData);

        const { from, to } = clampRange(pdf.numPages);

        hidePasswordUI();
        setStatus("ZIP 생성 중...");
        latestZipBlob = await convertPdfToZipJpg(pdf, from, to);

        setStatus("완료! ZIP 다운로드를 누르세요.");
        downloadZipBtn.style.display = 'inline-block';
        downloadZipBtn.onclick = () => saveAs(latestZipBlob, `${baseFileName}_${from}-${to}_images.zip`);
      } catch (err) {
        console.error(err);
        if (passwordContainer.style.display === 'block') {
          // 암호 UI 떠있는 상태면 사용자가 입력하도록 기다리면 됨
          // (추가 메시지는 과하게 안 띄움)
        } else {
          setStatus("오류: 변환 실패. (메모리 부족이면 페이지 범위를 더 작게 시도하세요: 1~10)");
        }
      } finally {
        disableActions(false);
      }
    }

    pdfInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      fileNameEl.innerText = `선택된 파일: ${file.name}`;
      baseFileName = getBaseName(file.name);

      resetUIOnNewFile();

      setStatus("파일 로딩 중...");
      currentPdfData = new Uint8Array(await file.arrayBuffer());

      setStatus("준비 완료: JPG 변환 버튼을 누르세요.");
      convertBtn.disabled = false;

      // 같은 파일 재선택 가능
      e.target.value = "";
    });

    convertBtn.addEventListener('click', handleConvert);
  </script>
</body>
</html>
