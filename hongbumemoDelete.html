<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>hongbuMemo DB ì´ˆê¸°í™” / ë””ë²„ê·¸</title>
  <style>
    body { font-family: system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; margin: 16px; }
    .card { border: 1px solid #333; border-radius: 12px; padding: 14px; margin: 12px 0; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #555; background: #111; color: #fff; font-weight: 700; }
    button:disabled { opacity: .5; }
    label { display: flex; gap: 10px; align-items: center; margin: 6px 0; }
    pre { white-space: pre-wrap; word-break: break-word; background: #0b0b0b; color: #d7d7d7; padding: 12px; border-radius: 10px; border: 1px solid #333; }
    .warn { color: #ffb020; }
    .hint { color: #9ad1ff; }
    input[type="text"]{ padding: 10px 12px; border-radius: 10px; border: 1px solid #555; background:#0b0b0b; color:#fff; }
    .small { font-size: 12px; opacity: .85; }
  </style>
</head>
<body>
  <h2>hongbuMemo DB ì´ˆê¸°í™”(ì‚­ì œ) + IndexedDB ë””ë²„ê·¸</h2>

  <div class="card">
    <div class="row">
      <button id="btnDelete">ğŸ§¨ hongbuMemo ì‚­ì œ</button>
      <button id="btnScan">ğŸ”„ DB ëª©ë¡/ìŠ¤í† ì–´ ìŠ¤ìº”</button>
      <button id="btnClearLog">ğŸ§¹ ë¡œê·¸ ì§€ìš°ê¸°</button>
    </div>

    <div style="margin-top:10px;">
      <label><input type="checkbox" id="chkCaches" checked> Cache Storageë„ ê°™ì´ ì‚­ì œ (ê¶Œì¥)</label>
      <label><input type="checkbox" id="chkSW" checked> Service Worker ë“±ë¡ë„ í•´ì œ (ê¶Œì¥)</label>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="hint">ì‚­ì œ ëŒ€ìƒ DB ì´ë¦„:</span>
      <input id="dbName" type="text" value="hongbuMemo" />
      <span class="small">(ì›í•˜ë©´ hongbutest ë“±ìœ¼ë¡œ ë°”ê¿”ì„œ ì‚­ì œ ê°€ëŠ¥)</span>
    </div>

    <p class="warn" style="margin-top:10px;">
      âš ï¸ deleteDatabaseê°€ <b>BLOCKED</b>ë¡œ ëœ¨ë©´: í™ë¶€ í˜ì´ì§€ í¬í•¨ ë‹¤ë¥¸ íƒ­/ì°½ì„ ì „ë¶€ ë‹«ê³ ,
      ì´ í˜ì´ì§€ í•œ íƒ­ë§Œ ë‚¨ê¸´ ë’¤ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”. (iOSì—ì„œ ë§¤ìš° í”í•¨)
    </p>
  </div>

  <div class="card">
    <h3>IndexedDB ëª©ë¡ / objectStore ë””ë²„ê·¸</h3>
    <pre id="dbList">(ì•„ì§ ìŠ¤ìº” ì „)</pre>
    <p class="small hint">
      iOSëŠ” <code>indexedDB.databases()</code>ê°€ ë¯¸ì§€ì›ì¸ ê²½ìš°ê°€ ë§ì•„ì„œ,
      ì•„ë˜ KNOWN_DB_CANDIDATES í›„ë³´ ëª©ë¡ì„ open í•´ì„œ ì¡´ì¬ ì—¬ë¶€ë¥¼ ì¶”ì •í•©ë‹ˆë‹¤.
    </p>
  </div>

  <div class="card">
    <h3>ë¡œê·¸</h3>
    <pre id="log"></pre>
  </div>

<script>
(() => {
  // =======================
  // Settings
  // =======================
  // iOSì—ì„œ ì „ì²´ DB ëª©ë¡ APIê°€ ì—†ì„ ë•Œë¥¼ ëŒ€ë¹„í•œ "í›„ë³´ DB ì´ë¦„ë“¤"
  // (í”„ë¡œì íŠ¸ì— ë§ê²Œ ê³„ì† ì¶”ê°€í•˜ì„¸ìš”)
  const KNOWN_DB_CANDIDATES = [
    "hongbuMemo",
    "hongbutest",
    "hongbuMap",
    "hongbuSise",
    "hongbuMemoImage",
    "hongbuSupply",
    "hongbuPath",
  ];

  // =======================
  // UI refs
  // =======================
  const $log = document.getElementById("log");
  const $dbList = document.getElementById("dbList");
  const $btnDelete = document.getElementById("btnDelete");
  const $btnScan = document.getElementById("btnScan");
  const $btnClearLog = document.getElementById("btnClearLog");
  const $chkCaches = document.getElementById("chkCaches");
  const $chkSW = document.getElementById("chkSW");
  const $dbName = document.getElementById("dbName");

  // =======================
  // Helpers (log)
  // =======================
  function now() {
    const d = new Date();
    const pad = n => String(n).padStart(2,"0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  function log(msg) {
    const line = `[${now()}] ${msg}`;
    $log.textContent += line + "\n";
    console.log(line);
  }
  function clearLog() { $log.textContent = ""; }

  // =======================
  // IndexedDB Debug Helpers
  // =======================
  function idbNames(db) {
    try { return Array.from(db.objectStoreNames || []); }
    catch { return []; }
  }
  function idbLogStores(db, needStores = [], tag = "IDB") {
    const names = idbNames(db);
    console.log(`[${tag}] DB`, { name: db?.name, version: db?.version, stores: names });
    if (needStores?.length) {
      const missing = needStores.filter(s => !names.includes(s));
      if (missing.length) console.error(`[${tag}] âŒ Missing objectStores:`, missing, " / existing:", names);
      else console.log(`[${tag}] âœ… All required stores exist:`, needStores);
    }
    return names;
  }
  function idbDebugTransaction(db, stores, mode = "readonly", tag = "IDB") {
    idbLogStores(db, stores, tag);
    try {
      const tx = db.transaction(stores, mode);
      tx.oncomplete = () => console.log(`[${tag}] tx complete`, { stores, mode });
      tx.onabort = () => console.warn(`[${tag}] tx abort`, { stores, mode, error: tx.error });
      tx.onerror = () => console.error(`[${tag}] tx error`, { stores, mode, error: tx.error });
      return tx;
    } catch (e) {
      console.error(`[${tag}] âŒ transaction() throw`, { stores, mode, error: e });
      throw e;
    }
  }

  // =======================
  // DB scan logic
  // =======================
  async function listDBsStandardAPI() {
    if (typeof indexedDB.databases !== "function") return null;
    try {
      const dbs = await indexedDB.databases();
      return dbs; // [{name, version}...]
    } catch {
      return null;
    }
  }

  function openDBNonCreating(name) {
    // ì¡´ì¬í•˜ë©´ open ì„±ê³µ + onupgradeneeded ì—†ì´ ë„˜ì–´ê°.
    // ì—†ìœ¼ë©´ onupgradeneededê°€ íŠ¸ë¦¬ê±°ë˜ì–´ "ìƒì„±í•˜ë ¤ê³  í•¨" -> abort ì²˜ë¦¬.
    return new Promise((resolve) => {
      const req = indexedDB.open(name);
      let existed = true;

      req.onupgradeneeded = () => {
        existed = false;
        log(`â„¹ï¸ "${name}" ì—†ìŒ â†’ ìƒì„±(onupgradeneeded) ë˜ë ¤í•´ì„œ ì¦‰ì‹œ ì¤‘ë‹¨(íŠ¸ëœì­ì…˜ abort)`);
        try { req.transaction.abort(); } catch (e) {}
      };

      req.onsuccess = () => {
        const db = req.result;
        const stores = idbNames(db);
        const version = db.version;
        // existedê°€ trueë©´ ê¸°ì¡´ DB ì¡´ì¬
        // existedê°€ falseë©´ ì‚¬ì‹¤ìƒ ìƒˆë¡œ ìƒê¸°ë ¤ë˜ ê²ƒ -> abort í–ˆì§€ë§Œ ì¼ë¶€ í™˜ê²½ì—ì„œ ë¹ˆ DBë¡œ ì—´ë¦´ ìˆ˜ ìˆì–´ ë³´ìˆ˜ì ìœ¼ë¡œ ì²˜ë¦¬
        // ê·¸ë˜ë„ stores/version ì •ë³´ëŠ” ì°¸ê³ ìš©ìœ¼ë¡œ ì¶œë ¥
        db.close();
        resolve({ name, existed, version, stores, ok: true });
      };

      req.onerror = () => resolve({ name, existed: false, version: null, stores: [], ok: false, error: req.error });
    });
  }

  async function scanDatabasesAndStores() {
    $btnScan.disabled = true;
    try {
      log("ğŸ” DB ëª©ë¡/ìŠ¤í† ì–´ ìŠ¤ìº” ì‹œì‘");
      $dbList.textContent = "";

      const lines = [];
      const found = new Map(); // name -> info

      // 1) í‘œì¤€ APIê°€ ë˜ë©´ ìš°ì„  ì‚¬ìš© (ëŒ€ì²´ë¡œ PC/ì•ˆë“œ/ì¼ë¶€ í™˜ê²½)
      const std = await listDBsStandardAPI();
      if (std) {
        lines.push("âœ… indexedDB.databases() ì§€ì›: ì‹¤ì œ ëª©ë¡");
        for (const d of std) {
          if (d?.name) found.set(d.name, { name: d.name, version: d.version ?? null });
        }
        lines.push(`- API ë°˜í™˜ DB ìˆ˜: ${std.length}`);
        lines.push("");
      } else {
        lines.push("â„¹ï¸ indexedDB.databases() ë¯¸ì§€ì›(iOSì—ì„œ í”í•¨) â†’ í›„ë³´ ëª©ë¡ìœ¼ë¡œ íƒì§€");
        lines.push("");
      }

      // 2) í›„ë³´ ëª©ë¡ open ê²€ì‚¬ (iOS í•µì‹¬)
      lines.push("ğŸ“Œ í›„ë³´ DB ì¡´ì¬ ì—¬ë¶€ ê²€ì‚¬ + objectStore ëª©ë¡");
      for (const name of KNOWN_DB_CANDIDATES) {
        const info = await openDBNonCreating(name);

        // existed ê¸°ì¤€ìœ¼ë¡œ â€œìˆë‹¤/ì—†ë‹¤â€ í‘œì‹œ
        if (info.ok && info.existed) {
          found.set(name, { ...found.get(name), ...info });
          lines.push(`âœ… ${name} (ver=${info.version}) stores=[${info.stores.join(", ") || "(ì—†ìŒ)"}]`);
        } else {
          lines.push(`â€” ${name} (ì—†ìŒ/íƒì§€ë¶ˆê°€)`);
        }
      }

      // 3) í‘œì¤€ APIì—ë§Œ ì¡´ì¬í•˜ê³  í›„ë³´ì— ì—†ëŠ” DBê°€ ìˆìœ¼ë©´, ê·¸ DBë„ store ëª©ë¡ì„ ì‹œë„
      if (std && found.size) {
        const extra = [];
        for (const name of found.keys()) {
          if (!KNOWN_DB_CANDIDATES.includes(name)) extra.push(name);
        }
        if (extra.length) {
          lines.push("");
          lines.push("ğŸ“Œ (ì¶”ê°€) APIì—ì„œë§Œ ë°œê²¬ëœ DBì˜ stores ì¡°íšŒ ì‹œë„");
          for (const name of extra) {
            const info = await openDBNonCreating(name);
            if (info.ok) lines.push(`âœ… ${name} (ver=${info.version}) stores=[${info.stores.join(", ") || "(ì—†ìŒ)"}]`);
            else lines.push(`âš ï¸ ${name} open ì‹¤íŒ¨: ${info.error?.message || info.error}`);
          }
        }
      }

      $dbList.textContent = lines.join("\n");
      log("âœ… DB ëª©ë¡/ìŠ¤í† ì–´ ìŠ¤ìº” ì™„ë£Œ");
    } catch (e) {
      $dbList.textContent = "âŒ ìŠ¤ìº” ì¤‘ ì˜ˆì™¸: " + (e?.message || e);
      log("âŒ ìŠ¤ìº” ì˜ˆì™¸: " + (e?.message || e));
    } finally {
      $btnScan.disabled = false;
    }
  }

  // =======================
  // Deletion helpers
  // =======================
  async function deleteCaches() {
    if (!("caches" in window) || typeof caches.keys !== "function") {
      log("â„¹ï¸ Cache Storage ë¯¸ì§€ì›. ìŠ¤í‚µ");
      return;
    }
    const keys = await caches.keys();
    if (!keys.length) {
      log("âœ… Cache Storage: ì‚­ì œí•  ìºì‹œ ì—†ìŒ");
      return;
    }
    for (const k of keys) {
      const ok = await caches.delete(k);
      log(`${ok ? "âœ…" : "â„¹ï¸"} cache delete: ${k}`);
    }
  }

  async function unregisterServiceWorkers() {
    if (!("serviceWorker" in navigator) || typeof navigator.serviceWorker.getRegistrations !== "function") {
      log("â„¹ï¸ Service Worker ë¯¸ì§€ì›. ìŠ¤í‚µ");
      return;
    }
    const regs = await navigator.serviceWorker.getRegistrations();
    if (!regs.length) {
      log("âœ… Service Worker: ë“±ë¡ ì—†ìŒ");
      return;
    }
    for (const r of regs) {
      const ok = await r.unregister();
      log(`${ok ? "âœ…" : "â„¹ï¸"} SW unregister: ${r.scope}`);
    }
  }

  async function deleteDB(dbName) {
    return await new Promise((resolve) => {
      const req = indexedDB.deleteDatabase(dbName);

      req.onblocked = () => {
        log(`âš ï¸ deleteDatabase("${dbName}") BLOCKED: ë‹¤ë¥¸ íƒ­/ì°½ì—ì„œ DB ì‚¬ìš© ì¤‘. ëª¨ë“  í™ë¶€ íƒ­ ë‹«ê³  ì¬ì‹œë„!`);
      };
      req.onsuccess = () => resolve({ ok: true });
      req.onerror = () => resolve({ ok: false, err: req.error });
    });
  }

  async function handleDelete() {
    const name = ($dbName.value || "").trim();
    if (!name) {
      alert("ì‚­ì œí•  DB ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.");
      return;
    }

    $btnDelete.disabled = true;
    try {
      log(`ğŸ§¨ IndexedDB ì‚­ì œ ì‹œë„: ${name}`);

      // (ë””ë²„ê·¸) ì‚­ì œ ì „ opení•´ì„œ í˜„ì¬ stores ì°ì–´ë³´ê¸° (ìˆìœ¼ë©´ ë„ì›€ ë¨)
      try {
        const info = await openDBNonCreating(name);
        if (info.ok) {
          log(`(ë””ë²„ê·¸) ì‚­ì œ ì „ ìƒíƒœ: ${name} existed=${info.existed} ver=${info.version} stores=[${info.stores.join(", ") || "(ì—†ìŒ)"}]`);
        }
      } catch {}

      const result = await deleteDB(name);

      if (result.ok) log(`âœ… DB ì‚­ì œ ì„±ê³µ: ${name}`);
      else log(`âŒ DB ì‚­ì œ ì‹¤íŒ¨: ${result.err?.message || result.err}`);

      if ($chkCaches.checked) {
        log("ğŸ§¹ Cache Storage ì‚­ì œ ì‹œì‘");
        await deleteCaches();
        log("ğŸ§¹ Cache Storage ì‚­ì œ ì™„ë£Œ");
      }

      if ($chkSW.checked) {
        log("ğŸ§¹ Service Worker í•´ì œ ì‹œì‘");
        await unregisterServiceWorkers();
        log("ğŸ§¹ Service Worker í•´ì œ ì™„ë£Œ");
      }

      log("âœ… ì „ì²´ ì‘ì—… ì™„ë£Œ. ì´ì œ í™ë¶€ í˜ì´ì§€ë¡œ ëŒì•„ê°€ ìƒˆë¡œê³ ì¹¨í•˜ë©´ ìƒˆ DBë¡œ ì¬ìƒì„±ë©ë‹ˆë‹¤.");
      // ì‚­ì œ í›„ ìŠ¤ìº” ê°±ì‹ 
      await scanDatabasesAndStores();
    } catch (e) {
      log(`âŒ ì˜ˆì™¸: ${e?.message || e}`);
    } finally {
      $btnDelete.disabled = false;
    }
  }

  // =======================
  // Wire up
  // =======================
  $btnDelete.addEventListener("click", handleDelete);
  $btnScan.addEventListener("click", scanDatabasesAndStores);
  $btnClearLog.addEventListener("click", clearLog);

  // ì´ˆê¸° ì‹¤í–‰
  clearLog();
  log("âœ… ì´ˆê¸°í™”/ë””ë²„ê·¸ í˜ì´ì§€ ë¡œë“œë¨");
  scanDatabasesAndStores();

  // =======================
  // (ì°¸ê³ ) ì´ í˜ì´ì§€ ìì²´ì—ì„œ transaction ë””ë²„ê·¸ë¥¼ ì“°ê³  ì‹¶ë‹¤ë©´:
  // const tx = idbDebugTransaction(db, ["storeName"], "readwrite", "HONGBU");
  // =======================
})();
</script>
</body>
</html>
