<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta id="dynamicViewport" name="viewport" content="width=device-width, initial-scale=0.85, user-scalable=no">

    <link rel="icon" href="route.png" type="image/png">
    <title>[ë£¨ì‹œí¼í™] í™ë¶€ê°€ ê¸°ê°€ë§‰í˜€</title>
	<script type="text/javascript" src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=9t8y33hyq8">
let sigGeojsonRaw = null;
let emdGeojsonRaw = null;
</script>
	<script type="text/javascript" src="MarkerClustering.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<style>
  /* #mapëŠ” ë™ì  ë²„íŠ¼ í¬ì§€ì…”ë‹ì„ ìœ„í•´ relative */
  #map { position: relative; }

  /* ì§€ë„ ìš°ìƒë‹¨ í”Œë¡œíŒ… ë²„íŠ¼ */
  .map-float-btn{
  position: absolute;
  top: 8px; right: 8px;
  width: 40px; height: 40px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #bbb;
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
  font-size: 18px;
  display: flex;              /* ì¤‘ì•™ì •ë ¬ */
  align-items: center;        /* ì¤‘ì•™ì •ë ¬ */
  justify-content: center;    /* ì¤‘ì•™ì •ë ¬ */
  cursor: pointer;
  z-index: 10000;
  transform: translateY(-1px);/* ì•„ì´ì½˜ ë¯¸ì„¸ ìƒí–¥ ë³´ì • */
}
/* line-height ì„¤ì •ì´ ìˆì—ˆë‹¤ë©´ ì œê±° */



  /* ì „ì²´í™”ë©´ì¼ ë•Œ ìƒë‹¨ íƒ€ì´í‹€/ì»¨íŠ¸ë¡¤ ìˆ¨ê¹€(ì„ íƒ) */
  body.fullscreen-active > h1,
  body.fullscreen-active > #controls { display: none !important; }

html, body { margin:0; padding:0; overflow-x:hidden; }

/* ì¼ë°˜ ìƒíƒœ: ì£¼ì†Œì°½ í¬í•¨ ë†’ì´ ë³€ë™ ëŒ€ì‘ */
@supports (height: 100svh) {
  #map { height: calc(100svh - 150px) !important; }
}

/* ì „ì²´í™”ë©´(í´ë°±/ë„¤ì´í‹°ë¸Œ ê³µí†µ)ì¼ ë•ŒëŠ” ë³´ì´ëŠ” í™”ë©´ ì „ë¶€ ì±„ìš°ê¸° */
@supports (height: 100dvh) {
  body.fullscreen-active #map { height: 100dvh !important; }
}

/* ê¸°ì¡´ ì „ì—­ ë²„íŠ¼ì€ ìˆ¨ê¹€ */
#locationButton, #stopTrackingButton { display: none !important; }

/* ì§€ë„ ë‚´ë¶€ìš© í˜„ì¬ìœ„ì¹˜/ì¤‘ì§€ ë²„íŠ¼ */
.map-locate-btn, .map-stoptrack-btn{
  position: absolute;
  left: 8px;
  width: 40px; height: 40px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #bbb;
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
  font-size: 18px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; z-index: 10000;
}
.map-locate-btn { top: 10px; }      /* í˜„ì¬ ìœ„ì¹˜ (ì¢Œìƒë‹¨ ì•„ì´ì½˜ ì•„ë˜) */
.map-stoptrack-btn { top: 50px; }  /* ì¶”ì  ì¤‘ì§€ */
#mapStopBtn { display: none !important; }


/* âœ… ë²•ì •ë™(EMD) ë¼ë²¨ */
/* âœ… ë²•ì •ë™(EMD) ë¼ë²¨ - ê¸€ìë§Œ */
.emd-label{
/* 12px * 4 */
  font-weight: 800;
  color: #0b1b3a;

  background: transparent;  /* ë°°ê²½ ì œê±° */
  border: none;             /* í…Œë‘ë¦¬ ì œê±° */
  border-radius: 0;         /* ë°˜ì›/ë‘¥ê·¼ëª¨ì–‘ ì œê±° */
  padding: 0;               /* ì—¬ë°± ì œê±° */
  box-shadow: none;         /* ê·¸ë¦¼ì ì œê±° */

  white-space: nowrap;
  pointer-events: none;

  /* ë°°ê²½ ì—†ì´ë„ ì˜ ë³´ì´ê²Œ(ì„ íƒ) */
  text-shadow: 0 0 2px rgba(255,255,255,0.9), 0 0 6px rgba(255,255,255,0.7);
}


/* ì‹œêµ°êµ¬(SIG) ë¼ë²¨ - ê¸€ìë§Œ */
.sig-label{
font-weight: 800;
  color: #111;
  background: transparent;
  border: none;
  border-radius: 0;
  padding: 0;
  box-shadow: none;
  white-space: nowrap;
  pointer-events: none;
  text-shadow: 0 0 2px rgba(255,255,255,0.9), 0 0 6px rgba(255,255,255,0.7);
}
</style>



    <style>
        #map { width: 100%;  max-width: 100%; height: calc(100vh - 150px); resize: both; max-height: calc(100svh) !important; }
        #controls { margin: 10px; }
        button { margin: 5px; padding: 10px; cursor: pointer; }

		/* í˜„ì¬ ìœ„ì¹˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
		#locationButton {
			position: absolute;
			top: 90px; /* ğŸ”¹ ì§€ë„ ë‚´ë¶€ì˜ ìƒë‹¨ */
			left: 8px; /* ğŸ”¹ ì§€ë„ ë‚´ë¶€ì˜ ì™¼ìª½ */
			background-color: white;
			border: 2px solid gray;
			padding: 10px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 12px;
			text-align: center;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
			z-index: 1000; /* ğŸ”¹ ì§€ë„ ìœ„ì— í‘œì‹œ */
		}

		/* ìœ„ì¹˜ ì¶”ì  ì¢…ë£Œ ë²„íŠ¼ */
		#stopTrackingButton {
			position: absolute;
			top: 125px; /* ğŸ”¹ ì§€ë„ ë‚´ë¶€ì˜ ìƒë‹¨ */
			left: 60px; /* ğŸ”¹ í˜„ì¬ ìœ„ì¹˜ ë²„íŠ¼ê³¼ ê°„ê²© ìœ ì§€ */
			background-color: white;
			border: 2px solid gray;
			padding: 10px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 14px;
			text-align: center;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
			z-index: 1000; /* ğŸ”¹ ì§€ë„ ìœ„ì— í‘œì‹œ */
		}

/* ===== í•„í„° ìˆ«ì ì…ë ¥(ìµœì†Œì„¸ëŒ€ìˆ˜/ì¤€ê³µë…„ë„) ê³µí†µ ìŠ¤íƒ€ì¼ ===== */
.filter-num{
  width:60px;
  height:24px;
  font-size:14px;
  text-align:center;
  border:1px solid #9aa0a6;
  border-radius:8px;
  padding:3px 6px;
  box-sizing:border-box;
}
.filter-num:focus{
  outline:none;
  border-color:#2D5DA7;
  box-shadow:0 0 5px rgba(74,144,226,0.35);
}

/* ê¸°ì¡´ #controls ê·œì¹™ì— ì•„ë˜ 3ì¤„ë§Œ ì¶”ê°€ */
#controls{
  display: flex;          /* ì´ë¯¸ flexë©´ ìœ ì§€ */
  flex-wrap: wrap;        /* ì¤„ë°”ê¿ˆ í—ˆìš© */
  row-gap: 6px;           /* ì¤„ë°”ê¿ˆ ì‹œ ì„¸ë¡œ ê°„ê²© */
  column-gap: 8px;        /* ê°™ì€ ì¤„ ë‚´ í•­ëª© ê°„ê²©(ì„ íƒ) */
}

#controls button { flex: 0 0 auto; } /* ğŸ”¹ ë²„íŠ¼ì´ ëˆŒë ¤ì„œ ì¤„ì–´ë“œëŠ” ê²ƒ ë°©ì§€ */
#controls label{
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  margin-right: 6px;
}


	#scaleControls {
		display: flex; /* âœ… ê°€ë¡œ ì •ë ¬ */
		align-items: center; /* âœ… ë²„íŠ¼ì´ ì²´í¬ë°•ìŠ¤ì™€ ê°™ì€ ë†’ì´ë¡œ */
		margin-left: 5px; /* âœ… ê°„ê²© ì¡°ì • */
	}

	#scaleControls button {
		width: 30px;
		height: 30px;
		font-size: 16px;
		font-weight: bold;
		background-color: white;
		border: 2px solid gray;
		border-radius: 5px;
		cursor: pointer;
		text-align: center;
		margin-left: 5px; /* âœ… ë²„íŠ¼ ì‚¬ì´ ê°„ê²© */
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
		display: flex;
		justify-content: center;
		align-items: center;
	}

	#scaleControls button:hover {
		background-color: #f0f0f0;
	}
	.fullscreen-btn {
		position: fixed;
		top: 170px;
		left: 20px;
		background-color: white;
		border: 2px solid gray;
		padding: 10px;
		border-radius: 50%;
		cursor: pointer;
		font-size: 14px;
		text-align: center;
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
		z-index: 10000; /* âœ… ìµœìƒë‹¨ ìœ ì§€ */
	}
#apartmentInfo {
    position: fixed;
    top: 50%;
    left: 50%;
    
    background: white;
    border: 1px solid black;
    padding: 8px;
    width: auto;
    font-size: 16px;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    display: none;
    z-index: 1000001;
     will-change: transform; /* GPU ë Œë”ë§ íŒíŠ¸ */
  contain: layout paint;  /* ë ˆì´ì•„ì›ƒ ë³€í™” ì œí•œ */
    max-width: 90%;
    max-height: 70vh; /* âœ… í™”ë©´ ë†’ì´ì˜ 80%ê¹Œì§€ í™•ì¥ */
    overflow-y: auto; /* âœ… ë‚´ë¶€ ìŠ¤í¬ë¡¤ í™œì„±í™” */
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch; /* âœ… iOS ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤ */
 backface-visibility: hidden; /* ê¹œë°•ì„ ë°©ì§€ */
    transform: translateZ(0);    /* GPU ë Œë”ë§ ì•ˆì •í™” */
}


#apartmentInfo table {
    width: auto; /* ğŸ”¹ í‘œ í¬ê¸°ë¥¼ ë‚´ìš©ì— ë§ê²Œ ìë™ ì¡°ì • */
    table-layout: auto; /* ğŸ”¹ í…Œì´ë¸” ë ˆì´ì•„ì›ƒ ìë™ ì¡°ì • */
    border-collapse: collapse;
}

#apartmentInfo th, #apartmentInfo td {
    border: 1px solid black;
    padding: 2px 5px; /* ğŸ”¹ ë‚´ë¶€ ì—¬ë°± ìµœì†Œí™” */
    text-align: center;
    white-space: nowrap; /* ğŸ”¹ í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
}

#apartmentInfo th {
    background: #f0f0f0;
    font-weight: bold;
}

#apartmentInfo .close-button {
    position: absolute;
    top: 5px;
    right: 8px;
    background: red;
    color: white;
    border: none;
    font-size: 14px;
    padding: 3px 6px;
    cursor: pointer;
    border-radius: 3px;
}
table {
    border-collapse: collapse; /* âœ… í…Œë‘ë¦¬ ì¤‘ë³µ ì œê±° */
    width: 100%; /* âœ… í…Œì´ë¸” í¬ê¸° ì¡°ì • */
}

td, th {
    border: 1px solid black; /* âœ… í…Œë‘ë¦¬ ìŠ¤íƒ€ì¼ í™•ì¸ */
    padding: 5px; /* âœ… ë‚´ë¶€ ì—¬ë°± ì¡°ì • */
    text-align: center;
    white-space: nowrap; /* âœ… ì¤„ë°”ê¿ˆ ë°©ì§€ */
  word-break: keep-all;
}
buttonContainer {
    display: flex;
    justify-content: center; /* âœ… ë²„íŠ¼ë“¤ì„ ì¤‘ì•™ ì •ë ¬ */
    gap: 10px; /* âœ… ë²„íŠ¼ ê°„ê²© ì¡°ì • */
    margin-top: 10px;
}
#imagePreview {
  width: 100%;
  height: 72px;              /* ê³ ì • ë†’ì´ */
  overflow-x: auto;
  white-space: nowrap;       /* ì¤„ë°”ê¿ˆ ë°©ì§€ */
}

#imagePreview > div {
  display: inline-block;
}
#imageModal {
  display: none;
  justify-content: center;
  align-items: center;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  z-index: 1000002;
  backface-visibility: hidden;
  will-change: opacity;
}

#modalCanvas {
  max-width: 90%;
  max-height: 90%;
  border-radius: 8px;
}

#mapWrapper.fullscreen {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 900000; /* íŒì—…(999999)ë³´ë‹¤ë§Œ ë‚®ê²Œ */
}
#map.fullscreen {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 900000;
}

body.map-fullscreen {
  overflow: hidden;
  height: 100%;
}

 @media (max-width: 768px) {
    .only-pc {
      display: none !important;
    }
    
    /* ğŸ“± ëª¨ë°”ì¼ì—ì„œ ë©”ëª¨ ì…ë ¥ì¹¸ ê¸€ì í¬ê¸° ì¡°ëŒ€ */
    #noteText {
      font-size: 16px !important;
      padding: 12px !important;
      line-height: 1.6 !important;
    }
  }
    </style>
<style id="hongbu-debug-style">
  #hongbuDebugOverlay{
    position:fixed; left:10px; right:10px; bottom:10px;
    max-height:40vh; overflow:auto;
    background:rgba(0,0,0,0.82);
    color:#fff; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px; line-height:1.35;
    border:1px solid rgba(255,255,255,0.25);
    border-radius:10px;
    z-index: 2147483647;
    display:none;
    box-shadow: 0 8px 24px rgba(0,0,0,0.45);
  }
  #hongbuDebugOverlay .dbg-head{
    position:sticky; top:0;
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    padding:8px 10px;
    background:rgba(0,0,0,0.92);
    border-bottom:1px solid rgba(255,255,255,0.15);
  }
  #hongbuDebugOverlay .dbg-title{ font-weight:800; display:flex; gap:8px; align-items:center; }
  #hongbuDebugOverlay .dbg-title .dot{ width:8px; height:8px; border-radius:50%; background:#22c55e; display:inline-block; }
  #hongbuDebugOverlay .dbg-actions button{
    background:rgba(255,255,255,0.12); color:#fff; border:1px solid rgba(255,255,255,0.18);
    border-radius:8px; padding:6px 8px; cursor:pointer;
    font-size:12px;
  }
  #hongbuDebugOverlay .dbg-actions button:hover{ background:rgba(255,255,255,0.18); }
  #hongbuDebugOverlay .dbg-body{ padding:8px 10px 10px; }
  #hongbuDebugOverlay .dbg-line{ padding:4px 0; border-bottom:1px dashed rgba(255,255,255,0.12); }
  #hongbuDebugOverlay .dbg-line:last-child{ border-bottom:none; }
  #hongbuDebugOverlay .lvl-ERR{ color:#fecaca; }
  #hongbuDebugOverlay .lvl-WARN{ color:#fde68a; }
  #hongbuDebugOverlay .lvl-INFO{ color:#bfdbfe; }
  #hongbuDebugOverlay .lvl-STAT{ color:#a7f3d0; }
  #hongbuDebugToast{
    position:fixed; left:50%; bottom:60px; transform:translateX(-50%);
    background:rgba(0,0,0,0.82); color:#fff;
    padding:10px 12px; border-radius:10px;
    border:1px solid rgba(255,255,255,0.22);
    z-index: 2147483646;
    display:none; max-width:92vw;
    font-size:13px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.45);
  }
</style>
</head>
<body>
<div id="hongbuDebugToast"></div>
<div id="hongbuDebugOverlay" aria-live="polite">
  <div class="dbg-head">
    <div class="dbg-title"><span class="dot" id="hongbuDbgDot"></span><span>ë””ë²„ê·¸ ë¡œê·¸</span><span id="hongbuDbgHint" style="opacity:.75;font-weight:600;"></span></div>
    <div class="dbg-actions">
      <button id="hongbuDbgShowBtn" title="í‘œì‹œ/ìˆ¨ê¹€">í‘œì‹œ</button>
      <button id="hongbuDbgCopyBtn" title="ì „ì²´ ë³µì‚¬">ë³µì‚¬</button>
      <button id="hongbuDbgClearBtn" title="ì§€ìš°ê¸°">ì§€ìš°ê¸°</button>
    </div>
  </div>
  <div class="dbg-body" id="hongbuDbgBody"></div>
</div>

<script id="hongbu-debug-script">
(function(){
  const overlay = document.getElementById('hongbuDebugOverlay');
  const body = document.getElementById('hongbuDbgBody');
  const toast = document.getElementById('hongbuDebugToast');
  const dot = document.getElementById('hongbuDbgDot');
  const hint = document.getElementById('hongbuDbgHint');
  const btnShow = document.getElementById('hongbuDbgShowBtn');
  const btnCopy = document.getElementById('hongbuDbgCopyBtn');
  const btnClear = document.getElementById('hongbuDbgClearBtn');

  const MAX_LINES = 250;
  const store = [];

  function ts(){
    const d = new Date();
    const p = (n)=>String(n).padStart(2,'0');
    return `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`;
  }
  function safeStr(x){
    try{
      if (x instanceof Error) return x.name + ': ' + x.message;
      if (typeof x === 'string') return x;
      return JSON.stringify(x);
    }catch(e){
      return String(x);
    }
  }
  function setDot(level){
    if (!dot) return;
    if (level === 'ERR') dot.style.background = '#ef4444';
    else if (level === 'WARN') dot.style.background = '#f59e0b';
    else dot.style.background = '#22c55e';
  }
  function ensureVisibleOnError(level){
    if (level === 'ERR'){
      overlay.style.display = 'block';
      btnShow.textContent = 'ìˆ¨ê¹€';
      hint.textContent = '(ì˜¤ë¥˜ ë°œìƒ)';
    }
  }
  function render(){
    if (!body) return;
    body.innerHTML = store.map(l => {
      const cls = 'lvl-' + l.level;
      const extra = l.extra ? `<div style="opacity:.9; margin-top:2px; white-space:pre-wrap;">${escapeHtml(l.extra)}</div>` : '';
      return `<div class="dbg-line ${cls}"><b>[${l.level}]</b> ${escapeHtml(l.time)} ${escapeHtml(l.msg)}${extra}</div>`;
    }).join('');
  }
  function escapeHtml(s){
    return String(s)
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#39;");
  }
  function log(level, msg, extra){
    if (level === 'WARN') return;
    const line = { level, time: ts(), msg: safeStr(msg), extra: extra ? safeStr(extra) : '' };
    store.push(line);
    while (store.length > MAX_LINES) store.shift();
    setDot(level);
    render();
    ensureVisibleOnError(level);
  }

  // expose
  window.hongbuDebugLog = log;

  function showToast(message, ms=3500){
    if (!toast) return;
    toast.textContent = String(message);
    toast.style.display = 'block';
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>{ toast.style.display='none'; }, ms);
  }
  window.hongbuDebugToast = showToast;

  btnShow?.addEventListener('click', ()=>{
    const on = overlay.style.display !== 'none';
    overlay.style.display = on ? 'none' : 'block';
    btnShow.textContent = on ? 'í‘œì‹œ' : 'ìˆ¨ê¹€';
    if (!on) hint.textContent = '';
  });
  btnClear?.addEventListener('click', ()=>{
    store.length = 0;
    hint.textContent = '';
    setDot('INFO');
    render();
  });
  btnCopy?.addEventListener('click', async ()=>{
    const text = store.map(l => `[${l.level}] ${l.time} ${l.msg}${l.extra ? '\n' + l.extra : ''}`).join('\n');
    try{
      await navigator.clipboard.writeText(text);
      showToast('âœ… ë¡œê·¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆì–´ìš”.');
    }catch(e){
      showToast('âš ï¸ ë³µì‚¬ ì‹¤íŒ¨. (HTTPS/ê¶Œí•œ í™•ì¸)');
      log('WARN', 'clipboard copy failed', e && (e.stack || e.message || e));
    }
  });

  // Global error hooks
  window.addEventListener('error', (e)=>{
    const extra = {
      file: e.filename, line: e.lineno, col: e.colno,
      stack: e.error && e.error.stack ? e.error.stack : ''
    };
    log('ERR', e.message || 'window.onerror', extra);
    showToast('âŒ ì˜¤ë¥˜ ë°œìƒ: ' + (e.message || 'unknown'));
  });

  window.addEventListener('unhandledrejection', (e)=>{
    const r = e.reason;
    const extra = { reason: safeStr(r), stack: r && r.stack ? r.stack : '' };
    log('ERR', 'Unhandled Promise Rejection', extra);
    showToast('âŒ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜¤ë¥˜(ë¹„ë™ê¸°)');
  });

  // Patch console.error / warn (keep original behavior)
  const _ce = console.error.bind(console);
  console.error = function(...args){
    try{ log('ERR', 'console.error: ' + args.map(safeStr).join(' ')); }catch(_){}
    return _ce(...args);
  };
  const _cw = console.warn.bind(console);
  console.warn = function(...args){
    // warnì€ í™”ë©´ì— í‘œì‹œí•˜ì§€ ì•ŠìŒ (ì½˜ì†”ì—ë§Œ ë‚¨ê¹€)
    return _cw(...args);
  };

  // Storage quota monitor
  async function reportStorage(){
    try{
      if (navigator.storage && navigator.storage.estimate){
        const est = await navigator.storage.estimate();
        const usage = est.usage || 0;
        const quota = est.quota || 0;
        if (quota > 0){
          const pct = (usage / quota) * 100;
          log('STAT', `Storage: ${(usage/1048576).toFixed(1)}MB / ${(quota/1048576).toFixed(1)}MB (${pct.toFixed(1)}%)`);
          if (pct >= 92) showToast('âš ï¸ ì €ì¥ê³µê°„ì´ ê±°ì˜ ê½‰ ì°¼ì–´ìš”. (ë¸Œë¼ìš°ì € ì €ì¥ì†Œ)');
        }
      }
    }catch(e){
      log('WARN', 'storage estimate failed', e && (e.message || e));
    }
  }
  reportStorage();
  setInterval(reportStorage, 60000);

  // JS heap (desktop chrome only)
  if (performance && performance.memory){
    setInterval(()=>{
      try{
        const m = performance.memory;
        log('STAT', `JS Heap: ${(m.usedJSHeapSize/1048576).toFixed(1)}MB / ${(m.jsHeapSizeLimit/1048576).toFixed(1)}MB`);
      }catch(_){}
    }, 45000);
  }

  // IndexedDB open monitor
  if (window.indexedDB && typeof indexedDB.open === 'function'){
    const _open = indexedDB.open.bind(indexedDB);
    indexedDB.open = function(...args){
      const req = _open(...args);
      req.addEventListener('error', ()=>{
        const er = req.error;
        log('ERR', `IndexedDB open error (${args[0]} v${args[1]||''})`, er ? (er.name + ': ' + er.message) : 'unknown');
        if (er && er.name === 'QuotaExceededError') showToast('âŒ IndexedDB ì €ì¥ê³µê°„ ì´ˆê³¼(QuotaExceededError)');
      });
      return req;
    };
  }

  // Helper to wrap requests (optional use by app code)
  window.wrapIdbRequest = function(req, context){
    try{
      if (!req || typeof req.addEventListener !== 'function') return req;
      req.addEventListener('error', ()=>{
        const er = req.error;
        log('ERR', `IDB request error: ${context || ''}`, er ? (er.name + ': ' + er.message) : 'unknown');
        if (er && er.name === 'QuotaExceededError'){
          showToast('âŒ ì €ì¥ê³µê°„ ì´ˆê³¼: ë” ì´ìƒ ì €ì¥í•  ìˆ˜ ì—†ì–´ìš”.');
        }
      });
      req.addEventListener('blocked', ()=> log('WARN', `IDB blocked: ${context||''}`));
    }catch(_){}
    return req;
  };

  // Quick toggle gesture: triple-tap top-left corner (mobile friendly)
  let tap = {t:0,c:0};
  document.addEventListener('pointerdown', (e)=>{
    if (e.clientX < 60 && e.clientY < 60){
      const now = Date.now();
      if (now - tap.t < 550) tap.c++; else tap.c = 1;
      tap.t = now;
      if (tap.c >= 3){
        overlay.style.display = (overlay.style.display === 'none' ? 'block' : 'none');
        btnShow.textContent = (overlay.style.display === 'none' ? 'í‘œì‹œ' : 'ìˆ¨ê¹€');
        tap.c = 0;
      }
    }
  }, {passive:true});

  // Show overlay by default on desktop if URL has ?debug=1
  try{
    const qs = new URLSearchParams(location.search);
    if (qs.get('debug') === '1'){
      overlay.style.display = 'block';
      btnShow.textContent = 'ìˆ¨ê¹€';
      log('INFO', 'Debug overlay enabled via ?debug=1');
    }
  }catch(_){}
})();
</script>

<h1 style="font-size: 20px; font-weight: bold; text-align: left;">
    [ë£¨ì‹œí¼í™] í™ë¶€ê°€ ê¸°ê°€ë§‰í˜€
</h1>

<div id="controls">
<label>ì‹œë„:
  <select id="sidoFilter">
    <option value="">ì „ì²´</option>
  </select>
</label>
<label>ì‹œêµ°êµ¬:
  <select id="sigunguFilter" disabled>
    <option value="">ì „ì²´</option>
  </select>
</label>

        <label>ì—°ë„:
      <input class="filter-num" type="number" id="yearFromFilter" min="1900" max="2100" placeholder="ì‹œì‘">
      ~
      <input class="filter-num" type="number" id="yearToFilter" min="1900" max="2100" placeholder="ë">
    </label>

<label>ìµœì†Œì„¸ëŒ€ìˆ˜:
  <input class="filter-num" type="number" id="unitFilter" min="0" value="190" placeholder="ìµœì†Œ">
</label>
    <label><input type="checkbox" id="toggleApartments" checked>ì•„íŒŒíŠ¸</label>
    <label><input type="checkbox" id="toggleSchools" >ì´ˆ</label>
	<label><input type="checkbox" id="toggleMiddleSchools" >ì¤‘</label>
	<label><input type="checkbox" id="toggleFacilities">í™˜ê²½</label>
	<label><input type="checkbox" id="toggleStarbucks">ìŠ¤ë²…</label>
	<label><input type="checkbox" id="toggleMemoIcon" checked>ë©”ëª¨ ì•„ì´ì½˜ í‘œì‹œ</label>
	<label><input type="checkbox" id="toggleEmdBoundary">ë²•ì •ë™ê²½ê³„</label>
	<label><input type="checkbox" id="toggleAdminBoundary">í–‰ì •ë™ê²½ê³„</label>
	<label class="only-pc"><input type="checkbox" id="toggleSiseMap">ì‹œì„¸ì§€ë„</label>
	<label class="only-pc"><input type="checkbox" id="toggleFindWay">ì—…ë¬´ì§€êµ¬ ê¸¸ì°¾ê¸°</label>
	<label><input type="checkbox" id="toggleBlankMap">ë°±ì§€ë„</label>

	<label><input type="checkbox" id="toggleCadastralMap">ì§€ì í¸ì§‘ë„</label>
<!-- 
	<label class="only-pc" style="color: red; margin-left: auto; white-space: nowrap;">
  ê¸¸ì°¾ê¸°í•  ë•Œ ì¶œë°œì‹œê°ì€ í˜„ì¬ ì»´í“¨í„° ì‹œê°ì— ë§ì¶°ì§‘ë‹ˆë‹¤. í‰ì¼ ì˜¤ì „ 7ì‹œë°˜ìœ¼ë¡œ ë§ì¶”ë©´ ì¶œë°œì‹œê°ì´ í•´ë‹¹ ì‹œê°ìœ¼ë¡œ ë³€ê²½ë©ë‹ˆë‹¤
</label> -->

<div id="locationPopup" style="
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border: 2px solid gray;
  padding: 20px;
  z-index: 99999 !important; 
  box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
  border-radius: 8px;
  text-align: center;
">
  <p>ğŸ“ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ì¤‘ì…ë‹ˆë‹¤...<br>ì²˜ìŒì—ëŠ” ìˆ˜ì‹­ì´ˆ ì†Œìš”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
</div>



    <!-- âœ… ìŠ¤ì¼€ì¼ ì¡°ì • ë²„íŠ¼ì„ 'ì´ˆë“±í•™êµ' ì²´í¬ë°•ìŠ¤ ì˜†ìœ¼ë¡œ ì´ë™ 
    <div id="scaleControls">
		<label>ë°°ìœ¨</label>
        <button id="scaleUpButton">+</button>
        <button id="scaleDownButton">-</button>
    </div>
-->
</div>



    <div id="map"></div>
    <div id="controls">
        <button id="startPolyline">ê²½ë¡œ ê·¸ë¦¬ê¸°</button>
		<button id="undoLastPointButton">ì§ì „ ì·¨ì†Œ</button>
        <button id="completePolyline">ê²½ë¡œ ê·¸ë¦¬ê¸° ì™„ë£Œ</button>
		<button id="clearMap">ê²½ë¡œ ì´ˆê¸°í™”</button>
        <button id="downloadGPX">GPX ë‹¤ìš´ë¡œë“œ</button>
        <button id="uploadGPX">GPX ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <input type="file" id="gpxFileInput" style="display: none;" accept=".gpx">
        
<button id="showInguBtn" style="display: block;">ì¸êµ¬ë°ì´í„°</button>
<div style="margin-top: 0px;">
   <!--  <button onclick="backupMemoDB()">ğŸ—‚ï¸ ë©”ëª¨ ë°±ì—…</button> -->
<button onclick="window.open('memoBackup.html', '_blank')">ğŸ“¦ ë©”ëª¨ ë°±ì—…</button>
    <button onclick="restoreMemoDB()">ğŸ—ƒï¸ ë©”ëª¨ ë³µì›</button>
	<button onclick="deleteMemoDB()">ğŸ—‘ï¸ ë©”ëª¨ ì¼ê´„ ì‚­ì œ</button>

    <input type="file" id="memoRestoreInput" accept=".json" style="display: none" />
</div>

<button
  onclick="window.open('https://cafe.naver.com/wecando7/11456373', '_blank')">
  ğŸ”— ì¹´í˜ ê¸€ ë§í¬
</button>

<button id="siseExportBtn" style="display: none;">ì‹œì„¸ì§€ë„ ë°±ì—…</button>
<button id="siseImportBtn" style="display: none;">ì‹œì„¸ì§€ë„ ë³µì›</button>
<button id="siseResetBtn" style="display: none;">ì‹œì„¸ì§€ë„ ì´ˆê¸°í™”</button>
<div style="flex-basis:100%; display:flex; flex-wrap:wrap; gap:8px; margin-top:0;">
  <button id="siseVer2ImportBtn" style="display:block;">ì‹œì„¸ì§€ë„Ver2ì—ì„œ ê°€ì ¸ì˜¤ê¸°</button>
  <button id="siseVer2ResetBtn"  style="display:block;">ì‹œì„¸ì§€ë„Ver2ë°ì´í„° ì´ˆê¸°í™”</button>
</div>



<!-- âœ… ì¸êµ¬ ë°ì´í„° íŒì—… ë²„íŠ¼ -->

<div id="inguModal" style="
  display:none;
  position:fixed;
  top:60px;
  left:50%;
  transform:translateX(-50%);
  width:90%;
  max-width:800px;
  max-height:80vh;
  overflow:auto;
  background:#fff;
  border:4px solid #333;
  padding:20px;
  z-index:99999;
">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div><strong>ë°ì´í„° ê¸°ì¤€ì¼ì: 2025-07-28</strong></div>
    <button onclick="document.getElementById('inguModal').style.display='none'">ë‹«ê¸°</button>
  </div>
  <div style="margin-top: 10px;">
    <label>ì‹œë„: <select id="sidoSelect"></select></label>
    <label>ì‹œêµ°êµ¬: <select id="sigunguSelect"></select></label>
  </div>
  <table border="1" style="width:100%; margin-top:10px; border-collapse:collapse;" id="inguTable">
	<thead>
  <tr id="inguHeaderRow">
    <th onclick="sortTable('ì‹œë„')">ì‹œë„</th>
    <th onclick="sortTable('ì‹œêµ°êµ¬')">ì‹œêµ°êµ¬</th>
    <th onclick="sortTable('ìë©´ë™')">ìë©´ë™</th>
    <th onclick="sortTable('ì´ì¸êµ¬ìˆ˜')">ì´ì¸êµ¬ìˆ˜</th>
    <th onclick="sortTable('ì„¸ëŒ€ìˆ˜')">ì„¸ëŒ€ìˆ˜</th>
    <th onclick="sortTable('ì„¸ëŒ€ë‹¹ì¸êµ¬')">ì„¸ëŒ€ë‹¹ ì¸êµ¬</th>
  </tr>
</thead>


    <tbody></tbody>
  </table>
</div>

    </div>
    <div id="locationButton" title="í˜„ì¬ ìœ„ì¹˜">ğŸ“</div> <!-- âœ… í˜„ì¬ ìœ„ì¹˜ ë²„íŠ¼ -->
    <div id="stopTrackingButton" style="display:none" title="ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€">ğŸ›‘</div> <!-- âœ… ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€ ë²„íŠ¼ -->
    <span style="font-size: 14px; color: gray;">
        ë°±ìŠ¤í˜ì´ìŠ¤ : ì§ì „ ì·¨ì†Œ<br>
        ESC, ë§ˆìš°ìŠ¤ ìš°í´ë¦­, [ê²½ë¡œ ê·¸ë¦¬ê¸° ì™„ë£Œ] ë²„íŠ¼ í´ë¦­ : ê·¸ë¦¬ê¸° ì¢…ë£Œ<br>
        ëª¨ë°”ì¼ì—ì„œë„ ê²½ë¡œê·¸ë¦¬ê¸°, ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤
    </span>

<div id="apartmentInfo" style="border: 1px solid black; padding: 10px; display:none">
    <p>ì•„íŒŒíŠ¸ ì •ë³´ë¥¼ í™•ì¸í•˜ë ¤ë©´ ë§ˆì»¤ë¥¼ í´ë¦­í•˜ì„¸ìš”.</p>
</div>
<!-- ëª¨ë‹¬ ìµœìƒë‹¨ + ë°°ê²½ íë¦¼ -->
<!-- ì´ë¯¸ì§€ ëª¨ë‹¬ (canvasë¡œ ë³€ê²½) -->
<!-- ì´ë¯¸ì§€ ëª¨ë‹¬ -->
<!--<div id="imageModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100vh; background-color:rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:99999;">-->
<div id="imageModal" style="display:none;">
  <canvas id="modalCanvas" style="max-width:90vw; max-height:90vh; border-radius:8px;"></canvas>

  <!-- ğŸ“‹ ë³µì‚¬ ë²„íŠ¼ -->
  <button id="copyImageButton" style="
    position: absolute; 
    top: 20px; 
    right: 20px;  
    background: white; 
    border: none; 
    padding: 8px 12px; 
    border-radius: 4px; 
    cursor: pointer;">
    ğŸ“‹ ë³µì‚¬
  </button>

  <!-- âœ… â¬‡ï¸ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ (ë³µì‚¬ ë²„íŠ¼ ì™¼ìª½ì— ìœ„ì¹˜) -->
  <button id="downloadImageButton" style="
    position: absolute; 
    top: 20px; 
    right: 100px;  
    background: white; 
    border: none; 
    padding: 8px 12px; 
    border-radius: 4px; 
    cursor: pointer;">
    â¬‡ï¸ ë‹¤ìš´ë¡œë“œ
  </button>
</div>




<script>
//ì´ë¯¸ì§€ í™•ëŒ€ ì—¬ë¶€
window.imageModalShowYn = false;

// ==============================
// âœ… Memory leak ë°©ì§€ ìœ í‹¸ (ë©”ëª¨/ì´ë¯¸ì§€/ìº”ë²„ìŠ¤)
// - ë©”ëª¨ ì´ë¯¸ì§€(base64) ìºì‹œë¥¼ "í˜„ì¬ ì„ íƒëœ ì•„íŒŒíŠ¸ 1ê°œ"ë¡œ ì œí•œ
// - ì´ë¯¸ì§€ ëª¨ë‹¬ ìº”ë²„ìŠ¤ GPU ë²„í¼ ê°•ì œ í•´ì œ
// ==============================
let __currentMemoAptId = null;

// âœ… ObjectURL(blob:) ì•ˆì „ í•´ì œ ìœ í‹¸
function __safeRevokeObjectURL(url){
  try{
    if(url && typeof url === "string" && url.startsWith("blob:")){
      URL.revokeObjectURL(url);
    }
  }catch(e){ /* ignore */ }
}


// âœ… ë©”ëª¨ ì´ë¯¸ì§€ ìºì‹œë¥¼ í˜„ì¬ ì•„íŒŒíŠ¸ 1ê°œë¡œ ì œí•œ (IndexedDBê°€ ì›ë³¸ ì €ì¥ì†Œ)
function __memoKeepOnly(keepId){
  try{
    if (!window.aptMemoImageList) return;
    const keepKey = String(keepId);
    Object.keys(window.aptMemoImageList).forEach(k => {
      if (k !== keepKey) {
        // âœ… blob: ObjectURLì´ ì„ì—¬ìˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ ë¨¼ì € revoke
        try{
          const arr = window.aptMemoImageList[k];
          if (Array.isArray(arr)) arr.forEach(u => __safeRevokeObjectURL(u));
        }catch(e){}
        // í° base64 ì°¸ì¡° ëŠê¸°
        window.aptMemoImageList[k] = [];
        delete window.aptMemoImageList[k];
      }
    });
  }catch(e){ console.warn("memo cache trim failed:", e); }
}

// âœ… ì´ë¯¸ì§€ ëª¨ë‹¬ ìº”ë²„ìŠ¤ GPU ë©”ëª¨ë¦¬ í•´ì œ
function __clearModalCanvas(){
  try{
    const canvas = document.getElementById("modalCanvas");
    if(!canvas) return;
    const ctx = canvas.getContext && canvas.getContext("2d");
    if(ctx) ctx.clearRect(0,0,canvas.width,canvas.height);
    // ğŸ”¥ í•µì‹¬: width ì¬ì„¤ì •ìœ¼ë¡œ GPU ë²„í¼ ë¦¬ì…‹
    canvas.width = 1;
    canvas.height = 1;
  }catch(e){ console.warn("clear canvas failed:", e); }
}

function closeImageModal(){
  const modal = document.getElementById("imageModal");
  if(modal) modal.style.display = "none";
  __clearModalCanvas();
  window.lastOpenedBase64 = null;
  window.imageModalShowYn = false;
}




 class MapHandler {

		

            constructor(map) {
                this.map = map;
                this.shapes = [];
                this.currentPath = [];
                this.currentPolyline = null;
                this.markers = [];
                this.initUI();
            }
				
            initUI() {
				document.getElementById("startPolyline").addEventListener("click", () => this.startPolylineMode());
				document.getElementById("undoLastPointButton").addEventListener("click", () => this.undoLastPoint());
				document.getElementById("completePolyline").addEventListener("click", () => this.completePolyline()); // âœ… ì¶”ê°€ë¨*				
				document.getElementById("downloadGPX").addEventListener("click", () => this.downloadGPX());
				 // âœ… ì‹œì„¸ì§€ë„ ë°±ì—… (ìµìŠ¤í¬íŠ¸)
				document.getElementById("siseExportBtn").addEventListener("click", () => {
					exportToJSON();
				});

				// âœ… ì‹œì„¸ì§€ë„ ë³µì› (ì„í¬íŠ¸)
				document.getElementById("siseImportBtn").addEventListener("click", () => {
					const input = document.createElement('input');
					input.type = 'file';
					input.accept = 'application/json';
					input.onchange = function (event) {
						const file = event.target.files[0];
						if (file) {
							importFromJSON(file);
						}
					};
					input.click();
				});

				// âœ… ì‹œì„¸ì§€ë„ ë³µì› (ì„í¬íŠ¸)
				document.getElementById("siseVer2ImportBtn").addEventListener("click", () => {
					const input = document.createElement('input');
					input.type = 'file';
					input.accept = 'application/json';
					input.onchange = function (event) {
						const file = event.target.files[0];
						if (file) {
							importFromSiseVer2JSON(file);
						}
					};
					input.click();
				});


				document.getElementById("siseResetBtn").addEventListener("click", () => {
					const confirmReset = confirm("âš ï¸ ì‹œì„¸ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ë©´ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‹œì„¸ì§€ë„ ë°±ì—…ì„ ê¶Œì¥ë“œë¦½ë‹ˆë‹¤. \nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
					if (!confirmReset) return;

					const request = indexedDB.open("hongbu", 5);
					request.onsuccess = function(event) {
						const db = event.target.result;
						const transaction = db.transaction(["apartments"], "readwrite");
						const store = transaction.objectStore("apartments");

						const clearRequest = store.clear(); // âœ… ì „ì²´ ì‚­ì œ

						clearRequest.onsuccess = function() {
							alert("âœ… ì‹œì„¸ì§€ë„ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
							// ğŸ” ë§ˆì»¤ ì—…ë°ì´íŠ¸
							prevSiseMapState = "ì´ˆê¸°í™”";
							updateMarkers(window.map.getBounds());
						};

						clearRequest.onerror = function(event) {
							console.error("âŒ ì‹œì„¸ì§€ë„ ì´ˆê¸°í™” ì‹¤íŒ¨:", event.target.error);
							alert("âŒ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
						};
					};
				});

				document.getElementById("siseVer2ResetBtn").addEventListener("click", () => {
					const confirmReset = confirm("âš ï¸ ì‹œì„¸ì§€ë„Ver2 ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ë©´ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‹œì„¸ì§€ë„Ver2ì—ì„œ ë°±ì—…ì„ ê¶Œì¥ë“œë¦½ë‹ˆë‹¤. \nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
					if (!confirmReset) return;

					const request = indexedDB.open("hongbu", 5);
					request.onsuccess = function(event) {
						const db = event.target.result;
						const transaction = db.transaction(["importSiseVer2"], "readwrite");
						const store = transaction.objectStore("importSiseVer2");

						const clearRequest = store.clear(); // âœ… ì „ì²´ ì‚­ì œ

						clearRequest.onsuccess = function() {
							alert("âœ… ì‹œì„¸ì§€ë„Ver2 ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
							// ğŸ” ë§ˆì»¤ ì—…ë°ì´íŠ¸
							prevSiseMapState = "ì´ˆê¸°í™”";
							updateMarkers(window.map.getBounds());
						};

						clearRequest.onerror = function(event) {
							console.error("âŒ ì‹œì„¸ì§€ë„ ì´ˆê¸°í™” ì‹¤íŒ¨:", event.target.error);
							alert("âŒ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
						};
					};
				});



				document.getElementById("uploadGPX").addEventListener("click", () => document.getElementById("gpxFileInput").click());

				// ğŸ”¹ `this`ë¥¼ `MapHandler` ì¸ìŠ¤í„´ìŠ¤ë¡œ ìœ ì§€
				document.getElementById("gpxFileInput").addEventListener("change", this.handleFileChange.bind(this));

				document.getElementById("clearMap").addEventListener("click", () => this.clearMap({ forgetStoredGpx: true }));
				
				document.addEventListener("keydown", (e) => {
					if (e.key === "Escape") {
						this.completePolyline();
					} else if (e.key === "Backspace") {
						this.undoLastPoint();
					}
				});

				naver.maps.Event.addListener(this.map, "click", (e) => {
					if (!this.currentPolyline) {
						console.warn("âš ï¸ ê²½ë¡œ ê·¸ë¦¬ê¸° ëª¨ë“œê°€ ì•„ë‹˜");
						return; // ğŸš« ì‹¤í–‰ ì¤‘ë‹¨ (ì˜¤ë¥˜ ë°©ì§€)
					}
					this.currentPath.push(e.coord);
					this.currentPolyline.setPath(this.currentPath);
					this.addMilestoneMarker(e.coord);
				});

				naver.maps.Event.addListener(this.map, "rightclick", () => {
					this.completePolyline();
				});

			
			}

			handleFileChange(event) {
				const file = event.target.files[0];
				if (!file) return; // ì„ íƒëœ íŒŒì¼ì´ ì—†ìœ¼ë©´ ì¢…ë£Œ

				this.loadGPX(file);

				// ğŸ”¹ ë™ì¼í•œ íŒŒì¼ ë‹¤ì‹œ ì„ íƒ ê°€ëŠ¥í•˜ë„ë¡ input ê°’ ì´ˆê¸°í™”
				event.target.value = ""; 
			}


			startPolylineMode() {
				if (this.shapes.length > 0) {
					const userConfirmed = confirm("ì´ì „ì— ê·¸ë¦° ê²½ë¡œê°€ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
					if (!userConfirmed) return;

					this.clearMap({ forgetStoredGpx: false }); // ê¸°ì¡´ ê²½ë¡œ ì´ˆê¸°í™”
				}

				this.currentPath = [];
				this.markers = [];
				this.currentPolyline = new naver.maps.Polyline({
					map: this.map,
					path: this.currentPath,
					strokeColor: "#FF0000",
					strokeWeight: 3.33,
					strokeOpacity: 0.8
				});	
			}
		
			downloadGPX() {
				if (this.shapes.length === 0) {
					alert("ë‹¤ìš´ë¡œë“œí•  ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.");
					return;
				}

				let gpxData = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="MapHandler">\n  <trk>\n    <trkseg>\n`;
				
				this.shapes.forEach(({ polyline }) => {
					polyline.getPath().forEach((coord) => {
						gpxData += `      <trkpt lat="${coord.y}" lon="${coord.x}"></trkpt>\n`;
					});
				});

				gpxData += `    </trkseg>\n  </trk>\n</gpx>`;
				
				const blob = new Blob([gpxData], { type: "application/gpx+xml" });
				const a = document.createElement("a");
				const url = URL.createObjectURL(blob);
				a.href = url;
				a.download = "route.gpx";
				document.body.appendChild(a);
				a.click();
				// âœ… ObjectURL í•´ì œ(ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
				setTimeout(() => __safeRevokeObjectURL(url), 1000);
				document.body.removeChild(a);
			}

            completePolyline() {
                if (this.currentPolyline && this.currentPath.length > 1) {
                    this.addStartEndMarkers();
                    this.shapes.push({ polyline: this.currentPolyline, markers: [...this.markers] });
                    this.currentPolyline = null;
                }
            }

            addMilestoneMarker(coord) {
                const marker = new naver.maps.Marker({
                    position: coord,
                    map: this.map,
                    icon: {
                        content: `<div style="width: 8px; height: 8px; background-color: #FF0000; border-radius: 50%; border: 2px solid #FFF;"></div>`,
                        anchor: new naver.maps.Point(4, 4)
                    }
                });
                this.markers.push(marker);
            }

            addStartEndMarkers() {
                if (this.currentPath.length < 2) return;
                this.createLabeledMarker(this.currentPath[0], "ì¶œë°œ");
                this.createEndMarker(this.currentPath[this.currentPath.length - 1]);
            }

            createLabeledMarker(coord, label) {
                const marker = new naver.maps.Marker({
                    position: coord,
                    map: this.map,
                    icon: {
                        content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
                                    <span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
                                  </div>`
                    }
                });
                this.markers.push(marker);
            }
			clearMap(options = {}) {
				const { forgetStoredGpx = false } = options;
				if (!Array.isArray(this.shapes)) {
					this.shapes = []; // shapesê°€ ë°°ì—´ì´ ì•„ë‹ˆë©´ ì´ˆê¸°í™”
				}

				// ê¸°ì¡´ ê²½ë¡œ ë° ë§ˆì»¤ ì œê±°
				this.shapes.forEach(({ polyline, markers }) => {
					if (polyline) polyline.setMap(null);
					if (Array.isArray(markers)) {
						markers.forEach(marker => marker.setMap(null));
					}
				});

				 // ğŸ”¹ í˜„ì¬ ê·¸ë¦¬ê³  ìˆëŠ” polylineë„ ì œê±°
				if (this.currentPolyline) {
					this.currentPolyline.setMap(null);
					this.currentPolyline = null;
				}

				// ğŸ”¹ ì¶œë°œ & ë„ì°© ë§ˆì»¤ ì‚­ì œ
				if (Array.isArray(this.markers)) {
					this.markers.forEach(marker => marker.setMap(null));
				}

				// ğŸ”¹ ë„ì°© ë§ˆì»¤ ì‚­ì œ ì¶”ê°€
				if (this.endMarker) {
					this.endMarker.setMap(null);
					this.endMarker = null; // ë„ì°© ë§ˆì»¤ ë³€ìˆ˜ ì´ˆê¸°í™”
				}

				// ë°ì´í„° ì´ˆê¸°í™”
				this.shapes = [];
				this.markers = [];
				this.currentPath = [];
				this.currentPolyline = null;
			

				// âœ… ë§ˆì§€ë§‰ ë¶ˆëŸ¬ì˜¨ GPX ê¸°ë¡ë„ ì‚­ì œ (ì‚¬ìš©ìê°€ "ê²½ë¡œ ì´ˆê¸°í™”"ë¥¼ ëˆŒë €ì„ ë•Œë§Œ)
				if (forgetStoredGpx) {
					deleteHongbuSetting("lastGpxPath").catch(console.warn);
				}
			}

		loadGPX(file) {

			this.clearMap({ forgetStoredGpx: false });
			const reader = new FileReader();
			reader.onload = (event) => {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

				const trkpts = xmlDoc.getElementsByTagName("trkpt");
				if (trkpts.length === 0) {
					alert("ìœ íš¨í•œ GPX íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.");
					return;
				}

				let path = [];
				for (let i = 0; i < trkpts.length; i++) {
					const lat = parseFloat(trkpts[i].getAttribute("lat"));
					const lon = parseFloat(trkpts[i].getAttribute("lon"));
					path.push(new naver.maps.LatLng(lat, lon));
				}

				this.drawGPXPath(path);
				this.updateEndMarker(path); // ğŸ”¹ GPX ë¡œë“œ í›„ ë„ì°© ë§ˆì»¤ ì—…ë°ì´íŠ¸

				// âœ… ë§ˆì§€ë§‰ ë¶ˆëŸ¬ì˜¨ GPX ê²½ë¡œ ì €ì¥ (IndexedDB settings)
				try {
					const serial = path.map(p => ({ lat: p.y, lon: p.x }));
					setHongbuSetting("lastGpxPath", serial).catch(console.warn);
				} catch (e) {
					console.warn("lastGpxPath ì €ì¥ ì‹¤íŒ¨:", e);
				}
			};
			reader.readAsText(file);
		}

		updateEndMarker(path) {
			if (path.length < 2) return; // ìœ íš¨í•œ ê²½ë¡œê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ

			const totalDistance = this.calculateTotalDistance(path); // ê±°ë¦¬ ì¬ê³„ì‚°
			const formattedDistance = totalDistance >= 1000 
				? (totalDistance / 1000).toFixed(2) + "km" 
				: totalDistance.toFixed(0) + "m";

			const estimatedTime = this.calculateWalkingTime(totalDistance / 1000); // ì˜ˆìƒ ì‹œê°„ ê³„ì‚°
			const label = `ë„ì°©<br>${formattedDistance}<br>${estimatedTime}<br>(ì‹œì† 4km ê¸°ì¤€)`;

			// ê¸°ì¡´ ë„ì°© ë§ˆì»¤ ì‚­ì œ
			if (this.endMarker) this.endMarker.setMap(null);

			// ìƒˆ ë„ì°© ë§ˆì»¤ ì¶”ê°€
			this.endMarker = new naver.maps.Marker({
				position: path[path.length - 1],
				map: this.map,
				icon: {
					content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
								<span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
							  </div>`
				}
			});
		}




		drawGPXPath(path) {
			if (path.length < 2) {
				alert("ê²½ë¡œ ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				return;
			}

			const polyline = new naver.maps.Polyline({
				map: this.map,
				path: path,
				strokeColor: "#0000FF", // GPX ê²½ë¡œ ìƒ‰ìƒ (íŒŒë€ìƒ‰)
				strokeWeight: 3.33,
				strokeOpacity: 0.8
			});

			this.shapes.push({ polyline });

			this.createLabeledMarker(path[0], "ì¶œë°œ");
			this.createEndMarker(path[path.length - 1]);
		}

		createEndMarker(coord) {
			const totalDistance = this.calculateTotalDistance(); // m ë‹¨ìœ„ë¡œ ê°€ì ¸ì˜´
			const formattedDistance = totalDistance >= 1000 
				? (totalDistance / 1000).toFixed(2) + "km" 
				: totalDistance.toFixed(0) + "m";

			const estimatedTime = this.calculateWalkingTime(totalDistance / 1000); // km ë‹¨ìœ„ë¡œ ë³€í™˜
			const label = `ë„ì°©<br>${formattedDistance}<br>${estimatedTime}<br>(ì‹œì† 4km ê¸°ì¤€)`;

			const marker = new naver.maps.Marker({
				position: coord,
				map: this.map,
				icon: {
					content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
								<span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
							  </div>`
				}
			});
			this.markers.push(marker);
		}


		calculateTotalDistance(path = this.currentPath) {
			if (!Array.isArray(path) || path.length < 2) {
				return 0; // ğŸ”¹ ê²½ë¡œê°€ ì—†ìœ¼ë©´ ê±°ë¦¬ 0 ë°˜í™˜
			}

			let total = 0;
			for (let i = 1; i < path.length; i++) {
				total += this.computeDistance(path[i - 1], path[i]);
			}
			return total; // ê±°ë¦¬ ë°˜í™˜ (m ë‹¨ìœ„)
		}




		computeDistance(coord1, coord2) {
			const R = 6371000;
			const lat1 = coord1.y * Math.PI / 180;
			const lat2 = coord2.y * Math.PI / 180;
			const deltaLat = (coord2.y - coord1.y) * Math.PI / 180;
			const deltaLng = (coord2.x - coord1.x) * Math.PI / 180;

			const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
					  Math.cos(lat1) * Math.cos(lat2) *
					  Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return R * c;
		}

        calculateWalkingTime(distanceKm) { 
			const speed = 4; // ì‹œì† 4km
			const hours = Math.floor(distanceKm / speed);
			const minutes = Math.round((distanceKm % speed) * 60 / speed);
			return (hours > 0 ? `${hours}ì‹œê°„ ${minutes}ë¶„` : `${minutes}ë¶„`);
		}


        undoLastPoint() {
			if (this.currentPath.length > 0) {
				this.currentPath.pop(); // ë§ˆì§€ë§‰ ì¢Œí‘œ ì‚­ì œ
				this.currentPolyline.setPath(this.currentPath); // ë°˜ì˜

				// ë§ˆì§€ë§‰ ë§ˆì»¤ ì‚­ì œ
				const lastMarker = this.markers.pop();
				if (lastMarker) lastMarker.setMap(null);
			}
		}

    }
	
// ==============================
// âœ… ì§€ì í¸ì§‘ë„(Cadastral) ë ˆì´ì–´ í† ê¸€
// - ë°±ì§€ë„(toggleBlankMap)ì™€ ìƒí˜¸ë°°íƒ€
// - ë‘˜ ë‹¤ OFFë©´ ê¸°ë³¸ì§€ë„(ê¸°ì¡´ ë™ì‘)
// ==============================
let __cadastralLayer = null;
function __ensureCadastralLayer(){
    if (!__cadastralLayer && window.naver && naver.maps && typeof naver.maps.CadastralLayer === "function"){
        __cadastralLayer = new naver.maps.CadastralLayer();
    }
    return __cadastralLayer;
}
function __setCadastralLayer(on){
    try{
        const layer = __ensureCadastralLayer();
        if (!layer) return;
        layer.setMap(on ? window.map : null);
    }catch(e){
        console.warn("CadastralLayer toggle failed:", e);
    }
}

//ì§€ë„ ì„ íƒ
	async function createMap(useBlankMap) {
		const mapElement = document.getElementById("map");

		// âœ… ê¸°ì¡´ map ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆìœ¼ë©´ ì´ë²¤íŠ¸/ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
		try {
		  if (window.map && window.map instanceof naver.maps.Map) {
		    naver.maps.Event.clearListeners(window.map, "idle");
		    naver.maps.Event.clearListeners(window.map, "zoom_changed");
		    naver.maps.Event.clearListeners(window.map, "rightclick");
		  }
		} catch(e) {}

		// âœ… í˜„ì¬ ìœ„ì¹˜ ê¸°ì–µ
		const currentCenter = window.map?.getCenter?.();
		const currentZoom = window.map?.getZoom?.();

		// âœ… ìµœì´ˆ ë¡œë“œì‹œ "ì„œìš¸ì‹œì²­(ê¸°ë³¸ì¢Œí‘œ) â†’ ë§ˆì§€ë§‰ ìœ„ì¹˜"ë¡œ ì í”„í•˜ëŠ” í˜„ìƒ ë°©ì§€
		// - ê°€ëŠ¥í•œ í•œ "ì§€ë„ ìƒì„± ì‹œì "ë¶€í„° ë§ˆì§€ë§‰ ìœ„ì¹˜ë¡œ ì‹œì‘
		let __initialPos = null;           // {lat,lng,zoom}
		let __initialPosApplied = false;   // center/zoomì„ mapOptionsì— ë°˜ì˜í–ˆëŠ”ì§€
		try {
			const raw = localStorage.getItem("hongbu_mapPosition_fallback_v1");
			if (!currentCenter && raw) {
				const p = JSON.parse(raw);
				if (p && typeof p.lat === "number" && typeof p.lng === "number") {
					__initialPos = p;
					__initialPosApplied = true; // mapOptionsì—ì„œ ë°”ë¡œ ë°˜ì˜ ì˜ˆì •
				}
			}
		} catch(e) {}

		// localStorage í´ë°±ì´ ì—†ìœ¼ë©´ IndexedDBì—ì„œ ë¨¼ì € ì½ì–´ì„œ "ì í”„" ìì²´ë¥¼ ì—†ì•°(ì¡°ê¸ˆ ëŠë ¤ì§ˆ ìˆ˜ ìˆìŒ)
		if (!currentCenter && !__initialPos) {
			try {
				const p = await getHongbuSetting("mapPosition");
				if (p && typeof p.lat === "number" && typeof p.lng === "number") {
					__initialPos = p;
					__initialPosApplied = true;
				}
			} catch(e) {}
		}

		mapElement.innerHTML = "";

		const mapOptions = useBlankMap
			? {
				center: currentCenter || (__initialPos ? new naver.maps.LatLng(__initialPos.lat, __initialPos.lng) : new naver.maps.LatLng(37.5665, 126.9780)),
				zoom: (typeof currentZoom === "number" ? currentZoom : (__initialPos && typeof __initialPos.zoom === "number" ? __initialPos.zoom : 15)),
				mapTypes: new naver.maps.MapTypeRegistry({
					'normal': naver.maps.NaverStyleMapTypeOptions.getVectorMap()
				}),
				mapTypeId: 'normal'
			}
			: {
				center: currentCenter || (__initialPos ? new naver.maps.LatLng(__initialPos.lat, __initialPos.lng) : new naver.maps.LatLng(37.5665, 126.9780)),
				zoom: (typeof currentZoom === "number" ? currentZoom : (__initialPos && typeof __initialPos.zoom === "number" ? __initialPos.zoom : 15))
			};

		window.map = new naver.maps.Map("map", mapOptions);

		// âœ… ë²•ì •ë™(EMD) ê²½ê³„: í˜„ì¬ í™”ë©´(bounds) ë‚´ë§Œ ë Œë”ë§ (ì„±ëŠ¥ ìµœì í™”)
		ensureEmdLayerBoundToMap().catch(console.warn);
		// âœ… í–‰ì •ë™(ADM) ê²½ê³„: í˜„ì¬ í™”ë©´(bounds) ë‚´ë§Œ ë Œë”ë§
		ensureAdmLayerBoundToMap().catch(console.warn);

		// ğŸ”½ ì €ì¥ëœ ì§€ë„ ìœ„ì¹˜ ë³µì› (IndexedDB ìš°ì„ , ì‹¤íŒ¨/ë¯¸ì¡´ì¬ ì‹œ localStorage í´ë°±)
		try {
		  let pos = await getHongbuSetting("mapPosition");

		  // âœ… Android íƒ­ discard/í”„ë¡œì„¸ìŠ¤ kill ëŒ€ë¹„: IndexedDBê°€ ëŠ¦ê±°ë‚˜ ì‹¤íŒ¨í•  ë•Œ í´ë°± ì‚¬ìš©
		  if (!pos || !pos.lat || !pos.lng) {
			try {
			  const raw = localStorage.getItem("hongbu_mapPosition_fallback_v1");
			  if (raw) {
				const fb = JSON.parse(raw);
				if (fb && fb.lat && fb.lng) pos = fb;
			  }
			} catch(e) {}
		  }

		  if (pos && pos.lat && pos.lng) {
			// âœ… ì´ë¯¸ mapOptions ë‹¨ê³„ì—ì„œ ë§ˆì§€ë§‰ ìœ„ì¹˜ë¥¼ ì ìš©í–ˆë‹¤ë©´(ì í”„ ë°©ì§€), ì—¬ê¸°ì„œ ë‹¤ì‹œ ì„¼í„°ë¥¼ ë®ì–´ì“°ì§€ ì•ŠìŒ
			if (!currentCenter && !__initialPosApplied) {
				window.map.setCenter(new naver.maps.LatLng(pos.lat, pos.lng));
				if (typeof pos.zoom === "number") {
				  window.map.setZoom(pos.zoom);
				}
			}
			// âœ… ë³µì› ì ìš©ë¨ í‘œì‹œ
			try { __markMapPosRestored(); } catch(e) {}
		  }
		} catch (err) {
		  console.warn("ì§€ë„ ìœ„ì¹˜ ë³µì› ì‹¤íŒ¨:", err);
		}

		// âœ… mapPosition ì €ì¥ ë¦¬ìŠ¤ë„ˆë¥¼ "í˜„ì¬ map ì¸ìŠ¤í„´ìŠ¤"ì— ì¬ë°”ì¸ë”©
		try { setupMapPositionAutoSave(window.map); } catch(e) {}

		apartmentMarkers = [];
		
		// ğŸ”„ idle ì´ë²¤íŠ¸ ì¤‘ë³µ ë“±ë¡ ë°©ì§€
		if (!window.__mapIdleListenerReady) {
			naver.maps.Event.addListener(window.map, "idle", () => {
				// âœ… ì•„íŒŒíŠ¸ ë§ˆì»¤ëŠ” í•­ìƒ
				updateMarkers(window.map.getBounds());
				// âœ… ë‚˜ë¨¸ì§€ëŠ” ë¡œë“œ ì™„ë£Œ + í† ê¸€ ONì¼ ë•Œë§Œ
				if (window.__schoolsReady) updateSchoolMarkers();
				if (window.__middleSchoolsReady) updateMiddleSchoolMarkers();
				if (window.__starbucksReady) updateStarbucksMarkers();
				if (window.__facilitiesReady) updateFacilityMarkers();
				
				// ğŸ’¾ ë©”ëª¨ ìºì‹œ ì¶”ê°€ ì •ë¦¬ (ë§¤ idleë§ˆë‹¤ í•œ ë²ˆ ë” ì ê²€)
				try {
					const bounds = window.map.getBounds();
					if (bounds && apartmentData) {
						const visibleIds = apartmentData
							.filter(apt => bounds.hasLatLng(new naver.maps.LatLng(apt.lat, apt.lng)))
							.map(apt => String(apt.id));
						
						const visibleSet = new Set(visibleIds);
						let cleanedCount = 0;
						
						for (const id of window.__memoPresenceCache.keys()) {
							if (!visibleSet.has(id)) {
								window.__memoPresenceCache.delete(id);
								cleanedCount++;
							}
						}
						
						if (cleanedCount > 0) {
							hongbuDebugLog("INFO", `ğŸ§¹ ìœ íœ´ ì‹œ ë©”ëª¨ ìºì‹œ ì •ë¦¬: ${cleanedCount}ê°œ`);
						}
					}
				} catch(e) {}
			});
			window.__mapIdleListenerReady = true;
		}
			if (window.mapHandler) {
				  naver.maps.Event.clearListeners(window.map, "rightclick"); // ì´ì „ ì´ë²¤íŠ¸ ì œê±°
			}
		window.mapHandler = new MapHandler(window.map);

		// âœ… ë§ˆì§€ë§‰ ë¶ˆëŸ¬ì˜¨ GPX ìë™ ë³µì› (ì•ˆë“œë¡œì´ë“œ ì•± ì „í™˜/ìƒˆë¡œê³ ì¹¨ ëŒ€ë¹„)
		try {
			const saved = await getHongbuSetting("lastGpxPath");
			if (Array.isArray(saved) && saved.length >= 2) {
				const path = saved.map(p => new naver.maps.LatLng(p.lat, p.lon));
				window.mapHandler.clearMap({ forgetStoredGpx: false });
				window.mapHandler.drawGPXPath(path);
				window.mapHandler.updateEndMarker(path);
			}
		} catch (e) {
			console.warn("lastGpxPath ë³µì› ì‹¤íŒ¨:", e);
		}

		/*
		if(window.matchMedia("(max-width: 768px)").matches){
			setTimeout(() => {
				clickLocationButton();
			  }, 1000);  // 1ì´ˆ ì§€ì—°
		}
		*/

		
// ë°ì´í„° ë¡œë“œ (ìš°ì„ ìˆœìœ„: ì•„íŒŒíŠ¸ ë§ˆì»¤ + ë©”ëª¨ â†’ 2ê°œ ì™„ë£Œ í›„ ë‚˜ë¨¸ì§€ ë³‘ë ¬)
// 1) ì•„íŒŒíŠ¸(ë§ˆì»¤) ë¨¼ì €
await loadApartments();

// 2) ë©”ëª¨ëŠ” 'ë‚´ìš©'ì„ ë¯¸ë¦¬ ë¡œë“œí•˜ì§€ ì•ŠìŒ. (ë©”ëª¨ ì•„ì´ì½˜ í‘œê¸°ëŠ” ë§ˆì»¤ ìƒì„± ì‹œ IDBì—ì„œ í‚¤ ì¡´ì¬ ì—¬ë¶€ë¥¼ ì§€ì—° ì¡°íšŒ)

// âœ… ì•„íŒŒíŠ¸+ë©”ëª¨ ì¤€ë¹„ê°€ ëë‚œ ì‹œì ì—ì„œ ì¦‰ì‹œ 1ì°¨ ë Œë” (ë§ˆì»¤/ë©”ëª¨ì•„ì´ì½˜ ìš°ì„ )
try { refreshByUIState(); } catch(e) {}
try { if (window.map && window.map.getBounds) updateMarkers(window.map.getBounds()); } catch(e) {}

// 3) ê·¸ ë‹¤ìŒ ë‚˜ë¨¸ì§€ëŠ” ë³‘ë ¬ ë¡œë“œ (ìƒì„¸/ì´ˆ/ì¤‘/í™˜ê²½/ìŠ¤ë²…/ê¸¸ì°¾ê¸°)
window.__aptDetailReady = false;
window.__schoolsReady = false;
window.__middleSchoolsReady = false;
window.__facilitiesReady = false;
window.__starbucksReady = false;
window.__findWayReady = false;

window.__aptDetailLoading = true;
        const pAptDetail = loadApartmentsDetail()
    .then(() => { window.__aptDetailReady = true; })
            .finally(() => { window.__aptDetailLoading = false; })
    .catch((e) => { console.warn("ì•„íŒŒíŠ¸ ìƒì„¸ ë¡œë“œ ì‹¤íŒ¨:", e); window.__aptDetailReady = false; });

window.__aptDetailPromise = pAptDetail;

        const pOthers = Promise.allSettled([
    loadSchools().then(() => { window.__schoolsReady = true; }).catch(()=>{}),
    loadMiddleSchools().then(() => { window.__middleSchoolsReady = true; }).catch(()=>{}),
    loadFacilities().then(() => { window.__facilitiesReady = true; }).catch(()=>{}),
    loadStarbucks().then(() => { window.__starbucksReady = true; }).catch(()=>{}),
    findWay().then(() => { window.__findWayReady = true; }).catch(()=>{}),
    pAptDetail
]);

pOthers.then(() => {
    // ë³‘ë ¬ ë¡œë“œê°€ ëë‚œ ë’¤ í† ê¸€ ìƒíƒœì— ë§ì¶° ê°±ì‹ 
    try { refreshByUIState(); } catch(e) {}
    if (window.map && window.map.getBounds) {
        try { updateMarkers(window.map.getBounds()); } catch(e) {}
        try { if (window.__schoolsReady) updateSchoolMarkers(); } catch(e) {}
        try { if (window.__middleSchoolsReady) updateMiddleSchoolMarkers(); } catch(e) {}
        try { if (window.__starbucksReady) updateStarbucksMarkers(); } catch(e) {}
        try { if (window.__facilitiesReady) updateFacilityMarkers(); } catch(e) {}
    }
});

setupRightClickEvent(); // ê¸¸ì°¾ê¸°ìš© ìš°í´ë¦­ ì´ë²¤íŠ¸
		

		//ëª¨ë°”ì¼ì´ë©´ í˜„ì¬ ìœ„ì¹˜ë¡œ ì´ë™
		
	}


	document.getElementById("toggleBlankMap").addEventListener("change", async () => {
  const blankEl = document.getElementById("toggleBlankMap");
  const cadastralEl = document.getElementById("toggleCadastralMap");

  const useBlank = blankEl.checked;

  // âœ… ìƒí˜¸ë°°íƒ€: ë°±ì§€ë„ ONì´ë©´ ì§€ì í¸ì§‘ë„ OFF (ë°±ì§€ë„ ONì¼ ë•Œë§Œ)
  if (useBlank && cadastralEl) {
    cadastralEl.checked = false;
    __setCadastralLayer(false);
  }

  await createMap(useBlank);           // ê¸°ì¡´ ë™ì‘ ìœ ì§€ (ë°±ì§€ë„ í† ê¸€ì—ì„œë§Œ ì§€ë„ ì¬ìƒì„±)
  injectMaximizeButton();              // ì§€ë„ ë‚´ë¶€ ìš°ìƒë‹¨ ìµœëŒ€í™” ë²„íŠ¼ ì£¼ì…

  // âœ… ë°±ì§€ë„ OFFë¡œ ëŒì•„ì˜¬ ë•Œ, ì§€ì í¸ì§‘ë„ ì²´í¬ê°€ ì¼œì ¸ ìˆìœ¼ë©´ ë ˆì´ì–´ë¥¼ ë‹¤ì‹œ ì˜¬ë¦¼
  if (!useBlank) {
    __setCadastralLayer(!!cadastralEl?.checked);
  }
});

// âœ… ì§€ì í¸ì§‘ë„ í† ê¸€ (ê¸°ì¡´ ì§€ë„ ìœ„ì— ë ˆì´ì–´ë¡œ í‘œì‹œ: ì§€ë„ ì¬ìƒì„± X)
document.getElementById("toggleCadastralMap")?.addEventListener("change", async () => {
  const blankEl = document.getElementById("toggleBlankMap");
  const cadastralEl = document.getElementById("toggleCadastralMap");
  const useCadastral = !!cadastralEl?.checked;

  // âœ… ìƒí˜¸ë°°íƒ€: ì§€ì í¸ì§‘ë„ ONì´ë©´ ë°±ì§€ë„ OFF
  if (useCadastral && blankEl?.checked) {
    // ë°±ì§€ë„ì—ì„œ ê¸°ë³¸ì§€ë„(ë˜ëŠ” ì›ë˜ ì§€ë„)ë¡œ ë³µê·€ëŠ” 'ë°±ì§€ë„ í† ê¸€' ì±…ì„ìœ¼ë¡œ ì²˜ë¦¬
    blankEl.checked = false;
    // ë°±ì§€ë„ OFFëŠ” ì§€ë„ ì¬ìƒì„±(ê¸°ì¡´ ë¡œì§) ì´ë¯€ë¡œ ì—¬ê¸°ì„œ í•œ ë²ˆë§Œ í˜¸ì¶œ
    await createMap(false);
    injectMaximizeButton();
  }

  // âœ… ì§€ì í¸ì§‘ë„ëŠ” í˜„ì¬ ì§€ë„ ìœ„ì— ë ˆì´ì–´ë¡œë§Œ ì˜¬ë¦¼
  __setCadastralLayer(useCadastral);
});

const mapElement = document.getElementById('map');

	function getMapSize() {
		return new naver.maps.Size(mapElement.offsetWidth, mapElement.offsetHeight);
	}

	let isTracking = false; // âœ… ìœ„ì¹˜ ì¶”ì  ì—¬ë¶€ (true: ì¶”ì  ì¤‘)
	window.watchId = null; // âœ… watchPositionì˜ ID (ì¤‘ë³µ ë“±ë¡ ë°©ì§€)

		
	function showLocationPopup() {
	  
console.log("showLocationPopup");
	}

	function hideLocationPopup() {
	  
console.log("hideLocationPopup");
	}

	function clickLocationButton(){
		if (!window.map || !(window.map instanceof naver.maps.Map)) {
			console.error("ë„¤ì´ë²„ ì§€ë„ ê°ì²´ê°€ ì˜¬ë°”ë¥´ê²Œ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
			return;
		}
		
		// ğŸ”„ ì´ë¯¸ tracking ì¤‘ì´ë©´ ì¤‘ì§€
		if (isTracking === true) {
			stopTracking();
			return;
		}

		document.getElementById("locationPopup").style.display = "block";
		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(
				(position) => {
					console.log(document.getElementById("locationPopup").style.display);
					updateUserLocation(position, true); // âœ… ê°•ì œ ì´ë™ (true)
					document.getElementById("locationPopup").style.display = "none";
					console.log(document.getElementById("locationPopup").style.display);
					startTracking(); // âœ… ìœ„ì¹˜ ì¶”ì  ì‹œì‘
				},
				(error) => {
					document.getElementById("locationPopup").style.display = "none";
					alert("í˜„ì¬ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìœ„ì¹˜ ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.");
					hongbuDebugLog("ERR", "ìœ„ì¹˜ ì¡°íšŒ ì‹¤íŒ¨", `ì½”ë“œ: ${error.code}`);
				},
				{
					enableHighAccuracy: false,
					timeout: 10000,
					maximumAge: 30000
				}
			);
		} else {
			alert("ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ìœ„ì¹˜ ì •ë³´ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
		}
	}

	document.getElementById("locationButton").addEventListener("click", () => {
		clickLocationButton();
	});

	function startTracking() {
		// ğŸ”„ ì´ë¯¸ tracking ì¤‘ì´ë©´ ê¸°ì¡´ ê²ƒ ì •ë¦¬ í›„ ì¬ì‹œì‘
		if (window.watchId !== null && window.watchId !== undefined) {
			navigator.geolocation.clearWatch(window.watchId);
			hongbuDebugLog("INFO", "ê¸°ì¡´ ìœ„ì¹˜ ì¶”ì  ì •ë¦¬ í›„ ì¬ì‹œì‘");
		}

		if (navigator.geolocation) {
			isTracking = true; // âœ… ìœ„ì¹˜ ì¶”ì  í™œì„±í™”
			window.watchId = navigator.geolocation.watchPosition(
				(position) => {
					updateUserLocation(position, false); // âœ… ì„¼í„° ì´ë™ X (false)
				},
				(error) => {
					hongbuDebugLog("ERR", "ì‹¤ì‹œê°„ ìœ„ì¹˜ ì¶”ì  ì‹¤íŒ¨", `ì½”ë“œ: ${error.code}`);
					// âš ï¸ ì—ëŸ¬ ì•Œë¦¼ ì œê±° (ë°°ê²½ì—ì„œ ì¡°ìš©íˆ ì§„í–‰)
				},
				{ 
					enableHighAccuracy: false, // ë°°í„°ë¦¬ ì ˆê°
					timeout: 10000,
					maximumAge: 5000  // 5ì´ˆ ì´ë‚´ ìºì‹œ ì‚¬ìš©
				}
			);
			hongbuDebugLog("INFO", `ìœ„ì¹˜ ì¶”ì  ì‹œì‘ (watchId: ${window.watchId})`);
		}
	}

	function stopTracking() {
		if (window.watchId !== null) {
			navigator.geolocation.clearWatch(window.watchId);
			//console.log("ìœ„ì¹˜ ì¶”ì ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. watchId:", window.watchId);
			window.watchId = null;
			isTracking = false; // âœ… ìœ„ì¹˜ ì¶”ì  ë¹„í™œì„±í™”

			// âœ… ë§ˆì»¤ ì œê±°
			if (window.currentLocationMarker) {
				window.currentLocationMarker.setMap(null);
				window.currentLocationMarker = null;
			}
		} else {
			console.warn("ìœ„ì¹˜ ì¶”ì ì´ ì´ë¯¸ ì¤‘ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤.");
		}
	}

	// âœ… "ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€" ë²„íŠ¼ ì´ë²¤íŠ¸
	document.getElementById("stopTrackingButton").addEventListener("click", stopTracking);

	function updateUserLocation(position, forceCenter = false) {
		const lat = position.coords.latitude;
		const lon = position.coords.longitude;
		const currentLocation = new naver.maps.LatLng(lat, lon);

		//console.log("í˜„ì¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸:", currentLocation, "ê°•ì œ ì´ë™ ì—¬ë¶€:", forceCenter);

		// âœ… ìœ„ì¹˜ ì¶”ì  ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜, ê°•ì œ ì´ë™ í”Œë˜ê·¸ê°€ trueì¼ ë•Œë§Œ ì§€ë„ ì¤‘ì‹¬ ì´ë™
		if (!isTracking || forceCenter) {
			window.map.setCenter(currentLocation);
			window.map.setZoom(16);
		}

		// âœ… ê¸°ì¡´ ë§ˆì»¤ ì‚­ì œ
		if (window.currentLocationMarker) {
			window.currentLocationMarker.setMap(null);
		}

		// âœ… í˜„ì¬ ìœ„ì¹˜ ë§ˆì»¤ ì¶”ê°€
		window.currentLocationMarker = new naver.maps.Marker({
			position: currentLocation,
			map: window.map,
			icon: {
				content: `<div style="width: 14px; height: 14px; background-color: red; border-radius: 50%; border: 3px solid white;"></div>`,
				anchor: new naver.maps.Point(7, 7)
			}
		});
	}


	let map; // âœ… ì „ì—­ ë³€ìˆ˜ ì„¤ì •
	let watchId = null; // âœ… ì „ì—­ ë³€ìˆ˜ë¡œ ìœ„ì¹˜ ì¶”ì  ID ì €ì¥

	let locationCircle = null; // âœ… ë°˜ê²½ 500m ì› ê°ì²´ ì €ì¥
	let currentLocationMarker = null; // âœ… í˜„ì¬ ìœ„ì¹˜ ë§ˆì»¤ ì €ì¥

	let apartmentData = []; // âœ… ì „ì²´ ì•„íŒŒíŠ¸ ë°ì´í„° ì €ì¥
	let apartmentMarkers = []; // âœ… ì§€ë„ì— í‘œì‹œëœ ë§ˆì»¤ ì €ì¥
	let markerCluster = null; // âœ… ë§ˆì»¤ í´ëŸ¬ìŠ¤í„°ë§ ê°ì²´


// =========================
// âœ… ë²•ì •ë™(EMD) ê²½ê³„ í‘œì‹œ (GeoJSON) - í™”ë©´ ë²”ìœ„(bounds) ë‚´ë§Œ ë Œë”ë§
// ì‚¬ìš©ë²•:
// 1) shpë¥¼ EPSG:4326(WGS84) GeoJSONìœ¼ë¡œ ë³€í™˜ í›„ ê°™ì€ í´ë”ì— emd_wgs84.geojson ë°°ì¹˜
// 2) ì•„ë˜ GEOJSON_URLë§Œ ë§ì¶”ë©´ ë™ì‘
// =========================
const EMD_GEOJSON_PARTS = ["emd_wgs84_utf8_part01.geojson", "emd_wgs84_utf8_part02.geojson", "emd_wgs84_utf8_part03.geojson", "emd_wgs84_utf8_part04.geojson"];
const ADM_GEOJSON_PARTS = ["adm_part_001.geojson", "adm_part_002.geojson"];
// âœ… í–‰ì •ë™(ADM) ê²½ê³„ GeoJSON (24MB ë¶„í• )
// âœ… UTF-8 GeoJSON (A2 í•œê¸€ í¬í•¨)  // âœ… íŒŒì¼ëª…/ê²½ë¡œ ë§ì¶°ì£¼ì„¸ìš”

let emdGeojson = null;
let emdPrepared = null;   // { bbox:[minLng,minLat,maxLng,maxLat], geometry, properties }[]

// ==============================
// âœ… SIG(ì‹œêµ°êµ¬) ê²½ê³„ í‘œì‹œ (ì¤Œ 14 ì´í•˜)
// ==============================
const SIG_GEOJSON_PARTS = ["sig_wgs84_utf8_part01.geojson", "sig_wgs84_utf8_part02.geojson"];
let sigPrepared = null;
let sigPolygons = [];

let sigStyleMode = "default"; // "default" | "admin"

let sigLabels = [];

let emdPolygons = [];     // í˜„ì¬ ì§€ë„ì— ê·¸ë ¤ì§„ polygon ê°ì²´ë“¤

let emdLabels = [];
// ==============================
// âœ… ADM(í–‰ì •ë™) helpers/vars
// ==============================
let admGeojsonRaw = null;
let admPrepared = null;
let admPolygons = [];

let admLabels = [];
let admRedrawTimer = null;
let admBoundMap = null;
let admLoaded = false;
      // í˜„ì¬ ì§€ë„ì— í‘œì‹œëœ ë¼ë²¨(ì»¤ìŠ¤í…€ ì˜¤ë²„ë ˆì´/ë§ˆì»¤)
function clearEmdLabels() {
	if (!emdLabels || emdLabels.length === 0) return;
	emdLabels.forEach(o => { try { o.setMap && o.setMap(null); } catch(e){} });
	emdLabels = [];
}

// bbox ì¤‘ì‹¬ì„ ë¼ë²¨ ìœ„ì¹˜ë¡œ ì‚¬ìš© (ë¹ ë¥´ê³  ì¶©ë¶„íˆ ì •í™•)
function getLabelLatLngByBbox(bbox){
	const lng = (bbox[0] + bbox[2]) / 2;
	const lat = (bbox[1] + bbox[3]) / 2;
	return new naver.maps.LatLng(lat, lng);
}


// âœ… ë¼ë²¨ ìœ„ì¹˜(ì‹œê°ì  ì¤‘ì‹¬) ê³„ì‚°: polylabel(ë„í˜• ë‚´ë¶€ì—ì„œ ê°€ì¥ ë„“ì€ ì§€ì )
// - centroid/bbox ì¤‘ì‹¬ë³´ë‹¤ ê²¹ì¹¨ì´ ëœí•˜ê³ , ì˜¤ëª©/ì„¸ë¡œë¡œ ê¸´ ë„í˜•ì—ì„œë„ ì•ˆì •ì 
function _emd_pointToPolygonDist(x, y, polygon) {
	let inside = false;
	let minDistSq = Infinity;

	for (let k = 0; k < polygon.length; k++) {
		const ring = polygon[k];
		for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
			const ax = ring[i][0], ay = ring[i][1];
			const bx = ring[j][0], by = ring[j][1];

			// ray casting
			const intersect = ((ay > y) !== (by > y)) && (x < (bx - ax) * (y - ay) / (by - ay + 0.0) + ax);
			if (intersect) inside = !inside;

			// distance to segment
			const dx = bx - ax, dy = by - ay;
			let t = ((x - ax) * dx + (y - ay) * dy) / (dx * dx + dy * dy);
			t = Math.max(0, Math.min(1, t));
			const px = ax + t * dx, py = ay + t * dy;
			const distSq = (x - px) * (x - px) + (y - py) * (y - py);
			if (distSq < minDistSq) minDistSq = distSq;
		}
	}
	const dist = Math.sqrt(minDistSq);
	return inside ? dist : -dist;
}

function _emd_ringAreaAbs(ring) {
	let a = 0;
	for (let i = 0; i < ring.length; i++) {
		const x1 = ring[i][0], y1 = ring[i][1];
		const x2 = ring[(i + 1) % ring.length][0], y2 = ring[(i + 1) % ring.length][1];
		a += (x1 * y2 - x2 * y1);
	}
	return Math.abs(a * 0.5);
}

function _emd_polylabel(polygon, precision = 1e-5) {
	const outer = polygon[0];
	let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	for (const p of outer) {
		const x = p[0], y = p[1];
		if (x < minX) minX = x;
		if (y < minY) minY = y;
		if (x > maxX) maxX = x;
		if (y > maxY) maxY = y;
	}

	const width = maxX - minX;
	const height = maxY - minY;
	const cellSize = Math.min(width, height);
	if (!isFinite(cellSize) || cellSize === 0) return outer[0];

	function Cell(x, y, h, d) {
		this.x = x; this.y = y; this.h = h;
		this.d = d;
		this.max = this.d + this.h * Math.SQRT2;
	}

	let h = cellSize / 2;
	let cells = [];

	for (let x = minX; x < maxX; x += cellSize) {
		for (let y = minY; y < maxY; y += cellSize) {
			const cx = x + h, cy = y + h;
			const d = _emd_pointToPolygonDist(cx, cy, polygon);
			cells.push(new Cell(cx, cy, h, d));
		}
	}

	// initial best: bbox center and first point
	let best = new Cell((minX + maxX) / 2, (minY + maxY) / 2, 0, _emd_pointToPolygonDist((minX + maxX) / 2, (minY + maxY) / 2, polygon));
	const fp = outer[0];
	const fpCell = new Cell(fp[0], fp[1], 0, _emd_pointToPolygonDist(fp[0], fp[1], polygon));
	if (fpCell.d > best.d) best = fpCell;

	// sort by max descending (simple priority queue)
	cells.sort((a, b) => b.max - a.max);

	while (cells.length) {
		const cell = cells.shift();
		if (cell.d > best.d) best = cell;
		if (cell.max - best.d <= precision) continue;

		const h2 = cell.h / 2;
		const children = [
			[cell.x - h2, cell.y - h2],
			[cell.x + h2, cell.y - h2],
			[cell.x - h2, cell.y + h2],
			[cell.x + h2, cell.y + h2],
		];

		for (const c of children) {
			const cx = c[0], cy = c[1];
			const d = _emd_pointToPolygonDist(cx, cy, polygon);
			const child = new Cell(cx, cy, h2, d);

			// insert keeping sort desc by max (fast enough for our scale)
			let idx = 0;
			while (idx < cells.length && cells[idx].max > child.max) idx++;
			cells.splice(idx, 0, child);
		}
	}

	return [best.x, best.y];
}
function _emd_clamp(v, a, b) {
  return Math.max(a, Math.min(b, v));
}

function _emd_aspectFromBbox(bbox){
  const [minLng, minLat, maxLng, maxLat] = bbox;
  const w = Math.max(1e-12, (maxLng - minLng));
  const h = Math.max(1e-12, (maxLat - minLat));
  return w > h ? (w / h) : (h / w); // í•­ìƒ >= 1
}

// âœ… ì—¬ê¸°ë§Œ êµì²´í•˜ë©´ ë¨
function getLabelLatLngByPolylabel(geometry, bbox) {
  const polys = (geometry.type === "MultiPolygon")
    ? geometry.coordinates
    : [geometry.coordinates];

  // 1) ê°€ì¥ í° í´ë¦¬ê³¤ ì„ íƒ
  let bestPoly = polys[0];
  let bestArea = -1;

  for (const p of polys) {
    const ring = p[0];
    let a = 0;
    for (let i = 0; i < ring.length; i++) {
      const [x1, y1] = ring[i];
      const [x2, y2] = ring[(i + 1) % ring.length];
      a += (x1 * y2 - x2 * y1);
    }
    a = Math.abs(a * 0.5);
    if (a > bestArea) {
      bestArea = a;
      bestPoly = p;
    }
  }

  // 2) polylabel (ì•ˆì „í•œ ë‚´ë¶€ì )
  const pl = _emd_polylabel(bestPoly, 1e-5); // [lng, lat]

  // 3) centroid (ì‚¬ëŒì´ ëŠë¼ëŠ” ì¤‘ì•™ ì„±í–¥)
  const ct = _emd_ringCentroidLngLat(bestPoly[0]) || pl;

  // 4) ë„í˜•ì´ ê¸¸ì­‰í• ìˆ˜ë¡ centroid ìª½ìœ¼ë¡œ ë” ë‹¹ê¹€
  const ar = _emd_aspectFromBbox(bbox); // ì¢…íš¡ë¹„
  const t = _emd_clamp((ar - 1) / 3, 0.2, 0.8); // ğŸ”¥ ìë™ ë³´ì • í•µì‹¬

  const blended = _emd_lerp(pl, ct, t);

  return new naver.maps.LatLng(blended[1], blended[0]);
}




/* === LABEL AUTO-FIT (bbox â†’ pixel â†’ font-size) === */
/* === LABEL AUTO-FIT (bbox â†’ pixel â†’ font-size) ===
   - í•­ìƒ ê²½ê³„(bbox) ì•ˆì— í…ìŠ¤íŠ¸ê°€ ë“¤ì–´ê°€ë„ë¡ font-sizeë¥¼ ìë™ìœ¼ë¡œ ë§ì¶¥ë‹ˆë‹¤.
   - bboxëŠ” [minLng, minLat, maxLng, maxLat]
*/
function _label_getBboxPixelSize(bbox, map){
  try{
    const proj = map && map.getProjection && map.getProjection();
    if (!proj) return null;

    const sw = proj.fromCoordToOffset(new naver.maps.LatLng(bbox[1], bbox[0]));
    const ne = proj.fromCoordToOffset(new naver.maps.LatLng(bbox[3], bbox[2]));
    return { width: Math.abs(ne.x - sw.x), height: Math.abs(ne.y - sw.y) };
  }catch(e){
    return null;
  }
}

function _label_measureTextPx(text, fontSizePx, fontWeight = 800, fontFamily = "sans-serif") {
  const canvas = _label_measureTextPx._canvas || (_label_measureTextPx._canvas = document.createElement("canvas"));
  const ctx = canvas.getContext("2d");
  ctx.font = `${fontWeight} ${fontSizePx}px ${fontFamily}`;
  const w = ctx.measureText(text).width;
  const h = fontSizePx * 1.15; // í•œê¸€/ì˜ë¬¸ ëª¨ë‘ ë³´ìˆ˜ì ìœ¼ë¡œ ì»¤ë²„
  return { w, h };
}

// âœ… í•µì‹¬: bbox í”½ì…€ ë°•ìŠ¤ ì•ˆì— í…ìŠ¤íŠ¸ê°€ "ë°˜ë“œì‹œ" ë“¤ì–´ê°€ë„ë¡ font-sizeë¥¼ fit
function _label_calcFitFontSize({
  bbox,
  text,
  map,
  paddingPx = 8,
  min = 8,
  max = 40,
  fontWeight = 800,
  fontFamily = "sans-serif",
  hideIfTooSmall = true
}) {
  const px = _label_getBboxPixelSize(bbox, map);
  if (!px) return min;

  const availW = Math.max(0, px.width  - paddingPx * 2);
  const availH = Math.max(0, px.height - paddingPx * 2);

  // bboxê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ìˆ¨ê¹€
  if (hideIfTooSmall && (availW < 10 || availH < 10)) return 0;

  // ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ "ë“¤ì–´ê°€ëŠ”" ìµœëŒ€ font-size ì°¾ê¸°
  let lo = min, hi = max, best = 0;
  while (lo <= hi) {
    const mid = (lo + hi) >> 1;
    const m = _label_measureTextPx(text, mid, fontWeight, fontFamily);
    if (m.w <= availW && m.h <= availH) {
      best = mid;
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }

  if (best === 0) return hideIfTooSmall ? 0 : min;
  return best;
}

// âœ… ë™ ë¼ë²¨(ë²•ì •/í–‰ì •) ê³ ì • í°íŠ¸ í¬ê¸°(PC ê¸°ì¤€)
// (removed fixed label size)



function addEmdLabel(latlng, text, bbox, forcedFontSizePx) {
  if (!text || !bbox || !window.map) return;

  const fs = (typeof forcedFontSizePx === "number")
    ? forcedFontSizePx
    : _label_calcFitFontSize({
        bbox,
        text,
        map: window.map,
        paddingPx: 8,
        min: 9,
        max: 20,
        hideIfTooSmall: true
      });

  if (fs <= 0) return;

  const marker = new naver.maps.Marker({
    position: latlng,
    map: window.map,
    clickable: false,
    zIndex: 999999,
    icon: {
      content: `<div class="emd-label" style="font-size:${fs}px">${text}</div>`,
      anchor: new naver.maps.Point(0, 0)
    }
  });

  emdLabels.push(marker);
}



let emdRedrawTimer = null;
let emdBoundMap = null; // ë§ˆì§€ë§‰ìœ¼ë¡œ ë°”ì¸ë”©ëœ map ì¸ìŠ¤í„´ìŠ¤

function clearEmdPolygons() {
  // âœ… ê²½ê³„ í´ë¦¬ê³¤ ì œê±°
  if (emdPolygons && emdPolygons.length) {
    emdPolygons.forEach(p => {
      try { p.setMap(null); } catch(e){}
    });
    emdPolygons = [];
  }

  // âœ… ì§€ì—­ëª… ë¼ë²¨ ì œê±° (â† ë„¤ê°€ ë¬¼ì–´ë³¸ ì½”ë“œ)
  if (emdLabels && emdLabels.length) {
    emdLabels.forEach(m => {
      try { m.setMap(null); } catch(e){}
    });
    emdLabels = [];
  }
}


function bboxIntersects(bounds, bbox) {
	// bounds: naver.maps.LatLngBounds
	const sw = bounds.getSW();
	const ne = bounds.getNE();
	const minLng = bbox[0], minLat = bbox[1], maxLng = bbox[2], maxLat = bbox[3];
	// bboxê°€ boundsì™€ ê²¹ì¹˜ì§€ ì•Šìœ¼ë©´ false
	if (maxLng < sw.lng()) return false;
	if (minLng > ne.lng()) return false;
	if (maxLat < sw.lat()) return false;
	if (minLat > ne.lat()) return false;
	return true;
}

function _prepareFeatureBBoxes(featureCollection) {
  const feats = featureCollection?.features || [];
  return feats.map(f => {
    const geom = f.geometry;
    const polys = (geom.type === "MultiPolygon") ? geom.coordinates : [geom.coordinates];
    let minLng=Infinity, minLat=Infinity, maxLng=-Infinity, maxLat=-Infinity;
    for (const poly of polys) {
      const ring = poly[0];
      for (const pt of ring) {
        const lng = pt[0], lat = pt[1];
        if (lng < minLng) minLng = lng;
        if (lat < minLat) minLat = lat;
        if (lng > maxLng) maxLng = lng;
        if (lat > maxLat) maxLat = lat;
      }
    }
    return { geometry: geom, properties: f.properties || {}, bbox: [minLng, minLat, maxLng, maxLat] };
  });
}

function prepareSigPreparedOnce() {
  if (sigPrepared) return;
  if (!sigGeojsonRaw) throw new Error("SIG GeoJSON not loaded");
  sigPrepared = _prepareFeatureBBoxes(sigGeojsonRaw);
}

function prepareEmdPreparedOnce() {
  if (emdPrepared) return;
  if (!emdGeojsonRaw) throw new Error("EMD GeoJSON not loaded");
  emdPrepared = _prepareFeatureBBoxes(emdGeojsonRaw);
}



function computeFeatureBbox(geom) {
	let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

	function scanCoords(coordArray) {
		// coordArray: [lng,lat]ë“¤ì˜ ì¤‘ì²© ë°°ì—´
		for (const item of coordArray) {
			if (!item) continue;
			if (typeof item[0] === "number" && typeof item[1] === "number") {
				const lng = item[0], lat = item[1];
				if (lng < minLng) minLng = lng;
				if (lng > maxLng) maxLng = lng;
				if (lat < minLat) minLat = lat;
				if (lat > maxLat) maxLat = lat;
			} else if (Array.isArray(item)) {
				scanCoords(item);
			}
		}
	}

	scanCoords(geom.coordinates);

	if (!isFinite(minLng) || !isFinite(minLat) || !isFinite(maxLng) || !isFinite(maxLat)) {
		return null;
	}
	return [minLng, minLat, maxLng, maxLat];
}

async function loadEmdBoundaryOnce() {
  if (emdPrepared) return;

  const parts = EMD_GEOJSON_PARTS;
  const results = await Promise.all(parts.map(p => fetch(p).then(r => {
    if (!r.ok) throw new Error(`Fetch failed: ${p} ${r.status}`);
    return r.json();
  })));

  // Merge FeatureCollections
  const merged = { type: "FeatureCollection", features: [] };
  for (const fc of results) {
    if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
      merged.features.push(...fc.features);
    }
  }

  // Store raw FC for downstream prepare step
  emdGeojsonRaw = merged;
}


// ==============================
// âœ… ADM(í–‰ì •ë™) boundary loader
// ==============================
async function loadAdmBoundaryOnce() {
  if (admLoaded) return;

  const parts = ADM_GEOJSON_PARTS;
  const results = await Promise.all(parts.map(p => fetch(p).then(r => {
    if (!r.ok) throw new Error(`Fetch failed: ${p} ${r.status}`);
    return r.json();
  })));

  const merged = { type: "FeatureCollection", features: [] };
  for (const fc of results) {
    if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
      merged.features.push(...fc.features);
    }
  }

  admGeojsonRaw = merged;
  admLoaded = true;
}

function prepareAdmPreparedOnce() {
  if (admPrepared) return;
  if (!admGeojsonRaw) throw new Error("ADM GeoJSON not loaded");
  admPrepared = _prepareFeatureBBoxes(admGeojsonRaw);
}

function clearAdmPolygons() {
  if (admPolygons && admPolygons.length) {
    admPolygons.forEach(p => { try { p.setMap(null); } catch(e){} });
    admPolygons = [];
  }
}

function clearAdmLabels() {
  if (admLabels && admLabels.length) {
    admLabels.forEach(o => { try { o.setMap && o.setMap(null); } catch(e){} });
    admLabels = [];
  }
}

function addAdmLabel(latlng, text, bbox, forcedFontSizePx) {
  if (!text || !bbox || !window.map) return;

  const fs = (typeof forcedFontSizePx === "number")
    ? forcedFontSizePx
    : _label_calcFitFontSize({
        bbox,
        text,
        map: window.map,
        paddingPx: 8,
        min: 9,
        max: 20,
        hideIfTooSmall: true
      });

  const marker = new naver.maps.Marker({
    position: latlng,
    map: window.map,
    clickable: false,
    zIndex: 999998, // ë²•ì •ë™ ë¼ë²¨ë³´ë‹¤ ì•½ê°„ ì•„ë˜
    icon: {
      content: `<div class="emd-label" style="font-size:${fs}px; color:#1e40af;">${text}</div>`,
      anchor: new naver.maps.Point(0, 0)
    }
  });

  admLabels.push(marker);
}



function drawAdmGeometry(geom) {
  const type = geom.type;
  const coords = geom.coordinates;
  const polygons = (type === "MultiPolygon") ? coords : [coords];

  polygons.forEach(poly => {
    if (!poly || !poly[0] || poly[0].length < 3) return;
    const ring = poly[0];
    const path = ring.map(c => new naver.maps.LatLng(c[1], c[0]));
    const polygon = new naver.maps.Polygon({
      map: window.map,
      paths: path,
      strokeColor: "#1e40af",
      strokeOpacity: 0.85,
      strokeWeight: 2,
      fillColor: "#1e40af",
      fillOpacity: 0.01
    });
    admPolygons.push(polygon);
  });
}

function isAdminBoundaryCheckboxOn() {
  const cb = document.getElementById("toggleAdminBoundary");
  return !!(cb && cb.checked);
}

function shouldShowAdminBoundary() {
  if (!isAdminBoundaryCheckboxOn()) return false;
  if (!window.map) return false;
  // âœ… ë²•ì •ë™ê²½ê³„ì²˜ëŸ¼: ì¤Œ 15 ì´ìƒì—ì„œë§Œ í‘œì‹œ
  return window.map.getZoom() >= 15;
}

function redrawAdmByBounds() {
  try { prepareAdmPreparedOnce(); } catch(e) { console.error('ADM prepare ì‹¤íŒ¨:', e); return; }
  if (!window.map) return;

  if (!shouldShowAdminBoundary()) {
    clearAdmPolygons();
  clearAdmLabels();
  return;
  }

  const bounds = window.map.getBounds();
  if (!bounds) return;

  clearAdmPolygons();

  for (const f of admPrepared) {
    if (!bboxIntersects(bounds, f.bbox)) continue;
    drawAdmGeometry(f.geometry);

    // âœ… í–‰ì •ë™ ë¼ë²¨
    const fullName = (f.properties && (f.properties.adm_nm || f.properties.NAME || f.properties.A2 || f.properties.name)) || "";
    const name = String(fullName).trim().split(/\s+/).pop() || "";
if (name) {
      const center = getLabelLatLngByPolylabel(f.geometry, f.bbox);
      addAdmLabel(center, name, f.bbox);
    }
}
}

function scheduleAdmRedraw() {
  if (admRedrawTimer) clearTimeout(admRedrawTimer);
  admRedrawTimer = setTimeout(() => {
    try { redrawBoundaryByZoom(); } catch (e) { console.error("Boundary redraw ì‹¤íŒ¨(ADM):", e); }
  }, 120);
}

async function ensureAdmLayerBoundToMap() {
  // GeoJSON í•œë²ˆë§Œ ë¡œë“œ
  await loadAdmBoundaryOnce();

  if (admBoundMap !== window.map) {
    admBoundMap = window.map;
    naver.maps.Event.addListener(window.map, "idle", scheduleAdmRedraw);
    naver.maps.Event.addListener(window.map, "zoom_changed", scheduleAdmRedraw);
  }

  scheduleAdmRedraw();
}


function drawEmdGeometry(geom) {
	// Polygon, MultiPolygon ì§€ì› (ì™¸ê³½ ringë§Œ ì‚¬ìš©)
	const type = geom.type;
	const coords = geom.coordinates;

	const polygons = (type === "MultiPolygon") ? coords : [coords];

	polygons.forEach(poly => {
		if (!poly || !poly[0] || poly[0].length < 3) return;
		const ring = poly[0];

		const path = ring.map(c => new naver.maps.LatLng(c[1], c[0]));

		const polygon = new naver.maps.Polygon({
		  map: window.map,
		  paths: path,
		  strokeColor: "#000000",   // âœ… ê²€ì€ìƒ‰
		  strokeOpacity: 0.9,
		  strokeWeight: 2,
		  fillColor: "#000000",     // (ì„ íƒ) ì±„ì›€ë„ ê²€ì •
		  fillOpacity: 0.01         // (ì„ íƒ) ì•„ì£¼ ì—°í•˜ê²Œ
		});


		emdPolygons.push(polygon);
	});
}


function isBoundaryCheckboxOn() {
  const cb = document.getElementById("toggleEmdBoundary");
  return !!(cb && cb.checked);
}

function shouldShowSigBoundary() {
  if (!window.map) return false;
  const z = window.map.getZoom();
  // âœ… SIGëŠ” ì¤Œ 13~14 êµ¬ê°„ì—ì„œ ì‚¬ìš©
  if (!(z > 12 && z <= 14)) return false;
  // âœ… ë²•ì •ë™ê²½ê³„ ë˜ëŠ” í–‰ì •ë™ê²½ê³„ ì²´í¬ ì‹œ í‘œì‹œ
  return isBoundaryCheckboxOn() || isAdminBoundaryCheckboxOn();
}

function shouldShowEmdBoundary() {
  if (!isBoundaryCheckboxOn()) return false;
  if (!window.map) return false;
  return window.map.getZoom() >= 15;
}

function redrawEmdByBounds() {
  try { prepareEmdPreparedOnce(); } catch(e) { console.error('redrawEmdByBounds prepare ì‹¤íŒ¨:', e); return; }

  if (!window.map) return;

  const z = window.map.getZoom();
  // âœ… ë²•ì •ë™ê²½ê³„ ì²´í¬ + ì¤Œ 15 ì´ìƒì¼ ë•Œë§Œ í‘œì‹œ
  if (!shouldShowEmdBoundary()) {
    clearEmdPolygons();
    clearEmdLabels();
    return;
  }

  const bounds = window.map.getBounds();
  if (!bounds) return;

  clearEmdPolygons();
  clearEmdLabels();

  // 1) í™”ë©´ì— ê±¸ì¹˜ëŠ” í´ë¦¬ê³¤ë§Œ ê·¸ë¦¬ê¸° + ë¼ë²¨ í›„ë³´ ìˆ˜ì§‘
  const labelCap = 200; // í™”ë©´ ë‚´ ë¼ë²¨ ìµœëŒ€ì¹˜ (ì„±ëŠ¥ ë³´í˜¸)
  const labelCandidates = [];

  for (const f of emdPrepared) {
    if (!bboxIntersects(bounds, f.bbox)) continue;

    // ê²½ê³„ ê·¸ë¦¬ê¸°
    drawEmdGeometry(f.geometry);

    // ë¼ë²¨ í›„ë³´ ìˆ˜ì§‘
    if (z >= 15 && labelCandidates.length < labelCap) {
      const name = (f.properties && (f.properties.A2 || f.properties.name || f.properties.EMD_NM)) || "";
      if (name) labelCandidates.push({ name, bbox: f.bbox, geometry: f.geometry });
    }
  }

  // 2) í›„ë³´ë“¤ ì¤‘ 'fit ê°€ëŠ¥í•œ' ìµœì†Œ í°íŠ¸ í¬ê¸° ì‚°ì¶œ (â† ì‚¬ìš©ìê°€ ì›í•˜ëŠ” "ê°€ì¥ ì‘ì€ í…ìŠ¤íŠ¸ í¬ê¸°")
  let minFit = Infinity;
  for (const c of labelCandidates) {
    const fs = _label_calcFitFontSize({
      bbox: c.bbox,
      text: c.name,
      map: window.map,
      paddingPx: 8,
      min: 9,
      max: 38,
      hideIfTooSmall: true
    });
    if (fs > 0 && fs < minFit) minFit = fs;
  }

  if (!isFinite(minFit) || minFit <= 0) return;

  
  // âœ… ëª¨ë°”ì¼ì—ì„œëŠ” ë¼ë²¨ ìµœëŒ€ 12px
  let uniformFit = minFit;
  if (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) {
    uniformFit = Math.min(uniformFit, 18);
  }
// 3) ëª¨ë“  ë¼ë²¨ì„ 'ìµœì†Œ í°íŠ¸'ë¡œ í†µì¼í•´ì„œ ë Œë”ë§ (í•­ìƒ bbox ì•ˆì— ë“¤ì–´ê°)
  for (const c of labelCandidates) {
    const latlng = getLabelLatLngByPolylabel(c.geometry, c.bbox);
    addEmdLabel(latlng, c.name, c.bbox, uniformFit);
  }
}


// âœ… SIG helpers
// ==============================
function clearSigPolygons() {
	if (sigPolygons && sigPolygons.length) {
		sigPolygons.forEach(p => { try { p.setMap(null); } catch(e){} });
		sigPolygons = [];
	}
}

function clearSigLabels() {
	if (sigLabels && sigLabels.length) {
		sigLabels.forEach(m => { try { m.setMap(null); } catch(e){} });
		sigLabels = [];
	}
}

function addSigLabel(latlng, text, bbox, forcedFontSizePx) {
  if (!text || !bbox || !window.map) return;

  const fs = (typeof forcedFontSizePx === "number")
    ? forcedFontSizePx
    : _label_calcFitFontSize({
        bbox,
        text,
        map: window.map,
        paddingPx: 10,
        min: 10,
        max: 34,
        hideIfTooSmall: true
      });

  if (fs <= 0) return;

  const color = (sigStyleMode === "admin") ? "#1e40af" : "#000000";

  const marker = new naver.maps.Marker({
    position: latlng,
    map: window.map,
    clickable: false,
    zIndex: 999998,
    icon: {
      content: `<div class="sig-label" style="font-size:${fs}px; color:${color};">${text}</div>`,
      anchor: new naver.maps.Point(0, 0)
    }
  });

  sigLabels.push(marker);
}


async function loadSigBoundaryOnce() {
  if (sigPrepared) return;

  const parts = SIG_GEOJSON_PARTS;
  const results = await Promise.all(parts.map(p => fetch(p).then(r => {
    if (!r.ok) throw new Error(`Fetch failed: ${p} ${r.status}`);
    return r.json();
  })));

  // Merge FeatureCollections
  const merged = { type: "FeatureCollection", features: [] };
  for (const fc of results) {
    if (fc && fc.type === "FeatureCollection" && Array.isArray(fc.features)) {
      merged.features.push(...fc.features);
    }
  }

  // Store raw FC for downstream prepare step
  sigGeojsonRaw = merged;
}


function drawSigGeometry(geometry) {
	const polys = (geometry.type === "MultiPolygon") ? geometry.coordinates : [geometry.coordinates];

	polys.forEach(poly => {
		const ring = poly[0];
		const path = ring.map(c => new naver.maps.LatLng(c[1], c[0]));

		const isAdminStyle = (sigStyleMode === "admin");

		const polygon = new naver.maps.Polygon({
			map: window.map,
			paths: path,
			strokeColor: isAdminStyle ? "#1e40af" : "#000000",
			strokeOpacity: isAdminStyle ? 0.85 : 1,
			strokeWeight: isAdminStyle ? 3 : 3,
			fillColor: isAdminStyle ? "#1e40af" : "#000000",
			fillOpacity: isAdminStyle ? 0.01 : 0
		});
		sigPolygons.push(polygon);
	});
}

function redrawSigByBounds() {
  try { prepareSigPreparedOnce(); } catch(e) { console.error('redrawSigByBounds prepare ì‹¤íŒ¨:', e); return; }

  if (!window.map || !sigPrepared) return;

  const bounds = window.map.getBounds();
  if (!bounds) return;

  clearSigPolygons();
  clearSigLabels();

  // 1) í™”ë©´ì— ê±¸ì¹˜ëŠ” í´ë¦¬ê³¤ë§Œ ê·¸ë¦¬ê¸° + ë¼ë²¨ í›„ë³´ ìˆ˜ì§‘
  const labelCap = 60; // ì„±ëŠ¥ ë³´í˜¸
  const labelCandidates = [];

  for (const f of sigPrepared) {
    if (!bboxIntersects(bounds, f.bbox)) continue;

    drawSigGeometry(f.geometry);

    if (labelCandidates.length < labelCap) {
      const name = f.properties?.A2 || f.properties?.SIG_KOR_NM || f.properties?.NAME || "";
      if (name) labelCandidates.push({ name, bbox: f.bbox, geometry: f.geometry });
    }
  }

  // 2) í›„ë³´ë“¤ ì¤‘ ìµœì†Œ fit í°íŠ¸ í¬ê¸° ì‚°ì¶œ
  let minFit = Infinity;
  for (const c of labelCandidates) {
    const fs = _label_calcFitFontSize({
      bbox: c.bbox,
      text: c.name,
      map: window.map,
      paddingPx: 10,
      min: 10,
      max: 34,
      hideIfTooSmall: true
    });
    if (fs > 0 && fs < minFit) minFit = fs;
  }

  if (!isFinite(minFit) || minFit <= 0) return;

  
  // âœ… ëª¨ë°”ì¼ì—ì„œëŠ” ë¼ë²¨ ìµœëŒ€ 12px
  let uniformFit = minFit;
  if (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) {
    uniformFit = Math.min(uniformFit, 18);
  }
// 3) ëª¨ë“  SIG ë¼ë²¨ì„ 'ìµœì†Œ í°íŠ¸'ë¡œ í†µì¼
  for (const c of labelCandidates) {
    const center = getLabelLatLngByPolylabel(c.geometry, c.bbox);
    addSigLabel(center, c.name, c.bbox, uniformFit);
  }
}


function redrawBoundaryByZoom() {
  if (!window.map) return;

  const z = window.map.getZoom();
  const boundaryOn = isBoundaryCheckboxOn();
  const adminOn = isAdminBoundaryCheckboxOn();

  // =========================
  // âœ… ì¤Œ 13~14: SIG ë°ì´í„° ì‚¬ìš©
  // - ë²•ì •ë™ê²½ê³„ ON ì´ê±°ë‚˜ í–‰ì •ë™ê²½ê³„ ON ì´ë©´ SIGë¥¼ í‘œì‹œ
  // - í–‰ì •ë™ê²½ê³„ ONì´ë©´ SIGë¥¼ í–‰ì •ë™ ìŠ¤íƒ€ì¼(íŒŒë€ìƒ‰)ë¡œ í‘œì‹œ
  // =========================
  if (z > 12 && z <= 14) {
    // EMD/ADMëŠ” ì´ êµ¬ê°„ì—ì„œ ìˆ¨ê¹€
    clearEmdPolygons(); clearEmdLabels();
    clearAdmPolygons(); clearAdmLabels();

    if (boundaryOn || adminOn) {
      sigStyleMode = adminOn ? "admin" : "default";
      loadSigBoundaryOnce().then(() => { try { redrawSigByBounds(); } catch(e){ console.error("SIG redraw ì‹¤íŒ¨:", e);} });
    } else {
      sigStyleMode = "default";
      clearSigPolygons(); clearSigLabels();
    }
    return;
  }

  // =========================
  // âœ… ì¤Œ 15 ì´ìƒ: ë™(ë²•ì •/í–‰ì •)
  // =========================
  sigStyleMode = "default";
  clearSigPolygons(); clearSigLabels();

  if (!boundaryOn) {
    clearEmdPolygons(); clearEmdLabels();
  } else {
    // EMD: zoom >= 15
    loadEmdBoundaryOnce().then(() => { try { redrawEmdByBounds(); } catch(e){ console.error("EMD redraw ì‹¤íŒ¨:", e);} });
  }

  if (adminOn && z >= 15) {
    loadAdmBoundaryOnce().then(() => { try { redrawAdmByBounds(); } catch(e){ console.error("ADM redraw ì‹¤íŒ¨:", e);} });
  } else {
    clearAdmPolygons(); clearAdmLabels();
  }

  // =========================
  // âœ… ì¤Œ 12 ì´í•˜: ì „ë¶€ ìˆ¨ê¹€
  // =========================
  if (z <= 12) {
    clearSigPolygons(); clearSigLabels();
    clearEmdPolygons(); clearEmdLabels();
    clearAdmPolygons(); clearAdmLabels();
  }
}



function scheduleEmdRedraw() {
	if (emdRedrawTimer) clearTimeout(emdRedrawTimer);
	emdRedrawTimer = setTimeout(() => {
		try { redrawBoundaryByZoom(); } catch (e) { console.error("Boundary redraw ì‹¤íŒ¨:", e); }
	}, 120);
}

async function ensureEmdLayerBoundToMap() {
	// GeoJSON í•œë²ˆë§Œ ë¡œë“œ
	await loadEmdBoundaryOnce();

	// createMap()ì€ ì§€ë„ë¥¼ 'ì¬ìƒì„±'í•˜ë¯€ë¡œ, map ì¸ìŠ¤í„´ìŠ¤ê°€ ë°”ë€” ë•Œë§ˆë‹¤ ì´ë²¤íŠ¸ë¥¼ ë‹¤ì‹œ ë°”ì¸ë”©í•´ì•¼ í•¨
	if (emdBoundMap !== window.map) {
		emdBoundMap = window.map;

		// ì¤Œ/ì´ë™ì´ ëë‚˜ëŠ” ì‹œì (idle)ì—ë§Œ bounds í•„í„° ë Œë”ë§
		naver.maps.Event.addListener(window.map, "idle", scheduleEmdRedraw);
		naver.maps.Event.addListener(window.map, "zoom_changed", scheduleEmdRedraw);
	}

	// ì´ˆê¸° 1íšŒ
	scheduleEmdRedraw();
}

	// âœ… 2. ì•„íŒŒíŠ¸ ë°ì´í„°ë¥¼ fetch()ë¡œ ê°€ì ¸ì˜¤ê¸°
	async function loadApartments() { 
    
		try {
			//const response = await fetch("https://your-github-username.github.io/data/apt.json"); // âœ… JSON íŒŒì¼ ì‚¬ìš©
			//const response = await fetch("apt.json");
			const response = await fetch(`apt.json?t=${Date.now()}`, { cache: "no-store" });
			const data = await response.json();

			apartmentData = data.map((apt, index) => ({
				id: apt.id,
				name: apt.name, // âœ… ì˜¬ë°”ë¥¸ ì†ì„± ì ‘ê·¼
				year: apt.year, // âœ… ì˜¬ë°”ë¥¸ ì†ì„± ì ‘ê·¼
				units: parseInt(apt.units, 10), // âœ… ì˜¬ë°”ë¥¸ ì†ì„± ì ‘ê·¼
				lat: parseFloat(apt.lat), // âœ… ì˜¬ë°”ë¥¸ ì†ì„± ì ‘ê·¼
				lng: parseFloat(apt.lng), // âœ… ì˜¬ë°”ë¥¸ ì†ì„± ì ‘ê·¼
				lease: apt.lease, // âœ… ì˜¬ë°”ë¥¸ ì†ì„± ì ‘ê·¼
				sido : apt.sido, //ì‹œë„
				sidoNm : apt.sidoNm, //ì‹œë„ëª…
				sigungu : apt.sigungu, //ì‹œêµ°êµ¬
				sigunguNm : apt.sigunguNm //ì‹œêµ°êµ¬ëª…

			}));

			
			//console.log("âœ… ì•„íŒŒíŠ¸ ë°ì´í„° fetch ì™„ë£Œ");
			updateMarkers(window.map.getBounds())

			buildRegionFiltersFromApartments();
			attachRegionFilterEvents();
			restoreRegionFiltersFromUIState();

		} catch (error) {
			console.error("âŒ ì•„íŒŒíŠ¸ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", error);
		}
	}



function closePopup() {
  //console.log("í˜¸ì¶œ")
    isPopupOpen = false;
    if (activeMarkerSet) {

        activeMarkerSet = null;
    }
    //console.log("âŒ ì´ë™ ëª¨ë“œ ì¢…ë£Œ");
}

function makeModalDraggable(modal) {
        let isDragging = false;
        let offsetX, offsetY;

        const header = document.createElement('div');
        header.className = 'draggable';
        header.style.padding = '10px';
        header.style.cursor = 'move';
        header.style.backgroundColor = '#f1f1f1';
        header.style.borderBottom = '1px solid #ccc';
        header.textContent = 'Drag me';

        modal.insertBefore(header, modal.firstChild);

        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - modal.offsetLeft;
            offsetY = e.clientY - modal.offsetTop;
            document.addEventListener('mousemove', moveModal);
            document.addEventListener('mouseup', stopDragging);
        });

        function moveModal(e) {
            if (isDragging) {
                modal.style.left = `${e.clientX - offsetX}px`;
                modal.style.top = `${e.clientY - offsetY}px`;
            }
        }

        function stopDragging() {
            isDragging = false;
            document.removeEventListener('mousemove', moveModal);
            document.removeEventListener('mouseup', stopDragging);
        }
    }


// âœ… ì‹œì„¸ ë§ˆì»¤ì—ì„œ í…Œì´ë¸”ì´ ì•„ë‹Œ ì˜ì—­ì„ ìš°í´ë¦­í•˜ë©´ ìƒ‰ìƒ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
function addSiseMapMarkerLeftClickEvent(marker, markerElement) {
//console.log("addSiseMapMarkerLeftClickEvent ì‹¤í–‰ë¨");
    naver.maps.Event.addListener(marker, "click", (e) => {
        e.domEvent.preventDefault(); // ê¸°ë³¸ ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
        e.domEvent.stopPropagation();

        const tableContainer = markerElement.querySelector(".tableContainer");

        // âœ… í…Œì´ë¸” ì˜ì—­ì„ í´ë¦­í•œ ê²½ìš° ìƒ‰ìƒ ì„ íƒ ëª¨ë‹¬ì„ ë„ìš°ì§€ ì•ŠìŒ
        if (e.domEvent.target.closest(".tableContainer")) {
            return;
        }

        //console.log("ğŸš€ ë§ˆì»¤ ìš°í´ë¦­ ê°ì§€:", markerElement.dataset);

        let apartmentId = markerElement.dataset.apartmentId;
        if (!apartmentId) {
            console.error("âŒ apartmentId ì°¾ì„ ìˆ˜ ì—†ìŒ!");
            return;
        }

        showColorPickerModal(apartmentId, markerElement.style.backgroundColor, markerElement.style.color, markerElement.style.fontSize, 
			(selectedColor, textColor, fontSize) => {
				markerElement.style.backgroundColor = selectedColor;
				markerElement.style.color = textColor;
				markerElement.style.fontSize = fontSize;

				updateMarkerStyleAndSave(apartmentId, selectedColor, textColor, fontSize); // âœ… apartmentIdê°€ ì •ìƒì ìœ¼ë¡œ ì „ë‹¬ë¨
			});



    });
}

function updateMarkerStyleAndSave(id, selectedColor, textColor, fontSize) {
    getFromIndexedDB(id, "ì‹œì„¸1").then(existingData => {
        let existingText = existingData?.text || generateDefaultTable();

        // âœ… ê¸°ë³¸ê°’ ê°•ì œ ì ìš©
        selectedColor = selectedColor?.trim() || '#9F9F9F';
        textColor = textColor?.trim() || '#FFFFFF';
        fontSize = fontSize?.trim() || '12px';

        //console.log(`ğŸ¨ ë§ˆì»¤ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ ì‹œë„ (ID: ${id})`, { selectedColor, textColor, fontSize });

        // âœ… IndexedDB ì €ì¥
        saveToIndexedDB(id, "ì‹œì„¸1", existingText, selectedColor, textColor, fontSize);

        // âœ… ë§ˆì»¤ ìŠ¤íƒ€ì¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        let markerElement = document.querySelector(`[data-apartment-id='${id}']`);
        if (!markerElement) {
            console.error(`âŒ ë§ˆì»¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ID: ${id}`);
            return;
        }

        // âœ… ğŸ’¡ ì¤‘ìš”: ê¸€ì ìƒ‰ìƒ ë° í¬ê¸° ì¦‰ì‹œ ë°˜ì˜
        markerElement.style.backgroundColor = selectedColor;
        markerElement.style.color = textColor;
        markerElement.style.setProperty("color", textColor, "important"); // âœ… ì¦‰ì‹œ ì ìš© (ì¤‘ìš”ë„ ë†’ì´ê¸°)
        markerElement.style.setProperty("font-size", fontSize, "important");

        markerElement.style.setProperty("font-size", fontSize, "important"); // âœ… ì¦‰ì‹œ ì ìš© (ì¤‘ìš”ë„ ë†’ì´ê¸°)


        // âœ… ë‚´ë¶€ í…Œì´ë¸”ì˜ ê¸€ììƒ‰ & í¬ê¸° ì¦‰ì‹œ ë°˜ì˜
        let tableContainer = markerElement.querySelector(".tableContainer");
        if (tableContainer) {
            tableContainer.style.color = textColor;
            tableContainer.style.fontSize = fontSize;
            tableContainer.style.setProperty("font-size", fontSize, "important");
        }

    }).catch(error => {
        console.error("âŒ IndexedDB ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", error);
    });
}


// ================================
// âœ… ë©”ëª¨ ì•„ì´ì½˜ 'í‘œê¸°'ë§Œ ì§€ì—° ì¡°íšŒ(ë‚´ìš©ì€ í´ë¦­ ì‹œì—ë§Œ ë¡œë“œ)
// - ì´ˆê¸° ë¡œë”©ì—ì„œ ë©”ëª¨ë¥¼ ë¯¸ë¦¬ ì½ì§€ ì•ŠìŒ
// - ë§ˆì»¤ê°€ ìƒì„±/ê°±ì‹ ë  ë•Œ í•´ë‹¹ idì˜ ë©”ëª¨ ì¡´ì¬ ì—¬ë¶€ë§Œ IndexedDBì—ì„œ í™•ì¸(getKey/get)
// - ê²°ê³¼ëŠ” ìºì‹œ(Map)í•˜ì—¬ ë°˜ë³µ ì¡°íšŒ ë°©ì§€
// ================================
window.__memoPresenceCache = window.__memoPresenceCache || new Map();
window.__memoPresencePending = window.__memoPresencePending || new Map();
window.__memoDbPromise = window.__memoDbPromise || null;
function openHongbuMemoDBOnce() {
  if (window.__memoDbPromise) return window.__memoDbPromise;

  window.__memoDbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open("hongbuMemo", 4);

    // âœ… ì¶”ê°€: ì²« ìƒì„±/ì—…ê·¸ë ˆì´ë“œì‹œ ìŠ¤í† ì–´ ë³´ì¥
    req.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains("apartmentNotes")) {
        db.createObjectStore("apartmentNotes", { keyPath: "id" });
      }
    };

    req.onsuccess = (e) => {
      const db = e.target.result;

      // âœ… iOS blocked/ì—…ê·¸ë ˆì´ë“œ ëŒ€ë¹„: ë‹¤ë¥¸ íƒ­ì—ì„œ ë²„ì „ ë³€ê²½ ì‹œ ìë™ close
      db.onversionchange = () => { try { db.close(); } catch(e) {} };

      resolve(db);
    };

    req.onerror = (e) => reject(e.target.error);
  });

  return window.__memoDbPromise;
}


async function memoExistsLazy(id) {
  id = String(id);
  // âœ… ìºì‹œëœ ê²½ìš°ë¼ë„ Promiseë¡œ ë˜í•‘í•´ì„œ ë°˜í™˜ (í•­ìƒ Promise ë°˜í™˜ ë³´ì¥)
  if (window.__memoPresenceCache.has(id)) {
    return Promise.resolve(window.__memoPresenceCache.get(id));
  }

  // ğŸ’¾ ìºì‹œ í¬ê¸° ì œí•œ (500ê°œ ì´ˆê³¼ ì‹œ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°)
  if (window.__memoPresenceCache.size >= 500) {
    const firstKey = window.__memoPresenceCache.keys().next().value;
    window.__memoPresenceCache.delete(firstKey);
  }

  if (window.__memoPresencePending.has(id)) return window.__memoPresencePending.get(id);

  const p = (async () => {
    try {
      await initMemoIndexedDB();
      // âœ… ë§¤ë²ˆ ìƒˆë¡œìš´ DB ì—°ê²° ì—´ê¸° (ìºì‹œëœ ì—°ê²°ì´ ì•„ë‹Œ ë…ë¦½ì ì¸ ì—°ê²°)
      return await new Promise((resolve) => {
        const req = indexedDB.open("hongbuMemo", 4);
        req.onsuccess = (e) => {
          const db = e.target.result;
          try {
            const tx = db.transaction(["apartmentNotes"], "readonly");
            const store = tx.objectStore("apartmentNotes");

            const getReq = (store.getKey ? store.getKey(id) : store.get(id));
            getReq.onsuccess = () => {
              const exists = store.getKey ? (getReq.result !== undefined && getReq.result !== null) : !!getReq.result;
              window.__memoPresenceCache.set(id, exists);
              try { db.close(); } catch(e) {} // âœ… ìƒˆë¡œìš´ DB ì—°ê²° ë‹«ê¸°
              resolve(exists);
            };
            getReq.onerror = () => {
              // ì—ëŸ¬ë©´ ì—†ëŠ” ê²ƒìœ¼ë¡œ ì²˜ë¦¬(í‘œê¸°ë§Œ)
              window.__memoPresenceCache.set(id, false);
              try { db.close(); } catch(e) {} // âœ… ìƒˆë¡œìš´ DB ì—°ê²° ë‹«ê¸°
              resolve(false);
            };
          } catch (e) {
            window.__memoPresenceCache.set(id, false);
            try { db.close(); } catch(e) {}
            resolve(false);
          }
        };
        req.onerror = () => {
          window.__memoPresenceCache.set(id, false);
          resolve(false);
        };
      });
    } catch (e) {
      window.__memoPresenceCache.set(id, false);
      return false;
    } finally {
      window.__memoPresencePending.delete(id);
    }
  })();

  window.__memoPresencePending.set(id, p);
  return p;
}

function applyMemoIconLazy(id, markerElement) {
  try {
    id = String(id);
    if (!markerElement) return;

    // ì¤‘ë³µ ë°©ì§€
    if (markerElement.__memoIconChecked) return;
    markerElement.__memoIconChecked = true;

    memoExistsLazy(id).then((exists) => {
      if (!exists) return;

      // ì´ë¯¸ ë¶™ì–´ ìˆìœ¼ë©´ íŒ¨ìŠ¤
      if (markerElement.querySelector && markerElement.querySelector("img.__hongbu_memo_icon")) return;

      const memoIcon = document.createElement("img");
      memoIcon.className = "__hongbu_memo_icon";
      memoIcon.src = "memo.png";
      memoIcon.style = `
        position: absolute;
        top: -16px;
        left: -20px;
        width: 28px;
        height: 28px;
        z-index: 10;
        pointer-events: none;
      `;
      markerElement.style.position = "relative";
      markerElement.appendChild(memoIcon);
    });
  } catch (e) {}
}


function createDefaultMapMarker(apartment) {
		let yearValue = parseInt(apartment.year.slice(2), 10);
		let bgColor = "#FFFA00"; // yellow
		let fongColor = "white";

		if (yearValue > 50) bgColor = "#5C6267";
		else if (yearValue >= 20) bgColor = "#3E24D7";
		else if (yearValue >= 10) bgColor = "#EE1A24";

		if (yearValue >= 00 && yearValue < 10) fongColor = "black"; 

		const markerElement = document.createElement("div");
		markerElement.style = `
			background-color: ${bgColor};
			color: ${fongColor};
			border-radius: 6px;
			padding: 0px;
			border: 3px  black;  /* âœ… í…Œë‘ë¦¬ ë‘ê»˜ 2px, ê²€ì •ìƒ‰ */
			text-align: center;
			font-size: 12px;
			font-weight: bold;
			box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
			white-space: nowrap;
			display: inline-block;
		`;

		const nameElement = document.createElement("div");
		nameElement.style = `
			background: white;
			color: black;
			font-size: 12px;
			font-weight: bold;
			display: flex; /* âœ… Flexbox ì‚¬ìš© */
			align-items: center;
			justify-content: center;
			padding: 2px 5px; /* âœ… ìµœì†Œ íŒ¨ë”© ìœ ì§€ */
			border-radius: 3px;
			min-width: 85px; /* âœ… ìµœì†Œ ë„ˆë¹„ ê³ ì • */
			max-width: 85px; /* âœ… ìµœëŒ€ ë„ˆë¹„ ê³ ì • */
			overflow: hidden;
			text-overflow: ellipsis;
		`;

		const detailsElement = document.createElement("div");
		detailsElement.style = `
			font-size: 12px;
			padding: 2px 5px;
			min-width: 85px; /* âœ… ì„¸ë¶€ ì •ë³´ë„ ìµœì†Œ í¬ê¸° ë™ì¼ */
			max-width: 85px;
			display: flex;
			justify-content: center;
		`;


		nameElement.textContent = apartment.name.length > 7 ? apartment.name.slice(0, 6) + "..." : apartment.name;
		detailsElement.textContent = `${apartment.year.slice(-5)} ${apartment.units}ì„¸ëŒ€`;
    markerElement.appendChild(nameElement);
    markerElement.appendChild(detailsElement);
	




	// âœ… ë©”ëª¨ ì•„ì´ì½˜ (í‚¤ì…‹ ê¸°ë°˜ ë¹ ë¥¸ ì²´í¬: ë§ˆì»¤ë§ˆë‹¤ DB ì¡°íšŒí•˜ì§€ ì•ŠìŒ)
	(function(){
		const showMemoIcon = document.getElementById("toggleMemoIcon")?.checked;
		if (!showMemoIcon) return;
		applyMemoIconLazy(String(apartment.id), markerElement);
	})();// âœ… ë§ˆì»¤ í´ë¦­ ì‹œ ê°€ë¡œ ê¸¸ì´ í™•ì¥ â†’ 3ì´ˆ í›„ ë‹¤ì‹œ ì¶•ì†Œ
    

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: markerElement,
            anchor: new naver.maps.Point(10, 30)
        }
    });
	marker.apartmentId = apartment.id; // âœ… ë§ˆì»¤ ê°ì²´ì— ì§ì ‘ ID ì €ì¥

	naver.maps.Event.addListener(marker, "click",  function(e) {
		showApartmentInfo(apartment.id, {
			x: e.offset.x,
			y: e.offset.y
		});
	});

	addMarkerRightClickEvent(marker, markerElement); // âœ… ë§ˆì»¤ ì„ íƒ ì´ë²¤íŠ¸ ë“±ë¡

	return marker;
}


// âœ… ë°±ì§€ë„ìš© í° ë§ˆì»¤ ìƒì„± (ë°±ì§€ë„ ì²´í¬ ì‹œ) - ê³¼ê±° ìŠ¤íƒ€ì¼(ë¹ˆ í° ì‚¬ê°í˜• + ê²€ì • í…Œë‘ë¦¬)
function createWhiteMapMarker(apartment) {
    const markerElement = document.createElement("div");
    markerElement.style = `
        background: #ffffff;
        border: 2px solid #000000;
        border-radius: 6px;
        width: 85px;
        height: 20px;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    // (ì˜ë„ì ìœ¼ë¡œ í…ìŠ¤íŠ¸/ì •ë³´ëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ)
    markerElement.textContent = "";

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: markerElement,
            anchor: new naver.maps.Point(10, 30)
        }
    });
    marker.apartmentId = apartment.id; // âœ… ë§ˆì»¤ ê°ì²´ì— ì§ì ‘ ID ì €ì¥

    naver.maps.Event.addListener(marker, "click", function (e) {
        showApartmentInfo(apartment.id, {
            x: e.offset.x,
            y: e.offset.y
        });
    });

    addMarkerRightClickEvent(marker, markerElement); // âœ… ë§ˆì»¤ ì„ íƒ ì´ë²¤íŠ¸ ë“±ë¡

    return marker;
}

// âœ… ê¸°ë³¸ ë§ˆì»¤ ìƒì„± (ì‹œì„¸ì§€ë„ ì²´í¬ í•´ì œ ì‹œ)
function createDefaultMarker(apartment) {

	const useBlankMap = document.getElementById("toggleBlankMap")?.checked;
//console.log("useBlankMap : "+useBlankMap);
	if(!useBlankMap){ //ë°±ì§€ë„ ì•„ë‹ ë•Œ
		return createDefaultMapMarker(apartment)
	}else{
		return createWhiteMapMarker(apartment)
	}

}

let prevSiseMapState = null; // ğŸ”¹ ì „ì—­ ë³€ìˆ˜ë¡œ ì´ì „ ì‹œì„¸ì§€ë„ ìƒíƒœ ì €ì¥

function removeLinesOutsideBounds(bounds) {
    Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        const position = marker.getPosition();
        const line = marker.lineToOrigin;

        const isMarkerInside = bounds.hasLatLng(position);

        // ë§ˆì»¤ê°€ bounds ë°”ê¹¥ì´ë©´
        if (!isMarkerInside) {
            //console.log(`âŒ ë§ˆì»¤ ì œê±°ë¨: ${id}`);
			if(marker.movementLine){
				marker.movementLine.setMap(null);
				marker.movementLine = null;
			}
            marker.setMap(null);
            delete apartmentMarkers[id];

            // ì„ ë„ ê°™ì´ ì œê±°
            if (line) {
                //console.log(`âŒ ì„ ë„ ê°™ì´ ì œê±°ë¨: ${id}`);
                line.setMap(null);
                delete marker.lineToOrigin;
            }
        }
    });
}

function removeAllLines() {
	
     Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        const position = marker.getPosition();
        const isMarkerInside = window.map.getBounds().hasLatLng(position);

        if (isMarkerInside) {
            // ğŸ”¥ ë²”ìœ„ ì•ˆì˜ ë§ˆì»¤ì— ì—°ê²°ëœ ì´ë™ì„  ì œê±°
            if (marker.movementLine) {
                marker.movementLine.setMap(null);
                marker.movementLine = null;
                //console.log(`ğŸ§¹ ${id}ì˜ ì´ë™ì„  ì œê±°ë¨`);
            }
        }
    });
}

	// âœ… 3. ì§€ë„ ì´ë™í•  ë•Œë§ˆë‹¤ ë²”ìœ„ ë‚´ ì•„íŒŒíŠ¸ë§Œ ë§ˆì»¤ë¡œ í‘œì‹œ
function _hongbuExtractBuiltYear(apartment) {
  // ê°€ëŠ¥í•œ í•„ë“œë“¤ì—ì„œ ì—°ë„ ì¶”ì¶œ: 4ìë¦¬(19xx/20xx) ìš°ì„ , ê·¸ ë‹¤ìŒ 2ìë¦¬(00.10 ë“±)
  const candidates = [
    apartment?.builtYear, apartment?.buildYear, apartment?.year, apartment?.completionYear,
    apartment?.title, apartment?.name
  ].filter(v => v !== undefined && v !== null);

  const str = String(candidates.find(v => String(v).trim() !== "") ?? "");

  // 4ìë¦¬ ì—°ë„ ìš°ì„ 
  const m4 = str.match(/\b(19\d{2}|20\d{2})\b/);
  if (m4) return parseInt(m4[1], 10);

  // 2ìë¦¬(ì˜ˆ: 00.10, 22.03) í˜•íƒœ
  const m2 = str.match(/\b(\d{2})\s*[\.\-\/]/);
  if (m2) {
    const yy = parseInt(m2[1], 10);
    // 70~99 => 19xx, 00~69 => 20xx (í•„ìš”í•˜ë©´ ê¸°ì¤€ê°’ ì¡°ì •)
    return (yy >= 70) ? (1900 + yy) : (2000 + yy);
  }

  return null;
}

function updateMarkers(bounds) {


	const showApartments = document.getElementById("toggleApartments").checked;
		if (!showApartments) {
			Object.values(apartmentMarkers).forEach(marker => {
				if (marker instanceof naver.maps.Marker) {
					marker.setMap(null);
				}
			});
			apartmentMarkers = {}; // ìºì‹œ ì´ˆê¸°í™”
			return; // âœ… ë§ˆì»¤ ì œê±° í›„ ë” ì´ìƒ ì‘ì—…í•˜ì§€ ì•ŠìŒ
		}

// â–¼ ì¶”ê°€: í˜„ì¬ ì„ íƒëœ ì‹œë„/ì‹œêµ°êµ¬ ì½ê¸°
  const { sidoSel, sigunguSel } = getFilterEls();
  const selectedSido = (sidoSel?.value || '').trim();     // '' => ì „ì²´
  const selectedSigungu = (sigunguSel?.value || '').trim(); // '' => ì „ì²´

	//ë²”ìœ„ ë²—ì–´ë‚˜ë©´ ë§ˆì»¤ ì‚­ì œ
	removeLinesOutsideBounds(bounds)

			const minUnits = parseInt(document.getElementById("unitFilter").value, 10) || 0;
			const fromYear = parseInt(document.getElementById("yearFromFilter")?.value, 10) || null;
			const toYear = parseInt(document.getElementById("yearToFilter")?.value, 10) || null;
			//const showApartments = document.getElementById("toggleApartments").checked;
			const isSiseMapActive = document.getElementById("toggleSiseMap").checked;

			if (!showApartments || window.map.getZoom() < 14) return;

 // â–¼ ì—¬ê¸°ì„œ ì‹œë„/ì‹œêµ°êµ¬ í•„í„°ê¹Œì§€ ì ìš©
  const filtered = apartmentData.filter(apartment => {
    const inBounds = bounds.hasLatLng(new naver.maps.LatLng(apartment.lat, apartment.lng));
    const unitOK = apartment.units >= minUnits;

    const sidoOK = !selectedSido || (apartment.sido || '').trim() === selectedSido;
    const sigunguOK = !selectedSigungu || (apartment.sigungu || '').trim() === selectedSigungu;
    const builtYear = _hongbuExtractBuiltYear(apartment);
    const yearOK = (!fromYear || (builtYear && builtYear >= fromYear)) && (!toYear || (builtYear && builtYear <= toYear));
//console.log("apartment.sido : "+apartment.sido)
//console.log("apartment.sigungu : "+apartment.sigungu)
    return inBounds && unitOK && sidoOK && sigunguOK && yearOK;
  });


// âœ… í•„í„° ê²°ê³¼ì— ì—†ëŠ” ê¸°ì¡´ ë§ˆì»¤ëŠ” ì¦‰ì‹œ ì œê±°(ì—°ë„/ì„¸ëŒ€ìˆ˜/ì§€ì—­/ë²”ìœ„ ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜)
const keepIds = new Set(filtered.map(a => String(a.id)));

// ğŸ’¾ ë²”ìœ„ ë°–ì˜ ë©”ëª¨ ìºì‹œë„ ìë™ ì‚­ì œ (ë©”ëª¨ë¦¬ ìµœì í™”)
try {
  const outOfBoundsIds = Array.from(window.__memoPresenceCache.keys()).filter(id => !keepIds.has(String(id)));
  outOfBoundsIds.forEach(id => window.__memoPresenceCache.delete(id));
  if (outOfBoundsIds.length > 0) {
    hongbuDebugLog("INFO", `ğŸ§¹ ë©”ëª¨ ìºì‹œ ì •ë¦¬: ${outOfBoundsIds.length}ê°œ ì œê±° (ë²”ìœ„ ë°–)`);
  }
} catch(e) {}

Object.keys(apartmentMarkers).forEach(id => {
  if (!keepIds.has(String(id))) {
    const m = apartmentMarkers[id];
    try {
      if (m && typeof m.setMap === "function") {
        naver.maps.Event && naver.maps.Event.clearInstanceListeners && naver.maps.Event.clearInstanceListeners(m);
        m.setMap(null);
      }
    } catch (e) {}
    delete apartmentMarkers[id];
  }
});


/*
			const filtered = apartmentData.filter(apartment =>
				bounds.hasLatLng(new naver.maps.LatLng(apartment.lat, apartment.lng)) &&
				apartment.units >= minUnits
			);
 */
			const newMarkers = [];

			// âœ… ì‹œì„¸ì§€ë„ ì²´í¬ ìƒíƒœê°€ ë°”ë€ ê²½ìš° â†’ ëª¨ë“  ë§ˆì»¤ ì œê±°
			if (prevSiseMapState !== isSiseMapActive) {
				Object.values(apartmentMarkers).forEach(marker => {
					if (marker instanceof naver.maps.Marker) {
						naver.maps.Event.clearInstanceListeners(marker);
						marker.setMap(null);
					}
				});
				apartmentMarkers = {}; // ìºì‹œ ì´ˆê¸°í™”
				prevSiseMapState = isSiseMapActive; // ìƒíƒœ ê°±ì‹ 
			}

			// âœ… ìƒˆ ë§ˆì»¤ ìƒì„± or ì¬ì‚¬ìš©
			filtered.forEach(apartment => {
				if (apartment.name.includes("ë„ì‹œí˜•") || apartment.name.includes("ìƒí™œí˜•")) return;
				let marker = apartmentMarkers[apartment.id];

				if (!marker) {
					marker = isSiseMapActive
						? renderSiseMapMarker(apartment)
						: createDefaultMarker(apartment);

					marker.__siseMap = isSiseMapActive;
					apartmentMarkers[apartment.id] = marker;
				}

				newMarkers.push(marker);
			});


			if (markerCluster) {
				markerCluster.setMarkers(newMarkers);
			}



	}




let schoolMarkers = []; // âœ… ì§€ë„ì— í‘œì‹œëœ í•™êµ ë§ˆì»¤ ì €ì¥

// ================================
// âœ… í•™êµ ë°°ì •ë²”ìœ„(í´ë¦¬ê³¤) í† ê¸€ í‘œì‹œ (eliSchools.jsonì— ë¯¸ë¦¬ í¬í•¨ëœ schoolVertexLists ì‚¬ìš©)
// ================================
let activeSchoolZoneId = null;
let activeSchoolZonePolygons = [];

function clearActiveSchoolZone() {
    activeSchoolZonePolygons.forEach(p => { try { p.setMap(null); } catch (e) {} });
    activeSchoolZonePolygons = [];
    activeSchoolZoneId = null;
}

function _getSchoolZoneId(school) {
    // ë°ì´í„°ì— ë”°ë¼ í‚¤ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ ìµœëŒ€í•œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    return String(
        school?.schoolCode ??
        school?.markerId ??
        school?.id ??
        school?.schoolName ??
        ""
    );
}

function drawSchoolZoneById(schoolId) {
    const id = String(schoolId);
    const vertexLists = window.schoolZoneMap?.get(id);

    if (!vertexLists || !vertexLists.length) {
        //alert("ì´ í•™êµëŠ” ë°°ì •ë²”ìœ„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (eliSchools.jsonì— schoolVertexListsê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤)");
        return;
    }

    clearActiveSchoolZone();
    activeSchoolZoneId = id;

    const bounds = new naver.maps.LatLngBounds();

    // vertexLists: [ [ [lat,lng], ... ], ... ] (ì¡°ê°ì´ ì—¬ëŸ¬ ê°œì¼ ìˆ˜ ìˆìŒ)
    vertexLists.forEach(ring => {
        const path = (ring || []).map(([lat, lng]) => {
            const ll = new naver.maps.LatLng(lat, lng);
            bounds.extend(ll);
            return ll;
        });

        const poly = new naver.maps.Polygon({
            map: window.map,
            paths: path,
            strokeColor: "#00BC38",
            strokeOpacity: 0.9,
            strokeWeight: 2,
            fillColor: "#00BC38",
            fillOpacity: 0.15,
            clickable: false,
            zIndex: 999999
        });

        activeSchoolZonePolygons.push(poly);
    });

    // âœ… ë²”ìœ„ê°€ í™”ë©´ì— ì˜ ë³´ì´ë„ë¡ ë§ì¶”ê¸° (ì›ì¹˜ ì•Šìœ¼ë©´ ì£¼ì„ ì²˜ë¦¬)
    //window.map.fitBounds(bounds);
}

function toggleSchoolZoneBySchool(school) {
    const id = _getSchoolZoneId(school);
    if (!id) return;

    // ê°™ì€ í•™êµ ë‹¤ì‹œ í´ë¦­í•˜ë©´ ì œê±°
    if (activeSchoolZoneId === id) {
        clearActiveSchoolZone();
        return;
    }

    // ë‹¤ë¥¸ í•™êµë©´ êµì²´
    drawSchoolZoneById(id);
}
function normalizeVertexLists(v) {
  // ì´ë¯¸ ë°°ì—´ì´ë©´ ê·¸ëŒ€ë¡œ
  if (Array.isArray(v)) return v;

  // ë¬¸ìì—´ì´ë©´ JSON íŒŒì‹± ì‹œë„
  if (typeof v === "string") {
    try {
      const parsed = JSON.parse(v);
      return Array.isArray(parsed) ? parsed : [];
    } catch (e) {
      console.warn("âš ï¸ schoolVertexLists JSON.parse ì‹¤íŒ¨", e);
      return [];
    }
  }

  return [];
}

async function loadSchools() {
  try {
    // âœ… ë¶„í•  íŒŒì¼ 4ê°œ ë¡œë“œ (GitHub Pages ê°™ì€ ì •ì í˜¸ìŠ¤íŒ… ê¸°ì¤€)
    const PARTS = ["eliSchools_1.json", "eliSchools_2.json", "eliSchools_3.json", "eliSchools_4.json"];

    // âœ… íŒŒì¼ í•˜ë‚˜ë¥¼ "ë°°ì—´ or ë˜í¼({schools:[]})" ëª¨ë‘ ì§€ì›í•´ì„œ ë°°ì—´ë¡œ í†µì¼
    async function fetchAsArray(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`í•™êµ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ${url} (HTTP ${res.status})`);
      const data = await res.json().catch(() => null);

      if (Array.isArray(data)) return data;
      if (Array.isArray(data?.schools)) return data.schools;
      if (Array.isArray(data?.schoolList)) return data.schoolList;
      return [];
    }

    // âœ… 4ê°œ íŒŒì¼ ë³‘í•© (ë„¤íŠ¸ì›Œí¬ ë¶€ë‹´ ì¤„ì´ë ¤ë©´ ìˆœì°¨ ë¡œë“œ)
    const merged = [];
    for (const f of PARTS) {
      const arr = await fetchAsArray(f);
      console.log(`âœ… loaded ${f}: ${arr.length}`);
      merged.push(...arr);
    }

    // âœ… ì¤‘ë³µ ì œê±° (schoolCode/markerId ìš°ì„ )
    const uniqMap = new Map();
    for (const s of merged) {
      const id = String(s?.schoolCode ?? s?.markerId ?? s?.id ?? s?.schoolName ?? "");
      if (!id) continue;
      if (!uniqMap.has(id)) uniqMap.set(id, s);
    }
    const schools = Array.from(uniqMap.values());

    console.log(`ğŸ¯ schools merged: ${merged.length} â†’ unique: ${schools.length}`);

    // âœ… ì „ì²´ í•™êµ ë°ì´í„° ì €ì¥
    window.schoolData = schools;

    // âœ… ë°°ì •ë²”ìœ„(í´ë¦¬ê³¤) ë¹ ë¥¸ ì¡°íšŒìš© Map: id -> schoolVertexLists
    window.schoolZoneMap = new Map(
      schools.map(s => [
        String(s.schoolCode ?? s.markerId ?? s.id ?? s.schoolName ?? ""),
        normalizeVertexLists(s.schoolVertexLists)
      ])
    );

    // âœ… ì´ˆê¸° ë§ˆì»¤ ì—…ë°ì´íŠ¸
    updateSchoolMarkers(window.map.getBounds());

    // âœ… ì§€ë„ ì´ë™ ì‹œ í˜„ì¬ ë²”ìœ„ ë‚´ í•™êµ ë§ˆì»¤ ì—…ë°ì´íŠ¸
    naver.maps.Event.addListener(window.map, "idle", function () {
      updateSchoolMarkers(window.map.getBounds());
    });

    // âœ… ì§€ë„ ë¹ˆ ê³³ í´ë¦­í•˜ë©´ ë°°ì •ë²”ìœ„(í´ë¦¬ê³¤) ì œê±°
    naver.maps.Event.addListener(window.map, "click", function () {
      clearActiveSchoolZone();
    });

  } catch (error) {
    console.error("âŒ í•™êµ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
  }
}


function updateSchoolMarkers() {
    const showSchools = document.getElementById("toggleSchools").checked;

    // âœ… ê¸°ì¡´ í•™êµ ë§ˆì»¤ ì œê±°
    schoolMarkers.forEach(marker => marker.setMap(null));
    schoolMarkers = [];

    if (!showSchools) return; // ì´ˆë“±í•™êµ í‘œì‹œ ì²´í¬ í•´ì œ ì‹œ ì¢…ë£Œ
	if (window.map.getZoom() < 14) { 
			return; // âœ… ì¤Œ ë ˆë²¨ì´ 14ë³´ë‹¤ ì‘ìœ¼ë©´ ì‹¤í–‰ ì¤‘ë‹¨
	}
    let bounds = window.map.getBounds();
    let filteredSchools = window.schoolData.filter(school =>
        bounds.hasLatLng(new naver.maps.LatLng(school.latitude, school.longitude))
    );

    filteredSchools.forEach(school => {
    // âœ… ë§ˆì»¤ ì»¨í…Œì´ë„ˆë¥¼ markerElementë¡œ í™œìš©
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = "eliSchool.png";
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;
   const rawPerClass = school.studentCountPerClassroom;
const perClass = Number.isFinite(rawPerClass) ? Math.floor(rawPerClass) : "";

const total = (school.totalStudentCount ?? "");

const suffix =
  (perClass !== "" || total !== "")
    ? ` (${perClass !== "" ? perClass : "-"} / ${total !== "" ? total : "-"})`
    : "";

infoBox.textContent =
  `${(school.schoolName || "").replace(/ë“±í•™êµ/g, "")}${suffix}`;


    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(school.latitude, school.longitude),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // âœ… ìš°í´ë¦­ ì´ë²¤íŠ¸ì— markerElement ì „ë‹¬ (í…Œë‘ë¦¬ í™œì„±í™” ê°€ëŠ¥)
    addMarkerRightClickEvent(marker, markerElement);

    // âœ… ì¢Œí´ë¦­: ë°°ì •ë²”ìœ„(í´ë¦¬ê³¤) í† ê¸€
    naver.maps.Event.addListener(marker, "click", () => {
        toggleSchoolZoneBySchool(school);
    });

    schoolMarkers.push(marker);
});

}




// ================================
// âœ… ì§€ë„ ë§ˆì§€ë§‰ ìœ„ì¹˜ ì €ì¥/ë³µì› ì•ˆì •í™”
// - createMap()ìœ¼ë¡œ ì§€ë„ê°€ ì¬ìƒì„±ë˜ì–´ë„ í•­ìƒ ì €ì¥ ë¦¬ìŠ¤ë„ˆë¥¼ ìƒˆ mapì— ì¬ë°”ì¸ë”©
// - ì´ˆê¸° ë³µì› ì§í›„ ì§€ì—­í•„í„°ê°€ setCenterë¡œ ë®ì–´ì“°ëŠ” í˜„ìƒ ë°©ì§€(suppressAutoFocusRegion)
// ================================
window.__mapPosRestoredAt = 0;
window.__suppressAutoFocusRegion = true;
window.__hongbuPageSaveHooksBound = false;

function __markMapPosRestored() {
  window.__mapPosRestoredAt = Date.now();
  window.__suppressAutoFocusRegion = true;
  // ì´ˆê¸° ë¡œë”© ì¤‘(ëŒ€ëµ 5ì´ˆ) ìë™ region focusë¡œ ì„¼í„°ë¥¼ ë®ì§€ ì•Šê²Œ ë³´í˜¸
  setTimeout(() => {
    if (Date.now() - window.__mapPosRestoredAt >= 4500) {
      window.__suppressAutoFocusRegion = true;
    }
  }, 5000);
}

function setupMapPositionAutoSave(map) {
  if (!map || !window.naver || !naver.maps || !naver.maps.Event) return;

  // âœ… ê¸°ì¡´ì— ì´ í•¨ìˆ˜ê°€ ë¶™ì¸ ë¦¬ìŠ¤ë„ˆë§Œ ì œê±° (ë‹¤ë¥¸ idle ë¦¬ìŠ¤ë„ˆëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ)
  try {
    if (map.__hongbuMapPosListeners && Array.isArray(map.__hongbuMapPosListeners)) {
      map.__hongbuMapPosListeners.forEach(l => { try { naver.maps.Event.removeListener(l); } catch(e) {} });
    }
  } catch(e) {}
  map.__hongbuMapPosListeners = [];

  let __saveMapPosTimer = null;

  const __saveToLocalStorage = () => {
    try {
      const c = map.getCenter();
      const z = map.getZoom();
      localStorage.setItem("hongbu_mapPosition_fallback_v1", JSON.stringify({
        lat: c.lat(), lng: c.lng(), zoom: z, t: Date.now()
      }));
    } catch(e) {}
  };

  const __save = (delayMs = 150) => {
    if (__saveMapPosTimer) clearTimeout(__saveMapPosTimer);
    __saveMapPosTimer = setTimeout(() => {
      try {
        const c = map.getCenter();
        const z = map.getZoom();
        setHongbuSetting("mapPosition", { lat: c.lat(), lng: c.lng(), zoom: z }).catch(console.warn);
        __saveToLocalStorage();
      } catch(e) {}
    }, delayMs);
  };

  // âœ… map ì´ë²¤íŠ¸(ìƒˆ map ì¸ìŠ¤í„´ìŠ¤ë§ˆë‹¤ ì¬ë°”ì¸ë”©)
  map.__hongbuMapPosListeners.push(naver.maps.Event.addListener(map, "idle", () => __save(150)));
  map.__hongbuMapPosListeners.push(naver.maps.Event.addListener(map, "zoom_changed", () => __save(0)));
  map.__hongbuMapPosListeners.push(naver.maps.Event.addListener(map, "dragend", () => __save(0)));

  // âœ… íƒ­ì´ ì£½ê¸° ì§ì „/ë°±ê·¸ë¼ìš´ë“œ ì „í™˜ ì§ì „ í•œ ë²ˆ ë” ì €ì¥(ì „ì—­ 1íšŒë§Œ ë°”ì¸ë”©)
  if (!window.__hongbuPageSaveHooksBound) {
    window.__hongbuPageSaveHooksBound = true;
    const saveCurrentNow = () => {
      try {
        const m = window.map;
        if (!m) return;
        const c = m.getCenter();
        const z = m.getZoom();
        setHongbuSetting("mapPosition", { lat: c.lat(), lng: c.lng(), zoom: z }).catch(console.warn);
        localStorage.setItem("hongbu_mapPosition_fallback_v1", JSON.stringify({
          lat: c.lat(), lng: c.lng(), zoom: z, t: Date.now()
        }));
      } catch(e) {}
    };
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") saveCurrentNow();
    });
    window.addEventListener("pagehide", saveCurrentNow);
    window.addEventListener("beforeunload", saveCurrentNow);
  }
}

function isKakaoInAppBrowser() {
    return /KAKAOTALK/i.test(navigator.userAgent);
}



// âœ… í˜ì´ì§€ ë¡œë“œ ì‹œ ì‹¤í–‰
document.addEventListener("DOMContentLoaded", async () => {
	

    if (isKakaoInAppBrowser()) {
        alert("âš ï¸ ì¹´ì¹´ì˜¤í†¡ ì¸ì•± ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.\n\ní™ë¶€ ì €ì¥ ê¸°ëŠ¥ì´ ì •ìƒ ë™ì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\ní¬ë¡¬, ì›¨ì¼, ì‚¼ì„±ì¸í„°ë„· ë“± ì™¸ë¶€ ë¸Œë¼ìš°ì €ë¡œ ì—´ì–´ì£¼ì„¸ìš”.");
    }

await initIndexedDB();

    // âœ… ì €ì¥ëœ UI ì˜µì…˜ ë³µì› + ìë™ ì €ì¥ ì„¤ì •
    await restoreUIStateFromDB();
    initUIStateAutoSave();


		const useBlank = document.getElementById("toggleBlankMap")?.checked;
		await createMap(useBlank);
		injectMaximizeButton(); // ì§€ë„ ë‚´ë¶€ ìš°ìƒë‹¨ ìµœëŒ€í™” ë²„íŠ¼ ì£¼ì…

		// âœ… ìƒˆë¡œê³ ì¹¨/ìƒíƒœë³µì›ìœ¼ë¡œ ì§€ì í¸ì§‘ë„ ì²´í¬ê°€ ì´ë¯¸ ì¼œì ¸ìˆìœ¼ë©´, ì§€ë„ ìƒì„± í›„ ë ˆì´ì–´ë¥¼ ë‹¤ì‹œ ì˜¬ë¦¼
		// (ë¸Œë¼ìš°ì €ì˜ í¼ ìƒíƒœ ë³µì›ì€ change ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•Šê¸° ë•Œë¬¸)
		{
		  const blankEl = document.getElementById("toggleBlankMap");
		  const cadastralEl = document.getElementById("toggleCadastralMap");
		  const wantCadastral = !!cadastralEl?.checked;
		  if (wantCadastral) {
		    // ìƒí˜¸ë°°íƒ€ ë³´ì¥: ë°±ì§€ë„ì™€ ë™ì‹œì— ì¼œì ¸ ìˆìœ¼ë©´ ê¸°ë³¸ì§€ë„ ì¬ìƒì„± í›„ ë ˆì´ì–´ ì ìš©
		    if (blankEl?.checked) {
		      blankEl.checked = false;
		      await createMap(false);
		      injectMaximizeButton();
		    }
		    __setCadastralLayer(true);
		  } else {
		    __setCadastralLayer(false);
		  }
		}



		// âœ… `MapHandler` í´ë˜ìŠ¤ ìƒì„± í›„ ì§€ë„ ê°ì²´ì™€ ì—°ê²°
		//new MapHandler(window.map);

		// âœ… ì•„íŒŒíŠ¸ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
		

		// âœ… ì§€ë„ ì´ë™ ì‹œ í˜„ì¬ ë²”ìœ„ ë‚´ ì•„íŒŒíŠ¸ ë§ˆì»¤ ì—…ë°ì´íŠ¸
		// âœ… ì§€ë„ ìœ„ì¹˜(ì„¼í„°/ì¤Œ) ì €ì¥ì€ createMap() ë‚´ë¶€ì—ì„œ í˜„ì¬ map ì¸ìŠ¤í„´ìŠ¤ì— ë°”ì¸ë”©ë¨ (setupMapPositionAutoSave)

		console.log("âœ… ë„¤ì´ë²„ ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ.");



// âœ… 0) ë©”ëª¨ DB + ë©”ëª¨ ì¡´ì¬ í‚¤ì…‹ì„ ê°€ì¥ ë¨¼ì € ì¤€ë¹„ (ì•„íŒŒíŠ¸ ë§ˆì»¤/ë©”ëª¨ ì•„ì´ì½˜ì´ ìµœìš°ì„ )
	await initMemoIndexedDB();
	await loadMemoKeySetOnce();

	// âœ… 1) ì•„íŒŒíŠ¸(ë§ˆì»¤) ë¨¼ì € ë¡œë“œ
	await loadApartments();

	// âœ… 2) ë‚˜ë¨¸ì§€ëŠ” ë³‘ë ¬ ë¡œë“œ (ì´ˆ/ì¤‘/í™˜ê²½/ìŠ¤ë²…/ìƒì„¸/ê¸¸ì°¾ê¸° ë“±)
	Promise.allSettled([
		loadApartmentsDetail(),
		loadSchools(),
		loadMiddleSchools(),
		loadFacilities(),
		loadStarbucks(),
		findWay(),
	]).then((results) => {
		const ok = results.filter(r => r.status === "fulfilled").length;
		const fail = results.filter(r => r.status === "rejected").length;
		console.log(`âœ… ë°±ê·¸ë¼ìš´ë“œ ë¡œë”© ì™„ë£Œ: ok=${ok}, fail=${fail}`);
	}).catch(console.warn);
if (window.map) {
        setupRightClickEvent();
    } else {
        // âœ… ì§€ë„ ë¡œë“œ í›„ ì´ë²¤íŠ¸ë¥¼ ì¶”ê°€í•˜ëŠ” ë°©ì‹
        const checkMapLoaded = setInterval(() => {
            if (window.map) {
                clearInterval(checkMapLoaded);
                setupRightClickEvent();
            }
        }, 100); // ğŸ”¹ 100ms ê°„ê²©ìœ¼ë¡œ ì§€ë„ ë¡œë“œ í™•ì¸
    }


    const metaViewport = document.querySelector("meta[name='viewport']");


    function updateViewportScale(scale) {
		const metaViewport = document.querySelector("meta[name='viewport']");
		currentScale = Math.max(0.5, Math.min(1.5, scale)); // âœ… ìµœì†Œ 0.5 ~ ìµœëŒ€ 1.5 ì œí•œ
		metaViewport.setAttribute("content", `width=device-width, initial-scale=${currentScale}, user-scalable=no`);

		//console.log("ğŸ“Œ ìƒˆë¡œìš´ Viewport Scale:", currentScale);

		// âœ… ê°•ì œë¡œ í™”ë©´ í™•ëŒ€/ì¶•ì†Œ íš¨ê³¼ ì ìš©
		document.documentElement.style.zoom = 1; // **Reflow**
		document.documentElement.style.zoom = currentScale; // **ì¦‰ì‹œ ë°˜ì˜**

		// âœ… ê°€ë¡œ ìŠ¤í¬ë¡¤ ë°©ì§€ (zoom ë³€ê²½ í›„ body, html í¬ê¸° ì¡°ì •)
		document.documentElement.style.overflow = "hidden";
		document.body.style.overflow = "hidden";
		document.body.style.width = "100%"; // **ğŸ“Œ ê°•ì œ ì¡°ì •í•˜ì—¬ ê°€ë¡œ ìŠ¤í¬ë¡¤ ì œê±°**

		// âœ… ì§€ë„ í¬ê¸° ê°•ì œ ì—…ë°ì´íŠ¸ (idle ì´ë²¤íŠ¸ ë°œìƒ ìœ ë„)
		if (window.map) {
			setTimeout(() => {
				let mapElement = document.getElementById("map");
				let width = mapElement.clientWidth;
				let height = mapElement.clientHeight;
				window.map.setSize(new naver.maps.Size(width, height));
				//console.log("ğŸ”„ ì§€ë„ í¬ê¸° ë³€ê²½ë¨:", width, height);
			}, 200); // âœ… ë¸Œë¼ìš°ì € ë¦¬í”Œë¡œìš° í›„ ì‹¤í–‰
		}
	}

//ì´ë™ì‹œ ì„  ê¸‹ê¸°
naver.maps.Event.addListener(window.map, "click", function(e) {
    if (activeMarker && activeMarker instanceof naver.maps.Marker) {
        const newPosition = e.coord;

        const origin = activeMarker.originPosition;
        if (origin) {
            // ğŸ”´ ì´ì „ ì„ ì´ ìˆë‹¤ë©´ ì§€ë„ì—ì„œ ì œê±°
            if (activeMarker.movementLine) {
                activeMarker.movementLine.setMap(null);
            }

            // ğŸ”µ ìƒˆ ì„  ìƒì„± ë° ë§ˆì»¤ì— ì €ì¥
            const line = new naver.maps.Polyline({
                map: window.map,
                path: [origin, newPosition],
                strokeColor: "#000000",
                strokeOpacity: 0.8,
                strokeWeight: 2
            });

            activeMarker.movementLine = line;
        }

        activeMarker.setPosition(newPosition);
        //console.log("ğŸ“Œ ë§ˆì»¤ ì´ë™ë¨:", newPosition.toString());
    }
});




});

document.getElementById("toggleApartments").addEventListener("change", () => {
    updateMarkers(window.map.getBounds()); // âœ… ì¦‰ì‹œ ì—…ë°ì´íŠ¸
});


document.getElementById("toggleMemoIcon").addEventListener("change", () => {
Object.values(apartmentMarkers).forEach(marker => {
        if (marker instanceof naver.maps.Marker) {
            marker.setMap(null);
        }
    });
    apartmentMarkers = {}; // âœ… ë§ˆì»¤ ìºì‹œë„ ì´ˆê¸°í™”

    // âœ… ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    
    updateMarkers(window.map.getBounds()); // âœ… ì¦‰ì‹œ ì—…ë°ì´íŠ¸
});


document.getElementById("toggleSchools").addEventListener("change", () => {
    updateSchoolMarkers(); // âœ… ì¦‰ì‹œ ì—…ë°ì´íŠ¸
});

// âœ… ë²•ì •ë™ê²½ê³„ í† ê¸€
const toggleEmdBoundaryEl = document.getElementById("toggleEmdBoundary");
if (toggleEmdBoundaryEl) {
  toggleEmdBoundaryEl.addEventListener("change", () => {
    // ì²´í¬/í•´ì œ ì¦‰ì‹œ ë°˜ì˜
    scheduleEmdRedraw();
  });
}

// âœ… í–‰ì •ë™ê²½ê³„ í† ê¸€
const toggleAdminBoundaryEl = document.getElementById("toggleAdminBoundary");
if (toggleAdminBoundaryEl) {
  toggleAdminBoundaryEl.addEventListener("change", () => {
    scheduleAdmRedraw();
  });
}

// âœ… ìµœì†Œ ì„¸ëŒ€ìˆ˜(unitFilter) ë³€ê²½ ì‹œ ì§€ë„ ì¦‰ì‹œ ë°˜ì˜
const unitFilterInput = document.getElementById("unitFilter");
let unitFilterTimer = null;

["input", "change"].forEach(evt => {
    unitFilterInput.addEventListener(evt, () => {
        if (!window.map) return;

        // ì…ë ¥ ì¤‘ ê³¼ë„í•œ í˜¸ì¶œì„ ë§‰ê¸° ìœ„í•œ ì•½ê°„ì˜ ë”œë ˆì´(0.2ì´ˆ)
        if (unitFilterTimer) clearTimeout(unitFilterTimer);
        unitFilterTimer = setTimeout(() => {
		Object.values(apartmentMarkers).forEach(marker => {
			if (marker instanceof naver.maps.Marker) {
				marker.setMap(null);
			}
		});
		apartmentMarkers = {}; // âœ… ë§ˆì»¤ ìºì‹œë„ ì´ˆê¸°í™”
				updateMarkers(window.map.getBounds());
			}, 200);
		});
});

// âœ… ì¤€ê³µë…„ë„(yearFromFilter/yearToFilter) ë³€ê²½ ì‹œ ì§€ë„ ì¦‰ì‹œ ë°˜ì˜
const yearFromFilterInput = document.getElementById("yearFromFilter");
const yearToFilterInput = document.getElementById("yearToFilter");
let yearFilterTimer = null;


function clearApartmentMarkersAndCluster() {
  const markers = window.apartmentMarkers || {};

  // 1) ì§€ë„ì—ì„œ ë§ˆì»¤ ì œê±°
  Object.values(markers).forEach(m => {
    try {
      if (m && typeof m.setMap === "function") m.setMap(null);
    } catch (e) {}
  });

  // 2) í´ëŸ¬ìŠ¤í„°/ì˜¤ë²„ë ˆì´ ëª©ë¡ë„ ë¹„ì›€ (ìˆì„ ë•Œë§Œ)
  try {
    if (window.markerCluster && typeof window.markerCluster.setMarkers === "function") {
      window.markerCluster.setMarkers([]);
    }
  } catch (e) {}

  // 3) ìºì‹œ ê°ì²´ ì´ˆê¸°í™”(ì¤‘ìš”: windowì— ë¶™ì€ ê±¸ ë°”ê¿”ì•¼ í•¨)
  window.apartmentMarkers = {};
}

function _applyYearFilterUpdate() {
  if (!window.map) return;

  // âœ… í•„í„° ë°˜ì˜ ìœ„í•´ ìºì‹œ ì‹¹ ì´ˆê¸°í™”
  clearApartmentMarkersAndCluster();

  // boundsê°€ ì—†ìœ¼ë©´ í˜„ì¬ ì§€ë„ bounds ì‚¬ìš©
  const b = window.map.getBounds ? window.map.getBounds() : null;
  updateMarkers(b);
}

["input", "change"].forEach(evt => {
  yearFromFilterInput?.addEventListener(evt, () => {
    if (yearFilterTimer) clearTimeout(yearFilterTimer);
    yearFilterTimer = setTimeout(_applyYearFilterUpdate, 200);
  });

  yearToFilterInput?.addEventListener(evt, () => {
    if (yearFilterTimer) clearTimeout(yearFilterTimer);
    yearFilterTimer = setTimeout(_applyYearFilterUpdate, 200);
  });
});



let observer = new ResizeObserver(() => {
    if (window.map) {
        let mapElement = document.getElementById("map");
        //let width = mapElement.clientWidth;
        //let height = mapElement.clientHeight;
        //window.map.setSize(new naver.maps.Size(width, height)); // ì§€ë„ í¬ê¸° ì—…ë°ì´íŠ¸
		//console.log("ì§€ë„ ë³€í•¨");
    }
});

// `#map` ìš”ì†Œì˜ í¬ê¸° ë³€í™”ë¥¼ ê°ì§€í•˜ì—¬ ìë™ ì—…ë°ì´íŠ¸
observer.observe(document.getElementById("map"));

let isFullscreen = false; // í˜„ì¬ ì „ì²´ í™”ë©´ ì—¬ë¶€ ì €ì¥
let originalHeight = document.getElementById("map").style.height; // ê¸°ì¡´ ì§€ë„ ë†’ì´ ì €ì¥
function toggleFullscreen() {
  const mapEl = document.getElementById('map');
  if (!mapEl) return;

  const willFull = !mapEl.classList.contains('fullscreen');
  mapEl.classList.toggle('fullscreen', willFull);
  document.body.classList.toggle('map-fullscreen', willFull);
}






let apartmentDetailData = {};

// JSON ë°ì´í„° ë¡œë“œ
async function loadApartmentsDetail() {
  try {
    // ë§¤ í˜¸ì¶œë§ˆë‹¤ ë‹¤ë¥¸ ì¿¼ë¦¬ìŠ¤íŠ¸ë§ìœ¼ë¡œ ìºì‹œ ìš°íšŒ
    const ts = Date.now();

    // ë‘ JSONì„ ìºì‹œ ì—†ì´ ë³‘ë ¬ ë¡œë“œ
    const [res1, res2] = await Promise.all([
      fetch(`apartments1.json?t=${ts}`, { cache: "no-store" }),
      fetch(`apartments2.json?t=${ts}`, { cache: "no-store" })
    ]);

    if (!res1.ok || !res2.ok) {
      throw new Error(`fetch failed: ${res1.status}/${res2.status}`);
    }

    const [json1, json2] = await Promise.all([res1.json(), res2.json()]);

    // ë³‘í•©
    apartmentDetailData = Object.assign({}, json1, json2);

    // ë§ˆì»¤ ê°±ì‹ 
    if (window.map && window.map.getBounds) {
      updateMarkers(window.map.getBounds());
    }
  } catch (error) {
    console.error("âŒ ì•„íŒŒíŠ¸ ìƒì„¸ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", error);
  }
}

// ë§¨ ìœ„ ì „ì—­ì— ì¶”ê°€
const aptMemoImageList = {};

   // ë§ˆì»¤ í´ë¦­ ì‹œ ì •ë³´ í‘œì‹œ
// ë§ˆì»¤ í´ë¦­ ì‹œ ì •ë³´ í‘œì‹œ

async function compressImage(base64, maxSize = 600, quality = 0.8) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement("canvas");
            let [w, h] = [img.width, img.height];
            if (w > h && w > maxSize) {
                h *= maxSize / w;
                w = maxSize;
            } else if (h >= w && h > maxSize) {
                w *= maxSize / h;
                h = maxSize;
            }
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);
            const compressedBase64 = canvas.toDataURL("image/jpeg", quality);
            resolve(compressedBase64);
        };
        img.src = base64;
    });
}



 function showApartmentInfo(apartmentId, markerPosition) {
  event?.stopPropagation();
  if (document.getElementById("toggleSiseMap").checked) return;

  apartmentId = String(apartmentId);
  
  // âœ… ë©”ëª¨/ì´ë¯¸ì§€ ë©”ëª¨ë¦¬ í­ì¦ ë°©ì§€: í˜„ì¬ ì„ íƒëœ ì•„íŒŒíŠ¸ 1ê°œë§Œ ìºì‹œ ìœ ì§€
  __currentMemoAptId = apartmentId;
  __memoKeepOnly(apartmentId);
// âœ… ì•„íŒŒíŠ¸ ìƒì„¸(apartments1/2.json)ëŠ” ëŠë¦´ ìˆ˜ ìˆìŒ: ì—†ìœ¼ë©´ ë©”ëª¨ UIë§Œ ë¨¼ì € ì—´ê³ , ìƒì„¸ëŠ” ë¡œë”© í›„ ê°±ì‹ 
  const hasDetail = !!apartmentDetailData[apartmentId];
  // ìƒì„¸ ë¡œë”©ì´ ëë‚˜ë©´, í˜„ì¬ ì—´ë ¤ìˆëŠ” íŒì—…ì´ë©´ ìë™ ê°±ì‹ 
  if (!hasDetail && window.__aptDetailPromise) {
    window.__aptDetailPromise.then(() => {
      try {
        const curId = document.getElementById('apartmentInfo')?.getAttribute('data-id');
        if (String(curId) === String(apartmentId) && apartmentDetailData[apartmentId]) {
          showApartmentInfo(apartmentId, markerPosition);
        }
      } catch(e) {}
    });
  }

  let aptInfo = apartmentData.find(apartment => String(apartment.id) === apartmentId);

  let apt = hasDetail ? apartmentDetailData[apartmentId] : {
    ì•„íŒŒíŠ¸ëª…: aptInfo?.name || `ì•„íŒŒíŠ¸ ${apartmentId}`,
    ì…ì£¼ì‹œê¸°: aptInfo?.year ? String(aptInfo.year) : "ë¡œë”©ì¤‘â€¦",
    ì´ì„¸ëŒ€ìˆ˜: aptInfo?.units ?? "ë¡œë”©ì¤‘â€¦",
    íƒ€ì…ì •ë³´: []
  };

  // ìƒì„¸ê°€ ì•„ì§ ì—†ìœ¼ë©´, ë¡œë”©ì¤‘ ì•ˆë‚´(ë©”ëª¨ëŠ” ë°”ë¡œ ë³´ì—¬ì¤Œ)

    let leaseInfo = aptInfo ? aptInfo.lease : "ì •ë³´ ì—†ìŒ";
  let typeInfo = apt.íƒ€ì…ì •ë³´ || [];

apartmentInfo.setAttribute("data-id", apartmentId);


  let infoHtml = `
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h3 style="margin: 0; text-align: left;">${apt.ì•„íŒŒíŠ¸ëª…}</h3>
      <button onclick="openNaverRealEstate(${apartmentId})" 
        style="padding: 8px; background: #4A90E2; color: white; border: none; border-radius: 4px; cursor: pointer;">
        ë„¤ë¶€ ë°”ë¡œê°€ê¸°
      </button>
    </div>
			${hasDetail ? "" : `<div style="margin-top:8px; padding:6px 8px; background:#fff3cd; color:#664d03; border:1px solid #ffecb5; border-radius:6px; font-size:13px;">
				ìƒì„¸ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦ (ë©”ëª¨ëŠ” ë¨¼ì € í‘œì‹œë©ë‹ˆë‹¤)
			</div>`}
    <p>ì…ì£¼ì‹œê¸°: ${apt.ì…ì£¼ì‹œê¸°}</p>
    <p>ì´ì„¸ëŒ€ìˆ˜: ${apt.ì´ì„¸ëŒ€ìˆ˜} (ì„ëŒ€ : ${leaseInfo})</p>
    <table style="width: 100%; border-collapse: collapse;">
      <tr>
        <th>ê³µê¸‰í‰ìˆ˜</th>
        <th>ê³µê¸‰ã¡</th>
        <th>ì „ìš©ã¡</th>
        <th>êµ¬ì¡°</th>
        <th>ë°©</th>
        <th>í™”</th>
        <th>íƒ€ì…</th>
        <th>ì„¸ëŒ€ìˆ˜</th>
      </tr>`;

  typeInfo.forEach(type => {
    infoHtml += `
      <tr>
        <td>${type["ê³µê¸‰í‰ìˆ˜"]}</td>
        <td>${type["ê³µê¸‰ë©´ì "]}</td>
        <td>${type["ì „ìš©ë©´ì "]}</td>
        <td>${type["êµ¬ì¡°"]}</td>
        <td>${type["ë°© ê°¯ìˆ˜"]}</td>
        <td>${type["í™”ì¥ì‹¤ ê°¯ìˆ˜"]}</td>
        <td>${type["íƒ€ì…"]}</td>
        <td>${type["í‰í˜• ì„¸ëŒ€ìˆ˜"]}</td>
      </tr>`;
  });

  infoHtml += `
    </table>
    <div style="margin-top: 20px;">
      <label>ë©”ëª¨:</label>
      <textarea id="noteText" rows="5" style="width: 100%; box-sizing: border-box;"></textarea>
      <div id="imagePreview" style="margin-top: 10px; display: none; flex-wrap: wrap; gap: 8px;"></div>
      <div style="display: flex; gap: 15px; align-items: center; margin-top: 10px;">

        <label style="cursor: pointer; background: white; color: black; padding: 8px 4px; border-radius: 4px;">
          ğŸ“· ì‚¬ì§„ ì°ê¸°
          <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display: none;" />
        </label>

        <label style="cursor: pointer; background: white; color: black; padding: 8px 4px; border-radius: 4px;">
          ğŸ“ íŒŒì¼ ì„ íƒ
          <input type="file" id="imageInput" accept="image/*" multiple style="display: none;" />
        </label>
<!-- 
        <label style="cursor: pointer; background: white; color: black; padding: 8px 6px; border-radius: 4px;">
          ğŸ’¾ ì €ì¥
          <button onclick="saveNote('${apartmentId}')" style="display: none;"></button>
        </label> -->

		<label style="cursor: pointer; background: white; color: black; padding: 8px 5px; border-radius: 4px;">
		  ğŸ—‘ ì´ˆê¸°í™”
		  <button onclick="deleteNote('${apartmentId}')" style="display: none;"></button>
		</label>
      </div>
    </div>`;

  const infoDiv = document.getElementById("apartmentInfo");
  if (!infoDiv.dataset.positioned) {
    infoDiv.style.top = "50%";
    infoDiv.style.left = "50%";
    infoDiv.style.transform = "translate(-50%, -50%)";
    infoDiv.dataset.positioned = "true";
  }


  infoDiv.innerHTML = infoHtml;
 infoDiv.style.display = "block";

const cs = window.getComputedStyle(infoDiv);
console.log("[DBG] apartmentInfo z-index:", cs.zIndex, "display:", cs.display, "position:", cs.position);


  loadNote(apartmentId);

  setTimeout(() => { 
    const imageInput = document.getElementById("imageInput");
    const cameraInput = document.getElementById("cameraInput");
    const preview = document.getElementById("imagePreview");

    const handleImageFiles = (files) => {
      if (!files.length) return;
      preview.style.display = "flex";
      for (const file of files) {
        const reader = new FileReader();
        reader.onload = async function (event) {

          const originalDataUrl = event.target.result;

          // âœ… DataURL ì €ì¥ ë°©ì‹ì€ ê·¸ëŒ€ë¡œ ë‘ê³ , ì €ì¥ ì§ì „ì— ë¦¬ì‚¬ì´ì¦ˆ/ì¬ì••ì¶•í•˜ì—¬ ìš©ëŸ‰ë§Œ ì¤„ì„
          let imageDataUrl = originalDataUrl;
          try {
            // ê¸´ ë³€ 1600px ì œí•œ + JPEG í’ˆì§ˆ 0.82 (ì›í•˜ë©´ ê°’ ì¡°ì • ê°€ëŠ¥)
            imageDataUrl = await compressImage(originalDataUrl, 1600, 0.82);
          } catch (err) {
            console.warn("ì´ë¯¸ì§€ ì••ì¶• ì‹¤íŒ¨. ì›ë³¸ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.", err);
            imageDataUrl = originalDataUrl;
          }

          if (!aptMemoImageList[apartmentId]) {
            aptMemoImageList[apartmentId] = [];
          }
          aptMemoImageList[apartmentId].push(imageDataUrl);


/*
const originalBase64 = event.target.result;

  // âœ… ì••ì¶•
  const compressedBase64 = await compressImage(originalBase64, 600, 1.0);

  if (!aptMemoImageList[apartmentId]) {
    aptMemoImageList[apartmentId] = [];
  }
  aptMemoImageList[apartmentId].push(compressedBase64);
*/
          const wrapper = document.createElement("div");
          wrapper.style.position = "relative";
          wrapper.style.display = "inline-block";
          wrapper.style.marginRight = "6px";
          wrapper.style.width = "60px";
          wrapper.style.height = "60px";

          const canvas = document.createElement("canvas");
          canvas.width = 60;
          canvas.height = 60;
          canvas.style.border = "1px solid #ccc";
          canvas.style.borderRadius = "4px";
          canvas.style.cursor = "pointer";
          canvas.title = "ë¯¸ë¦¬ë³´ê¸°";

          const ctx = canvas.getContext("2d");
          const img = new Image();
          img.onload = () => ctx.drawImage(img, 0, 0, 60, 60);
          img.src = imageDataUrl;

          canvas.onclick = (e) => {
            e.stopPropagation();
            const modal = document.getElementById("imageModal");
            const modalCanvas = document.getElementById("modalCanvas");
            const modalCtx = modalCanvas.getContext("2d");
            
  __clearModalCanvas();
const previewImg = new Image();
            previewImg.onload = () => {
              modalCanvas.width = previewImg.width;
              modalCanvas.height = previewImg.height;
              modalCtx.drawImage(previewImg, 0, 0);
              modal.style.display = "flex";
              window.imageModalShowYn = true;
            };
            previewImg.src = imageDataUrl;
			window.lastOpenedBase64 = imageDataUrl;
          };

          const deleteBtn = document.createElement("div");
          deleteBtn.textContent = "âœ•";
          deleteBtn.style.position = "absolute";
          deleteBtn.style.top = "2px";
          deleteBtn.style.right = "2px";
          deleteBtn.style.background = "rgba(0,0,0,0.6)";
          deleteBtn.style.color = "white";
          deleteBtn.style.borderRadius = "50%";
          deleteBtn.style.width = "16px";
          deleteBtn.style.height = "16px";
          deleteBtn.style.display = "flex";
          deleteBtn.style.alignItems = "center";
          deleteBtn.style.justifyContent = "center";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.fontSize = "12px";

          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm("ì‚¬ì§„ì„ ì‚­ì œí•©ë‹ˆë‹¤")) {
              aptMemoImageList[apartmentId] = aptMemoImageList[apartmentId].filter(img => img !== imageDataUrl);
              wrapper.remove();
              if (preview.children.length === 0) {
                preview.style.display = "none";
              }
            }
          };

          wrapper.appendChild(canvas);
          wrapper.appendChild(deleteBtn);
          preview.appendChild(wrapper);
        };
        reader.readAsDataURL(file);
      }
    };

    if (imageInput) {
      imageInput.addEventListener("change", (e) => {
        handleImageFiles(e.target.files);
        e.target.value = "";
      });
    }

    if (cameraInput) {
      cameraInput.addEventListener("change", (e) => {
        handleImageFiles(e.target.files);
        e.target.value = "";
      });
    }
  }, 0);

showSiseVer2DataToggle(apartmentId);

}






// âœ… ë„¤ì´ë²„ ë¶€ë™ì‚° ë§í¬ ì—´ê¸° í•¨ìˆ˜ ì¶”ê°€
	function openNaverRealEstate(apartmentId) {
		let url = `https://new.land.naver.com/complexes/${apartmentId}`;
		window.open(url, "_blank");
	}


document.addEventListener("click", (event) => {
    const apartmentInfo = document.getElementById("apartmentInfo");
    const imageModal = document.getElementById("imageModal");

    // apartmentInfoê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ë¦¬í„´
    if (!apartmentInfo) return;

    setTimeout(() => {
        // ğŸ”’ ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ë‹«ì§€ ì•ŠìŒ

        if (window.imageModalShowYn === true) { return; }

        // apartmentInfo ë‚´ë¶€ í´ë¦­ì´ë©´ ë‹«ì§€ ì•ŠìŒ
        if (apartmentInfo.contains(event.target)) return;

        // ê·¸ ì™¸ì—” ë‹«ê¸°
        if (apartmentInfo.style.display === "block") {
//console.log("ì‹¤í–‰ë¨");

 const apartmentInfo = document.getElementById("apartmentInfo");
 const id = apartmentInfo.getAttribute("data-id");
      const memo = document.getElementById("noteText")?.value?.trim();
      const images = aptMemoImageList?.[id] ?? [];
console.log(id);
console.log(memo);
console.log(images);
      //if ((memo && memo !== "") || images.length > 0) {
        saveNote(id); // âœ… ìë™ ì €ì¥
      //}




            apartmentInfo.style.display = "none";
            // âœ… ë©”ëª¨ íŒì—… ë‹«í ë•Œ í° ë°ì´í„° ì°¸ì¡° í•´ì œ
            try { closeImageModal(); } catch(e){}
            try { if (__currentMemoAptId) { __memoKeepOnly(__currentMemoAptId); } } catch(e){}
            try { if (window.aptMemoImageList) { window.aptMemoImageList = {}; } } catch(e){}
            try { __currentMemoAptId = null; } catch(e){}

        }
    }, 0);
});



document.getElementById("apartmentInfo").addEventListener("touchstart", function(event) {
    const infoDiv = event.currentTarget;
    infoDiv.dataset.startY = event.touches[0].clientY;
    infoDiv.dataset.startScrollTop = infoDiv.scrollTop;
}, { passive: false });

document.getElementById("apartmentInfo").addEventListener("touchmove", function(event) {
    const infoDiv = event.currentTarget;
    
    // ë‚´ë¶€ ìŠ¤í¬ë¡¤ì´ ê°€ëŠ¥í•œ ê²½ìš°
    if (infoDiv.scrollHeight > infoDiv.clientHeight) {
        let startY = parseFloat(infoDiv.dataset.startY);
        let startScrollTop = parseFloat(infoDiv.dataset.startScrollTop);
        let currentY = event.touches[0].clientY;
        let scrollDiff = startScrollTop + (startY - currentY);

        // âœ… ìµœìƒë‹¨ì—ì„œ ì•„ë˜ë¡œ ë‹¹ê¸°ë ¤ê³  í•  ë•Œ
        if (infoDiv.scrollTop <= 0 && scrollDiff < 0) {
            event.preventDefault();
        }
        
         // âœ… ìµœí•˜ë‹¨ì—ì„œ ìœ„ë¡œ ìŠ¤í¬ë¡¤í•  ë•Œ ì œí•œì„ í•´ì œ
		if (infoDiv.dataset.atBottom === "true" && scrollDiff > 0) {
			event.preventDefault();
			infoDiv.scrollTop = infoDiv.scrollHeight - infoDiv.clientHeight - 1; // âœ… ìŠ¤í¬ë¡¤ì„ ì¡°ì •í•˜ì—¬ ì •ìƒ ì‘ë™
		}

    } else {
        // âœ… ë‚´ë¶€ ìŠ¤í¬ë¡¤ì´ ì—†ëŠ” ê²½ìš° ë°”ë”” ìŠ¤í¬ë¡¤ ì°¨ë‹¨
        event.preventDefault();
    }
}, { passive: false });

document.addEventListener("touchmove", function(event) {
    const infoDiv = document.getElementById("apartmentInfo");

    if (infoDiv.style.display === "block") {
        if (infoDiv.scrollHeight <= infoDiv.clientHeight) {
            event.preventDefault(); // ë‚´ë¶€ ìŠ¤í¬ë¡¤ì´ ì—†ìœ¼ë©´ ë°”ë”” ìŠ¤í¬ë¡¤ ë§‰ê¸°
        }
    }
}, { passive: false });

let middleSchoolMarkers = []; // âœ… ì§€ë„ì— í‘œì‹œëœ ì¤‘í•™êµ ë§ˆì»¤ ì €ì¥
/*
async function loadMiddleSchools() {
    try {
        const response = await fetch("middleSchools.json");
        const middleSchools = await response.json();
        
        console.log("âœ… ì¤‘í•™êµ ë°ì´í„° ë¡œë“œ ì™„ë£Œ", middleSchools);

        window.middleSchoolData = middleSchools; // âœ… ì „ì²´ ì¤‘í•™êµ ë°ì´í„° ì €ì¥

        // âœ… ì´ˆê¸° ë§ˆì»¤ ì—…ë°ì´íŠ¸
        updateMiddleSchoolMarkers(window.map.getBounds());

        // âœ… ì§€ë„ ì´ë™ ì‹œ í˜„ì¬ ë²”ìœ„ ë‚´ ì¤‘í•™êµ ë§ˆì»¤ ì—…ë°ì´íŠ¸
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateMiddleSchoolMarkers(bounds);
        });

    } catch (error) {
        console.error("âŒ ì¤‘í•™êµ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    }
}
*/

async function loadMiddleSchools() {
    try {
        const response = await fetch("middleSchools.json");
        let middleSchools = await response.json();
		console.log(middleSchools);
        // âœ… ì¤‘ë³µ ì œê±°: í•™êµ IDë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì²« ë²ˆì§¸ ê°’ë§Œ ìœ ì§€
        const uniqueSchools = [];
        const seenIds = new Set();

        middleSchools.forEach(school => {
            if (!seenIds.has(school["í•™êµ ID"])) {
                seenIds.add(school["í•™êµ ID"]);
                uniqueSchools.push(school);
            }
        });

        //console.log("âœ… ì¤‘ë³µ ì œê±° ì™„ë£Œ: ì´", uniqueSchools.length, "ê°œ í•™êµ ë¡œë“œë¨");

        window.middleSchoolData = uniqueSchools; // âœ… ì¤‘ë³µ ì œê±°ëœ ë°ì´í„° ì €ì¥

        // âœ… ë§ˆì»¤ ì—…ë°ì´íŠ¸
        updateMiddleSchoolMarkers();

        // âœ… ì§€ë„ ì´ë™ ì‹œ í˜„ì¬ ë²”ìœ„ ë‚´ ì¤‘í•™êµ ë§ˆì»¤ ì—…ë°ì´íŠ¸
        naver.maps.Event.addListener(window.map, "idle", function () {
            updateMiddleSchoolMarkers();
        });

    } catch (error) {
        console.error("âŒ ì¤‘í•™êµ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    }
}



function updateMiddleSchoolMarkers() {
    const showMiddleSchools = document.getElementById("toggleMiddleSchools").checked;
	
    // âœ… ê¸°ì¡´ ì¤‘í•™êµ ë§ˆì»¤ ì œê±°
    middleSchoolMarkers.forEach(marker => marker.setMap(null));
    middleSchoolMarkers = [];

    if (!showMiddleSchools) return; // ì¤‘í•™êµ í‘œì‹œ ì²´í¬ í•´ì œ ì‹œ ì¢…ë£Œ
	
	if (window.map.getZoom() < 14) { 
        return; // âœ… ì¤Œ ë ˆë²¨ì´ 14ë³´ë‹¤ ì‘ìœ¼ë©´ ì‹¤í–‰ ì¤‘ë‹¨
    }

    let bounds = window.map.getBounds();
    let filteredSchools = window.middleSchoolData.filter(school =>
        bounds.hasLatLng(new naver.maps.LatLng(school["ìœ„ë„"], school["ê²½ë„"]))
    );
	console.log(filteredSchools);
    filteredSchools.forEach(school => {
    // âœ… ë§ˆì»¤ ì»¨í…Œì´ë„ˆë¥¼ markerElementë¡œ í™œìš©
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = "midSchool.png";
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;
    infoBox.textContent = `${school["í•™êµëª…"]} (${school["í•™ì—…ì„±ì·¨ë„"]}/${school["íŠ¹ëª©ê³ "]})`;

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(school["ìœ„ë„"], school["ê²½ë„"]),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // âœ… ìš°í´ë¦­ ì´ë²¤íŠ¸ì— markerElement ì „ë‹¬ (í…Œë‘ë¦¬ í™œì„±í™” ê°€ëŠ¥)
    addMarkerRightClickEvent(marker, markerElement);

    middleSchoolMarkers.push(marker);
});

}


// âœ… ì¤‘í•™êµ ì²´í¬ë°•ìŠ¤ ë³€ê²½ ì‹œ ë§ˆì»¤ ì—…ë°ì´íŠ¸
document.getElementById("toggleMiddleSchools").addEventListener("change", () => {
    updateMiddleSchoolMarkers(); // âœ… ì¦‰ì‹œ ì—…ë°ì´íŠ¸
});

let facilityMarkers = []; // âœ… ì§€ë„ì— í‘œì‹œëœ ì‹œì„¤ ë§ˆì»¤ ì €ì¥

async function loadFacilities() {
    try {
        const response = await fetch("facility.json");
        const facilities = await response.json();

        //console.log("âœ… ì‹œì„¤ ë°ì´í„° ë¡œë“œ ì™„ë£Œ", facilities);
        window.facilityData = facilities; // âœ… ì „ì²´ ì‹œì„¤ ë°ì´í„° ì €ì¥

        // âœ… ì´ˆê¸° ë§ˆì»¤ ì—…ë°ì´íŠ¸
        updateFacilityMarkers(window.map.getBounds());

        // âœ… ì§€ë„ ì´ë™ ì‹œ í˜„ì¬ ë²”ìœ„ ë‚´ ì‹œì„¤ ë§ˆì»¤ ì—…ë°ì´íŠ¸
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateFacilityMarkers(bounds);
        });

    } catch (error) {
        console.error("âŒ ì‹œì„¤ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    }
}

function updateFacilityMarkers() {
    const showFacilities = document.getElementById("toggleFacilities").checked;

    // âœ… ê¸°ì¡´ ì‹œì„¤ ë§ˆì»¤ ì œê±°
    facilityMarkers.forEach(marker => marker.setMap(null));
    facilityMarkers = [];

    if (!showFacilities) return; // ì²´í¬ í•´ì œ ì‹œ ì¢…ë£Œ
    if (window.map.getZoom() < 14) return; // âœ… ì¤Œ ë ˆë²¨ì´ 14ë³´ë‹¤ ì‘ìœ¼ë©´ ì‹¤í–‰ ì¤‘ë‹¨

    let bounds = window.map.getBounds();
    let filteredFacilities = window.facilityData.filter(facility =>
        bounds.hasLatLng(new naver.maps.LatLng(facility.lat, facility.lng))
    );

    filteredFacilities.forEach(facility => {
    let iconSrc = "default.png"; // ê¸°ë³¸ ì•„ì´ì½˜ (ì˜ˆì™¸ì²˜ë¦¬)
    if (facility.category === 10) {
        iconSrc = facility.description.includes("ë°±í™”ì ") ? "depart.png" : "mart.png";
    } else if (facility.category === 9) {
        iconSrc = "hospital.png";
    }

    // âœ… ë§ˆì»¤ ì»¨í…Œì´ë„ˆë¥¼ markerElementë¡œ í™œìš©
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = iconSrc;
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;

    if (facility.category === 10) {
        infoBox.textContent = `${facility.description} (${facility.name})`;
    } else if (facility.category === 9) {
        infoBox.textContent = `${facility.name}`;
    }

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(facility.lat, facility.lng),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // âœ… ìš°í´ë¦­ ì´ë²¤íŠ¸ì— markerElement ì „ë‹¬ (í…Œë‘ë¦¬ í™œì„±í™” ê°€ëŠ¥)
    addMarkerRightClickEvent(marker, markerElement);

    facilityMarkers.push(marker);
});

}

// âœ… ì‹œì„¤ ì²´í¬ë°•ìŠ¤ ë³€ê²½ ì‹œ ë§ˆì»¤ ì—…ë°ì´íŠ¸
document.getElementById("toggleFacilities").addEventListener("change", () => {
    updateFacilityMarkers(); // âœ… ì¦‰ì‹œ ì—…ë°ì´íŠ¸
});

let starbucksMarkers = []; // âœ… ì§€ë„ì— í‘œì‹œëœ ìŠ¤íƒ€ë²…ìŠ¤ ë§ˆì»¤ ì €ì¥

async function loadStarbucks() {
    try {
        const response = await fetch("starbucks.json");
        const starbucks = await response.json();

        //console.log("âœ… ìŠ¤íƒ€ë²…ìŠ¤ ë°ì´í„° ë¡œë“œ ì™„ë£Œ", starbucks);
        window.starbucksData = starbucks; // âœ… ì „ì²´ ìŠ¤íƒ€ë²…ìŠ¤ ë°ì´í„° ì €ì¥

        // âœ… ì´ˆê¸° ë§ˆì»¤ ì—…ë°ì´íŠ¸
        updateStarbucksMarkers(window.map.getBounds());

        // âœ… ì§€ë„ ì´ë™ ì‹œ í˜„ì¬ ë²”ìœ„ ë‚´ ìŠ¤íƒ€ë²…ìŠ¤ ë§ˆì»¤ ì—…ë°ì´íŠ¸
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateStarbucksMarkers(bounds);
        });

    } catch (error) {
        console.error("âŒ ìŠ¤íƒ€ë²…ìŠ¤ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    }
}

function updateStarbucksMarkers() {
    const showStarbucks = document.getElementById("toggleStarbucks").checked;

    // âœ… ê¸°ì¡´ ìŠ¤íƒ€ë²…ìŠ¤ ë§ˆì»¤ ì œê±°
    starbucksMarkers.forEach(marker => marker.setMap(null));
    starbucksMarkers = [];

    if (!showStarbucks) return; // ì²´í¬ í•´ì œ ì‹œ ì¢…ë£Œ
    if (window.map.getZoom() < 14) return; // âœ… ì¤Œ ë ˆë²¨ì´ 14ë³´ë‹¤ ì‘ìœ¼ë©´ ì‹¤í–‰ ì¤‘ë‹¨

    let bounds = window.map.getBounds();
    let filteredStarbucks = window.starbucksData.filter(store =>
        bounds.hasLatLng(new naver.maps.LatLng(store.lat, store.lot))
    );

     filteredStarbucks.forEach(store => {
        let iconSrc = store.s_name.includes("R") ? "starbucksReserve.png" : "starbucks.png";

        // âœ… ë§ˆì»¤ ì»¨í…Œì´ë„ˆë¥¼ markerElementë¡œ í™œìš©
        const markerElement = document.createElement("div");
        markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

        const markerIcon = document.createElement("img");
        markerIcon.src = iconSrc;
        markerIcon.style = "width: 32px; height: 32px;";

        markerElement.appendChild(markerIcon);

        const marker = new naver.maps.Marker({
            position: new naver.maps.LatLng(store.lat, store.lot),
            map: window.map,
            icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
        });

        // âœ… ìš°í´ë¦­ ì´ë²¤íŠ¸ì— markerElement ì „ë‹¬
        addMarkerRightClickEvent(marker, markerElement);

        starbucksMarkers.push(marker);
    });
}

// âœ… ìŠ¤íƒ€ë²…ìŠ¤ ì²´í¬ë°•ìŠ¤ ë³€ê²½ ì‹œ ë§ˆì»¤ ì—…ë°ì´íŠ¸
document.getElementById("toggleStarbucks").addEventListener("change", () => {
    updateStarbucksMarkers(); // âœ… ì¦‰ì‹œ ì—…ë°ì´íŠ¸
});


////////////////////////// ì´ë™ ì´ë²¤íŠ¸ //////////////////////////
let activeMarker = null; // âœ… í˜„ì¬ ì„ íƒëœ ë§ˆì»¤
var activeMarkerElement = null; // âœ… í˜„ì¬ ì„ íƒëœ ë§ˆì»¤ì˜ ìš”ì†Œ (í…Œë‘ë¦¬ ë³€ê²½ìš©)

// âœ… ğŸ”¥ ë§ˆì»¤ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì„ íƒëœ ê²½ìš° ê°•ì¡°)
function updateMarkerSelection(markerElement, isSelected) {
    if (markerElement) {
        setTimeout(() => {
            markerElement.style.outline = isSelected ? "3px solid red" : "";
        }, 50); // âœ… DOM ì—…ë°ì´íŠ¸ ëŒ€ê¸° í›„ ìŠ¤íƒ€ì¼ ì ìš©
    }
}


function addMarkerRightClickEvent(marker, markerElement) {
    naver.maps.Event.addListener(marker, "rightclick", (e) => {
        e.domEvent.preventDefault();
        e.domEvent.stopPropagation();

        const isSiseMapActive = document.getElementById("toggleSiseMap").checked;

        console.log("ğŸš€ ë§ˆì»¤ ìš°í´ë¦­ ê°ì§€ (ID: " + marker.apartmentId + ")");

        // âœ… ê¸°ì¡´ ì„ íƒëœ ë§ˆì»¤ í…Œë‘ë¦¬ ì œê±°
        if (activeMarkerElement) {
            updateMarkerSelection(activeMarkerElement, false);
        }

        // âœ… í˜„ì¬ ì„ íƒëœ ë§ˆì»¤ ì—…ë°ì´íŠ¸
        activeMarker = marker;
        activeMarkerElement = markerElement; // âœ… ê¸°ì¡´ ë°©ì‹
        updateMarkerSelection(activeMarkerElement, true);

        // âœ… ë§Œì•½ ë§ˆì»¤ê°€ ì‹œì„¸ì§€ë„ ë§ˆì»¤ì´ë©´ `.siseMapMarker`ë¥¼ ë‹¤ì‹œ ì°¾ê³  ìŠ¤íƒ€ì¼ ì ìš©
        if (isSiseMapActive) {
            setTimeout(() => {
                const updatedMarkerElement = markerElement.querySelector(".siseMapMarker");
                if (updatedMarkerElement) {
                    activeMarkerElement = updatedMarkerElement;
                    updateMarkerSelection(updatedMarkerElement, true);
                }
            }, 100); // âœ… DOM ì—…ë°ì´íŠ¸ ëŒ€ê¸° í›„ ìŠ¤íƒ€ì¼ ì ìš©
        }
    });
}





// âœ… í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë“±ë¡
document.removeEventListener("keydown", handleKeyDown);
document.addEventListener("keydown", handleKeyDown);



function setupRightClickEvent() {
    let radiusCircle = null; // âœ… ë°˜ê²½ ì› ê°ì²´
    let centerMarker = null; // âœ… ë°˜ê²½ ì¤‘ì‹¬ ë§ˆì»¤

    // âœ… ì§€ë„ì—ì„œ ìš°í´ë¦­ ì‹œ (ë°˜ê²½ 1km ì› + ì¤‘ì‹¬ ë¹¨ê°„ ì  ì¶”ê°€)
    naver.maps.Event.addListener(window.map, "mousedown", function (e) {
        if (e.domEvent.button !== 2) return; // âœ… ìš°í´ë¦­ì´ ì•„ë‹ ê²½ìš° ë¬´ì‹œ
		
        let clickedPosition = e.coord; // âœ… ìš°í´ë¦­í•œ ìœ„ì¹˜ì˜ ì¢Œí‘œ
        //console.log("ğŸ“ ìš°í´ë¦­ ìœ„ì¹˜:", clickedPosition);

        // âœ… ì´ë¯¸ ë°˜ê²½ ì›ì´ ìˆëŠ” ê²½ìš°, ì œê±° í›„ ì¢…ë£Œ (í† ê¸€ ë°©ì‹)
        if (radiusCircle) {
            radiusCircle.setMap(null);
            radiusCircle = null;
        }
		
        if (centerMarker) {
            centerMarker.setMap(null);
            centerMarker = null;
            return; // âœ… ì‚­ì œ í›„ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•ŠìŒ
        }

		if (document.getElementById("toggleFindWay")?.checked) return;

        // âœ… ë°˜ê²½ 1km ì› ì¶”ê°€
        radiusCircle = new naver.maps.Circle({
            map: window.map,
            center: clickedPosition,
            radius: 1000, // âœ… ë°˜ê²½ 1km
            strokeColor: "#FF0000",
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: "#FF0000",
            fillOpacity: 0.08
        });

        // âœ… ë°˜ê²½ ì¤‘ì‹¬ì— ë¹¨ê°„ìƒ‰ ì‘ì€ ì  ì¶”ê°€
        centerMarker = new naver.maps.Marker({
            position: clickedPosition,
            map: window.map,
            icon: {
                content: `<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%; border: 1px solid white;"></div>`,
                anchor: new naver.maps.Point(4, 4) // âœ… ì¤‘ì‹¬ ì •ë ¬
            }
        });

        // âœ… ì§€ë„ ì¤‘ì‹¬ì„ í´ë¦­í•œ ìœ„ì¹˜ë¡œ ì´ë™
        window.map.panTo(clickedPosition);
    });

    // âœ… ê¸°ë³¸ì ì¸ ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
    document.addEventListener("contextmenu", function (e) {
        e.preventDefault();
    });

    //console.log("âœ… ì§€ë„ ë¡œë“œ ì™„ë£Œ í›„ ìš°í´ë¦­ ì´ë²¤íŠ¸ ë“±ë¡ë¨");
}

//////////////////////////////////ì‹œì„¸ ì§€ë„ ////////////////////////////




var activeMarkerSet = null;

// âœ… IndexedDB ì´ˆê¸°í™”
function initIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("hongbu", 5);

        request.onupgradeneeded = function(event) {
            const db = event.target.result;

            if (!db.objectStoreNames.contains('apartments')) {
                const store = db.createObjectStore('apartments', { keyPath: 'idType' });
                store.createIndex('id', 'id', { unique: false });
                console.log('âœ… IndexedDB ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ: apartments store ìƒì„±ë¨');
            }
			if (!db.objectStoreNames.contains('importSiseVer2')) {
                const store = db.createObjectStore('importSiseVer2', { keyPath: 'idType' });
                store.createIndex('id', 'id', { unique: false });
                console.log('âœ… IndexedDB ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ: importSiseVer2 store ìƒì„±ë¨');
            } // ğŸ”½ğŸ”½ğŸ”½ ì—¬ê¸°ê°€ ì¶”ê°€ëœ ë¶€ë¶„
			if (!db.objectStoreNames.contains('settings')) {
				db.createObjectStore('settings'); // keyPath ì—†ì´ key-value í˜•íƒœë¡œ ì‚¬ìš©
				console.log('âœ… IndexedDB ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ: settings store ìƒì„±ë¨');
			}
			  // ğŸ”¼ğŸ”¼ğŸ”¼
        };

        request.onsuccess = function(event) {
            console.log('ğŸ“Œ hongbu ì—°ê²° ì„±ê³µ (DB: hongbu)');
            resolve(event.target.result);
        };

        request.onerror = function(event) {
            console.error('âŒ IndexedDB ì—°ê²° ì‹¤íŒ¨:', event.target.error);
            reject(event.target.error);
        };
    });
}
function initMemoIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("hongbuMemo", 4);

    request.onupgradeneeded = function (event) {
      const db = event.target.result;
      if (!db.objectStoreNames.contains("apartmentNotes")) {
        db.createObjectStore("apartmentNotes", { keyPath: "id" });
      }
    };

    request.onsuccess = function (event) {
      const db = event.target.result;

      // âœ… iOS ê¼¬ì„ ë³µêµ¬: ì´ë¯¸ v4ì¸ë° storeê°€ ì—†ìœ¼ë©´ DBë¥¼ ì§€ìš°ê³  ì¬ìƒì„± ìœ ë„
      if (!db.objectStoreNames.contains("apartmentNotes")) {
        db.close();
        const del = indexedDB.deleteDatabase("hongbuMemo");
        del.onsuccess = () => resolve(initMemoIndexedDB());
        del.onerror = (e) => reject(e.target.error);
        del.onblocked = () => reject(new Error("hongbuMemo delete blocked (ë‹¤ë¥¸ íƒ­ ë‹«ê¸° í•„ìš”)"));
        return;
      }

      db.close();
      resolve(true);
    };

    request.onerror = (e) => reject(e.target.error);
  });
}

// âœ… ë©”ëª¨ ì¡´ì¬ ì—¬ë¶€(ì•„ì´ì½˜ í‘œì‹œìš©) í‚¤ì…‹ì„ í•œë²ˆë§Œ ë¡œë“œí•´ì„œ ë§ˆì»¤ ìƒì„± ì‹œ DBë¥¼ ë§¤ë²ˆ ì—´ì§€ ì•Šë„ë¡ ìµœì í™”
window.__hongbuMemoKeySet = window.__hongbuMemoKeySet || new Set();
window.__hongbuMemoKeySetReady = window.__hongbuMemoKeySetReady || false;

async function loadMemoKeySetOnce() {
  if (window.__hongbuMemoKeySetReady) return window.__hongbuMemoKeySet;
  await initMemoIndexedDB();

  return new Promise((resolve) => {
    const req = indexedDB.open("hongbuMemo", 4);
    req.onerror = () => {
      window.__hongbuMemoKeySet = new Set();
      window.__hongbuMemoKeySetReady = true;
      resolve(window.__hongbuMemoKeySet);
    };
    req.onsuccess = (event) => {
      const db = event.target.result;
      try {
        const tx = db.transaction(["apartmentNotes"], "readonly");
        const store = tx.objectStore("apartmentNotes");

        // getAllKeys ì§€ì› ì‹œ ê°€ì¥ ë¹ ë¦„
        if (store.getAllKeys) {
          const kreq = store.getAllKeys();
          kreq.onsuccess = () => {
            const keys = (kreq.result || []).map(k => String(k));
            window.__hongbuMemoKeySet = new Set(keys);
            window.__hongbuMemoKeySetReady = true;
            try { db.close(); } catch(e) {}
            resolve(window.__hongbuMemoKeySet);
          };
          kreq.onerror = () => {
            window.__hongbuMemoKeySet = new Set();
            window.__hongbuMemoKeySetReady = true;
            try { db.close(); } catch(e) {}
            resolve(window.__hongbuMemoKeySet);
          };
        } else {
          // fallback: cursor
          const s = new Set();
          const cur = store.openCursor();
          cur.onsuccess = (e) => {
            const cursor = e.target.result;
            if (cursor) {
              s.add(String(cursor.key));
              cursor.continue();
            } else {
              window.__hongbuMemoKeySet = s;
              window.__hongbuMemoKeySetReady = true;
              try { db.close(); } catch(e) {}
              resolve(window.__hongbuMemoKeySet);
            }
          };
          cur.onerror = () => {
            window.__hongbuMemoKeySet = new Set();
            window.__hongbuMemoKeySetReady = true;
            try { db.close(); } catch(e) {}
            resolve(window.__hongbuMemoKeySet);
          };
        }
      } catch (e) {
        window.__hongbuMemoKeySet = new Set();
        window.__hongbuMemoKeySetReady = true;
        try { db.close(); } catch(e) {}
        resolve(window.__hongbuMemoKeySet);
      }
    };
  });
}



// âœ… hongbu.settings ì €ì¥
function setHongbuSetting(key, value) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("hongbu", 5);
    request.onsuccess = (event) => {
      const db = event.target.result;
      const tx = db.transaction(["settings"], "readwrite");
      const store = tx.objectStore("settings");
      store.put(value, key);
      tx.oncomplete = () => { db.close(); resolve(); };
      tx.onerror = (e) => { db.close(); reject(e); };
    };
    request.onerror = (e) => reject(e);
  });
}

// âœ… hongbu.settings ì½ê¸°
function getHongbuSetting(key) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("hongbu", 5);
    request.onsuccess = (event) => {
      const db = event.target.result;
      const tx = db.transaction(["settings"], "readonly");
      const store = tx.objectStore("settings");
      const getReq = store.get(key);
      getReq.onsuccess = () => { 
        db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        resolve(getReq.result); 
      };
      getReq.onerror = (e) => { 
        db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        reject(e); 
      };
    };
    request.onerror = (e) => {
      try { /* dbê°€ ì—´ë¦¬ì§€ ì•Šì•„ ì´ë¯¸ ë‹«í˜ */ } catch(e) {}
      reject(e);
    };
  });
}


// âœ… hongbu.settings ì‚­ì œ
function deleteHongbuSetting(key) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("hongbu", 5);
    request.onsuccess = (event) => {
      const db = event.target.result;
      const tx = db.transaction(["settings"], "readwrite");
      const store = tx.objectStore("settings");
      store.delete(key);
      tx.oncomplete = () => { db.close(); resolve(); };
      tx.onerror = (e) => { db.close(); reject(e); };
    };
    request.onerror = (e) => {
      try { /* dbê°€ ì—´ë¦¬ì§€ ì•Šì•„ ì´ë¯¸ ë‹«í˜ */ } catch(e) {}
      reject(e);
    };
  });
}


// ================================
// âœ… UI ì˜µì…˜(ì²´í¬ë°•ìŠ¤/í•„í„° ë“±) ì €ì¥/ë³µì› (IndexedDB settings)
// - ìƒˆë¡œê³ ì¹¨/ì•±ì „í™˜(ë¦¬ë¡œë“œ)ì—ë„ í˜„ì¬ ì˜µì…˜ ìƒíƒœ ìœ ì§€
// ================================
const UI_STATE_KEY = "uiState_v1";
const MAP_FULLSCREEN_KEY = "mapPseudoFullscreen_v1";

// file inputì€ ìƒíƒœ ì €ì¥ ì œì™¸
function _isSkippableUiEl(el) {
  if (!el || !el.id) return true;
  const type = (el.getAttribute("type") || "").toLowerCase();
  return type === "file" || el.id === "gpxFileInput" || el.id === "memoRestoreInput";
}

// DOMì—ì„œ í˜„ì¬ UI ìƒíƒœ ìˆ˜ì§‘
function collectUIState() {
  const state = {};
  const nodes = document.querySelectorAll("input[id], select[id], textarea[id]");
  nodes.forEach(el => {
    if (_isSkippableUiEl(el)) return;
    const tag = el.tagName.toLowerCase();
    if (tag === "input") {
      const type = (el.getAttribute("type") || "text").toLowerCase();
      if (type === "checkbox") state[el.id] = !!el.checked;
      else if (type === "radio") { if (el.checked) state[el.name || el.id] = el.value; }
      else state[el.id] = el.value;
    } else {
      state[el.id] = el.value;
    }
  });
  return state;
}

// UI ìƒíƒœë¥¼ DOMì— ë°˜ì˜
function applyUIState(state) {
  if (!state || typeof state !== "object") return;

  Object.entries(state).forEach(([id, val]) => {
    const el = document.getElementById(id);
    if (!el || _isSkippableUiEl(el)) return;

    const tag = el.tagName.toLowerCase();
    if (tag === "input") {
      const type = (el.getAttribute("type") || "text").toLowerCase();
      if (type === "checkbox") {
        el.checked = !!val;
      } else if (type === "radio") {
        // name ê¸°ì¤€ìœ¼ë¡œ ë³µì›
        const group = document.querySelectorAll(`input[type="radio"][name="${CSS.escape(el.name)}"]`);
        group.forEach(r => { r.checked = (r.value === val); });
      } else {
        el.value = val;
      }
    } else {
      // select/textarea
      try {
        el.value = val;
      } catch (e) {}
    }
  });
}

// IndexedDBì— UI ìƒíƒœ ì €ì¥
let _uiSaveTimer = null;
function saveUIStateDebounced(delayMs = 250) {
  if (_uiSaveTimer) clearTimeout(_uiSaveTimer);
  _uiSaveTimer = setTimeout(() => {
    const state = collectUIState();
    setHongbuSetting(UI_STATE_KEY, state).catch(console.warn);
  }, delayMs);
}

// IndexedDBì—ì„œ UI ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° + ì ìš©
async function restoreUIStateFromDB() {
  try {
    const saved = await getHongbuSetting(UI_STATE_KEY);
    if (saved && typeof saved === "object") {
      applyUIState(saved);
    }
  } catch (e) {
    console.warn("UI ìƒíƒœ ë³µì› ì‹¤íŒ¨:", e);
  }
}

// UI ë³€ê²½ ìë™ ì €ì¥ (ì´ë²¤íŠ¸ ìœ„ì„)
function initUIStateAutoSave() {
  // input/textarea/select ë³€ê²½ì„ ëª¨ë‘ ìºì¹˜
  document.addEventListener("change", (e) => {
    const el = e.target;
    if (!el || !el.id || _isSkippableUiEl(el)) return;
    saveUIStateDebounced();
  }, true);

  document.addEventListener("input", (e) => {
    const el = e.target;
    if (!el || !el.id || _isSkippableUiEl(el)) return;
    saveUIStateDebounced();
  }, true);
}

// ì§€ë„/ë§ˆì»¤ ë“±ì´ ì¤€ë¹„ëœ ë’¤, í˜„ì¬ UI ìƒíƒœì— ë§ê²Œ ì¦‰ì‹œ í™”ë©´ ë°˜ì˜
function refreshByUIState() {
  if (!window.map) return;
  try { updateMarkers(window.map.getBounds()); } catch (e) {}
  try { updateSchoolMarkers(); } catch (e) {}
  try { updateMiddleSchoolMarkers?.(); } catch (e) {}
  try { updateFacilityMarkers?.(); } catch (e) {}
  try { updateStarbucksMarkers?.(); } catch (e) {}
  try { scheduleEmdRedraw?.(); } catch (e) {}
  try { scheduleAdmRedraw?.(); } catch (e) {}
}


// âœ… IndexedDB ì €ì¥ í•¨ìˆ˜
function saveToIndexedDB(id, type, text, color, textColor, fontSize) {
    const request = indexedDB.open("hongbu", 5);
    request.onsuccess = function(event) {
        const db = event.target.result;
        const transaction = db.transaction(["apartments"], "readwrite");
        const store = transaction.objectStore("apartments");

        store.put({ idType: `${id}-${type}`, text, color, textColor, fontSize });

        transaction.oncomplete = () => {
            console.log(`âœ… IndexedDB ì €ì¥ ì™„ë£Œ: ${id}`);
            db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        };
        transaction.onerror = (e) => {
            console.error(`âŒ IndexedDB ì €ì¥ ì˜¤ë¥˜: ${e.target.error}`);
            db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        };
    };
    request.onerror = function(event) {
        console.error(`âŒ IndexedDB ì—´ê¸° ì‹¤íŒ¨: ${event.target.error}`);
    };
	markerElement = document.querySelector(`[data-apartment-id='${id}']`);
	//markerElement.style.maxWidth = '160px';


}

// âœ… IndexedDBì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
function getFromIndexedDB(id, type) {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("hongbu", 5);

        request.onerror = (event) => {
            reject("âŒ IndexedDB ì—´ê¸° ì˜¤ë¥˜: " + event.target.errorCode);
        };

        request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(["apartments"], "readonly");
            const store = transaction.objectStore("apartments");

            const idType = `${id}-${type}`;
            const getRequest = store.get(idType);

            getRequest.onsuccess = () => {
                db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
                if (getRequest.result) {
                    resolve(getRequest.result);
                } else {
                    resolve({ text: "", color: "#9F9F9F", textColor: "#ffffff", fontSize: "12px" });
                }
            };

            getRequest.onerror = () => {
                db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
                reject("âŒ IndexedDB ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨");
            };
        };
    });
}
document.getElementById("toggleSiseMap").addEventListener("change", function() {
    const isChecked = this.checked;

	document.getElementById("siseExportBtn").style.display = isChecked ? "inline-block" : "none";
    document.getElementById("siseImportBtn").style.display = isChecked ? "inline-block" : "none";
	document.getElementById("siseResetBtn").style.display = isChecked ? "inline-block" : "none";

document.getElementById("siseVer2ImportBtn").style.display = isChecked ? "none" : "inline-block";
document.getElementById("siseVer2ResetBtn").style.display = isChecked ? "none" : "inline-block";
	if(!isChecked){
		removeAllLines(window.map.getBounds());
	}
    updateMarkers(window.map.getBounds())
	
});



function renderSiseMapMarker(apartment) {
    // âœ… ê¸°ì¡´ ë§ˆì»¤ê°€ ìˆìœ¼ë©´ ì‚­ì œ
    if (apartmentMarkers[apartment.id]) {
        naver.maps.Event.clearInstanceListeners(apartmentMarkers[apartment.id]); // ğŸ”¥ ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±°
        apartmentMarkers[apartment.id].setMap(null); // ğŸ”¥ ì§€ë„ì—ì„œ ì‚­ì œ
        delete apartmentMarkers[apartment.id]; // ğŸ”¥ ë©”ëª¨ë¦¬ì—ì„œ ì œê±°
    }

    const markerElement = document.createElement("div");
    markerElement.className = "siseMapMarker";
    markerElement.style = `
    background: #fff;
    border: 2px solid black;
    padding: 0px;
    font-size: 12px;
    text-align: center;
    border-radius: 6px;
    display: inline-block;  /* âœ… ìë™ ë„ˆë¹„ ì„¤ì • */
    max-width: 200px;        /* âœ… í•„ìš”í•˜ë©´ ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
min-width: 120px;
    word-break: keep-all;   /* âœ… ì¤„ë°”ê¿ˆ ë°©ì§€ */
`;


    markerElement.setAttribute("data-apartment-id", apartment.id);

    const nameElement = document.createElement("div");
    nameElement.innerHTML = `${apartment.name}<br>${apartment.year.slice(-5)} ${apartment.units}ì„¸ëŒ€`;
    nameElement.style = `
        font-weight: bold;
        font-size: 12px;
        margin: 5px;
overflow: hidden; /* âœ… ë„˜ì¹˜ëŠ” ë‚´ìš© ìˆ¨ê¹€ */
    white-space: nowrap; /* âœ… í•œ ì¤„ ìœ ì§€ */
    text-overflow: ellipsis; /* âœ… ë§ì¤„ì„ (...) ì²˜ë¦¬ */
    `;

    const tableContainer = document.createElement("div");
    tableContainer.className = "tableContainer";
    tableContainer.style = `
    background: white;
    padding: 0px;
    font-size: 12px;
min-height: 24px;
    display: block;
    width: auto;           /* âœ… ë§ˆì»¤ê°€ ë‚´ìš©ì— ë§ê²Œ ëŠ˜ì–´ë‚˜ë„ë¡ */
    max-width: none;       /* âœ… ì œí•œ ì œê±° */
    overflow: visible;     /* âœ… ë„˜ì¹¨ í—ˆìš© */
`;


    markerElement.appendChild(nameElement);
    markerElement.appendChild(tableContainer);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: markerElement,
            anchor: new naver.maps.Point(10, 30)
        }
    });
	marker.originPosition = new naver.maps.LatLng(apartment.lat, apartment.lng); // âœ… ìµœì´ˆ ìœ„ì¹˜ ì €ì¥
    marker.apartmentId = apartment.id;

    // âœ… ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€ ìœ„í•´ ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±° í›„ ë‹¤ì‹œ ì¶”ê°€
    addSiseMapMarkerLeftClickEvent(marker, markerElement);
    addMarkerRightClickEvent(marker, markerElement);

    // âœ… IndexedDBì—ì„œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
    updateT2FromIndexedDB(apartment.id, markerElement, tableContainer);

    return marker;
}


// âœ… IndexedDBì—ì„œ ë°ì´í„° ê°€ì ¸ì™€ í…Œì´ë¸” ì—…ë°ì´íŠ¸ + ìˆ˜ì • ê°€ëŠ¥í•˜ê²Œ ì ìš©
function updateT2FromIndexedDB(id, markerElement, tableContainer) {
	let siseChecked = document.getElementById("toggleSiseMap").checked;
    if (!siseChecked) return;
	

    getFromIndexedDB(id, "ì‹œì„¸1").then(data => {
        let tableData = data?.text || generateDefaultTable();
        tableContainer.innerHTML = createEditableTableHTML(id, tableData);

        let bgColor = data?.color?.trim() || '#9F9F9F';
		let textColor = data?.textColor?.trim() || '#FFFFFF';
		let fontSize = data?.fontSize?.trim();

		if (!fontSize || fontSize === "undefined" || fontSize === "") {
			fontSize = "12px";
		}


        // âœ… IndexedDBì—ì„œ ê°€ì ¸ì˜¨ ê°’ ë””ë²„ê¹… ì¶œë ¥
        //console.log(`ğŸ¨ IndexedDB ë¶ˆëŸ¬ì˜¨ ë°ì´í„° (ID: ${id}):`, data);
        //console.log(`ğŸ”¹ ì ìš©í•  ìƒ‰ìƒ: ë°°ê²½ìƒ‰=${bgColor}, ê¸€ììƒ‰=${textColor}, ê¸€ì í¬ê¸°=${fontSize}`);

        markerElement.style.backgroundColor = bgColor;
        markerElement.style.color = textColor;
        markerElement.style.fontSize = fontSize;
		tableContainer.style.fontSize = fontSize;

        // âœ… ê°•ì œ ì ìš© í›„ í™•ì¸
        //console.log(`ğŸŸ¢ ì ìš©ëœ markerElement.style.color: ${markerElement.style.color}`);

        // âœ… ë§Œì•½ colorê°€ ë¹ˆ ê°’ì´ë©´ ê¸°ë³¸ê°’ ê°•ì œ ì ìš©
        if (!markerElement.style.color || markerElement.style.color === "" || markerElement.style.color === "undefined") {
            markerElement.style.color = "#FFFFFF"; 
            //console.log(`âš ï¸ ê°•ì œ ì ìš© í›„ markerElement.style.color: ${markerElement.style.color}`);
        }

		// âœ… tableData ê°’ì„ ê²€ì‚¬í•´ì„œ ê°’ì´ ìˆìœ¼ë©´ â†’ 160px, ì—†ìœ¼ë©´ â†’ 120px
let maxWidth = 120;

if (data?.text?.trim()) {
    // âœ… í…ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆì§€ ì•Šìœ¼ë©´ ë„ˆë¹„ë¥¼ ëŠ˜ë¦¼
    maxWidth = 200;
}

// âœ… markerElementì— max-width ë°˜ì˜
markerElement.style.maxWidth = `${maxWidth}px`;



        makeTableEditable(tableContainer); // âœ… í…Œì´ë¸”ì„ ìˆ˜ì • ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
    }).catch(console.error);
}



// âœ… ê¸°ë³¸ 3x4 í…Œì´ë¸” ìƒì„±
function generateDefaultTable() {
    let defaultTable = [];
    for (let i = 0; i < 3; i++) {
        let row = [];
        for (let j = 0; j < 4; j++) {
            row.push("");  // ê¸°ë³¸ê°’ ì„¤ì •
        }
        defaultTable.push(row.join('\t'));
    }
    return defaultTable.join('\n'); // ì¤„ë°”ê¿ˆ í¬í•¨í•˜ì—¬ ì €ì¥
}

/*
// âœ… ìˆ˜ì • ê°€ëŠ¥í•œ í…Œì´ë¸”ì„ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
function createEditableTableHTML(id, textData) {
    let rows = textData.split('\n').map(row => row.split('\t'));
    const table = document.createElement("table");
    table.style.borderCollapse = "collapse";
    table.style.width = "100%";             // âœ… ìë™ ë„ˆë¹„
    table.style.tableLayout = "auto";       // âœ… ì—´ë§ˆë‹¤ ìœ ë™ì  ë„ˆë¹„
    table.style.color = "black";

    rows.forEach((row, rowIndex) => {
        const tr = document.createElement("tr");
        row.forEach((cell, colIndex) => {
            const td = document.createElement("td");
            td.dataset.id = id;
            td.dataset.row = rowIndex;
            td.dataset.col = colIndex;
            td.textContent = cell.trim();

            td.style = `
				border: 1px solid black;
				padding: 2px 4px;
				text-align: center;
				height: 24px;

				vertical-align: middle;
				white-space: normal;  // âœ… ì¤„ë°”ê¿ˆ í—ˆìš© 
				word-break: break-word; // âœ… í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ 
			`;


            tr.appendChild(td);
        });
        table.appendChild(tr);
    });

    return table.outerHTML;
}
*/
function createEditableTableHTML(id, textData) {
    let rows = textData.split('\n').map(row => row.split('\t'));
    const table = document.createElement("table");
    table.style.borderCollapse = "collapse";
    table.style.width = "100%";
    table.style.tableLayout = "auto";
    table.style.color = "black";

    rows.forEach((row, rowIndex) => {
        const tr = document.createElement("tr");

        for (let colIndex = 0; colIndex < 4; colIndex++) {  // ì—´ 4ê°œ ê³ ì •
            const td = document.createElement("td");
            td.dataset.id = id;
            td.dataset.row = rowIndex;
            td.dataset.col = colIndex;
            td.contentEditable = "true";
            td.textContent = row[colIndex]?.trim() || "";

            // âœ… ì…€ ìŠ¤íƒ€ì¼
            td.style = `
                border: 1px solid black;
                padding: 2px 4px;
                text-align: center;
                height: 24px;
                vertical-align: middle;
                white-space: normal;
                word-break: break-word;
            `;

            // âœ… Tab í‚¤ ì´ë™ ì´ë²¤íŠ¸ ì¶”ê°€ ìœ„ì¹˜ (ì—¬ê¸°!)
            td.addEventListener("keydown", (event) => {
  if (event.key === "Tab") {
    event.preventDefault();

    const currentRow = parseInt(td.dataset.row, 10);
    const currentCol = parseInt(td.dataset.col, 10);
    const table = td.closest("table");  // âœ… í˜„ì¬ ë§ˆì»¤ ë‚´ë¶€ì˜ ì´ í…Œì´ë¸” ì•ˆì—ì„œë§Œ

    let nextCell = table.querySelector(`td[data-row='${currentRow}'][data-col='${currentCol + 1}']`);

    // ë‹¤ìŒ ì—´ì´ ì—†ìœ¼ë©´ ë‹¤ìŒ í–‰ì˜ ì²« ë²ˆì§¸ ì—´
    if (!nextCell) {
      nextCell = table.querySelector(`td[data-row='${currentRow + 1}'][data-col='0']`);
    }

    // âœ… í•´ë‹¹ í…Œì´ë¸” ì•ˆì— ì¡´ì¬í•˜ëŠ” ì…€ë§Œ focus
    if (nextCell) {
      nextCell.focus();
    }
  }
});



            tr.appendChild(td);
        }

        table.appendChild(tr);
    });

    return table.outerHTML;
}



// âœ… IndexedDBì— í…Œì´ë¸” ë°ì´í„° ì €ì¥ (tableContainerê°€ ì—†ì„ ê²½ìš° ë³µêµ¬)
function saveTableToIndexedDB(id, tableContainer) {
    if (!tableContainer) {
        console.warn(`âš ï¸ [saveTableToIndexedDB] tableContainerê°€ ì—†ìŠµë‹ˆë‹¤. ID: ${id || "undefined"}`);
        return;
    }

    // âœ… ì´ë¯¸ ì €ì¥ ì¤‘ì¸ì§€ ì²´í¬í•˜ì—¬ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (window.isSaving) {
        console.warn("âš ï¸ IndexedDB ì €ì¥ ì¤‘, ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€");
        return;
    }
    window.isSaving = true;  // âœ… ì €ì¥ ì¤‘ ìƒíƒœ í”Œë˜ê·¸ ì„¤ì •

    let tableData = [];
    tableContainer.querySelectorAll("tr").forEach(row => {
        let rowData = [];
        row.querySelectorAll("td").forEach(td => {
            rowData.push(td.textContent.trim());
        });
        tableData.push(rowData.join('\t'));
    });

    // âœ… IndexedDBì—ì„œ ê¸°ì¡´ ìƒ‰ìƒ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ ìœ ì§€
    getFromIndexedDB(id, "ì‹œì„¸1").then(existingData => {
        let existingColor = existingData?.color || "#9F9F9F"; // âœ… ê¸°ì¡´ ë°°ê²½ìƒ‰ ìœ ì§€
        let existingTextColor = existingData?.textColor || "#ffffff"; // âœ… ê¸°ì¡´ ê¸€ììƒ‰ ìœ ì§€
        let existingFontSize = existingData?.fontSize || "12px"; // âœ… ê¸°ì¡´ í°íŠ¸ í¬ê¸° ìœ ì§€

        saveToIndexedDB(id, "ì‹œì„¸1", tableData.join('\n'), existingColor, existingTextColor, existingFontSize);
    }).catch(error => {
        console.error("âŒ IndexedDB ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", error);
    }).finally(() => {
        setTimeout(() => {
            window.isSaving = false;  // âœ… ì¼ì • ì‹œê°„ í›„ ë‹¤ì‹œ ì €ì¥ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
        }, 100);
    });
}




// âœ… ì…€ ì‚­ì œ í•¨ìˆ˜ ìˆ˜ì • (ì‚­ì œ í›„ ì˜¤ë¥˜ ë°©ì§€)
function deleteSelectedCells() {
    if (!selectedCells || selectedCells.size === 0) {
        console.warn("âš ï¸ ì„ íƒëœ ì…€ì´ ì—†ìŒ");
        return;
    }

    selectedCells.forEach(td => {
        if (td && td instanceof HTMLElement) {
            td.textContent = ""; // âœ… ë‚´ìš©ë§Œ ì‚­ì œ
        }
    });

    // â— activeMarkerElementê°€ ì—†ì„ ê²½ìš° ë³µêµ¬ ì‹œë„
    if (!activeMarkerElement && selectedCells.size > 0) {
        let firstCell = Array.from(selectedCells)[0];
        activeMarkerElement = firstCell.closest(".siseMapMarker");
    }

    if (activeMarkerElement) {
        let tableContainer = activeMarkerElement.querySelector(".tableContainer");
        let id = activeMarkerElement.dataset.apartmentId;

        if (!id || id === "undefined") {
            console.warn("âš ï¸ ì‚­ì œ í›„ ì €ì¥í•  IDê°€ ì—†ìŒ.");
            return;
        }

        if (tableContainer) {
            // âœ… ë¶ˆí•„ìš”í•œ setTimeout ì œê±° (ì¦‰ì‹œ ì €ì¥)
            saveTableToIndexedDB(id, tableContainer);
        } else {
            console.warn("âš ï¸ tableContainer ì°¾ì„ ìˆ˜ ì—†ìŒ");
        }
    } else {
        console.warn("âš ï¸ activeMarkerElementê°€ ì—†ìŒ");
    }
}

// âœ… ì…€ì„ ìˆ˜ì • ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì • + IME í•œê¸€ ì…ë ¥ ì²˜ë¦¬ (ì¤‘ë³µ ë°©ì§€)
function makeTableEditable(tableContainer) {
    let isComposing = false; // âœ… í•œê¸€ ì…ë ¥ ì¤‘ì¸ì§€ í™•ì¸
    let lastFocusedTd = null; // âœ… ë§ˆì§€ë§‰ìœ¼ë¡œ í¬ì»¤ìŠ¤ëœ ì…€ ì €ì¥

    tableContainer.querySelectorAll("td").forEach(td => {
        // âœ… ê¸°ì¡´ ì´ë²¤íŠ¸ ì œê±° (ì¤‘ë³µ ë°©ì§€)
        td.removeEventListener("click", handleTdClick);
        td.removeEventListener("compositionstart", handleCompositionStart);
        td.removeEventListener("compositionend", handleCompositionEnd);
        //td.removeEventListener("keydown", handleKeyDown);
        td.removeEventListener("blur", handleTdBlur);
        td.removeEventListener("paste", handlePaste);

        // âœ… ìƒˆë¡œìš´ ì´ë²¤íŠ¸ ì¶”ê°€
        td.addEventListener("click", handleTdClick);
        td.addEventListener("compositionstart", handleCompositionStart);
        td.addEventListener("compositionend", handleCompositionEnd);
        //td.addEventListener("keydown", handleKeyDown);
        td.addEventListener("blur", handleTdBlur);
        td.addEventListener("paste", handlePaste);
    });

    // âœ… í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ì…€ì„ í´ë¦­í•˜ë©´ í¸ì§‘ ê°€ëŠ¥)
    function handleTdClick(event) {
		const td = event.target;
		td.setAttribute("contenteditable", "true");
		td.focus();
		lastFocusedTd = td;

		// âœ… ì»¤ì„œë¥¼ ì œì¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê¸°
		const range = document.createRange();
		const selection = window.getSelection();

		range.selectNodeContents(td);
		range.collapse(false); // false â†’ ì»¤ì„œë¥¼ ëìœ¼ë¡œ ë³´ëƒ„
		selection.removeAllRanges();
		selection.addRange(range);
	}


    // âœ… í•œê¸€ ì…ë ¥ ì‹œì‘ (IME ì…ë ¥ ê°ì§€)
    function handleCompositionStart() {
        isComposing = true;
    }

    // âœ… í•œê¸€ ì…ë ¥ ì™„ë£Œ (í¬ì»¤ìŠ¤ ìœ ì§€ ì¤‘ì´ë©´ ì €ì¥ ì•ˆ í•¨)
    function handleCompositionEnd(event) {
    isComposing = false; // âœ… ì¡°í•© ì¢…ë£Œ í”Œë˜ê·¸
    setTimeout(() => {
        saveTableToIndexedDB(event.target.dataset.id, event.target.closest(".tableContainer"));
    }, 50);
}


    

    // âœ… í¬ì»¤ìŠ¤ ì•„ì›ƒ ì‹œ ì €ì¥ (IME ì…ë ¥ ì¤‘ì´ë©´ ì €ì¥ ë°©ì§€)
    function handleTdBlur(event) {
        setTimeout(() => {
            if (isComposing) return; // âœ… IME ì…ë ¥ ì¤‘ì´ë©´ blur ì €ì¥ ë°©ì§€
            isComposing = false; // âœ… í¬ì»¤ìŠ¤ê°€ ì•„ì›ƒë˜ì—ˆì„ ë•Œ ì…ë ¥ ì¢…ë£Œ
            saveTableToIndexedDB(event.target.dataset.id, event.target.closest(".tableContainer"));
        }, 50);
    }

    // âœ… ë¶™ì—¬ë„£ê¸° ì´ë²¤íŠ¸ (ë¶™ì—¬ë„£ê¸° í›„ ì¦‰ì‹œ ì €ì¥)
     function handlePaste(event) {
        event.preventDefault();
        let clipboardData = event.clipboardData || window.clipboardData;
        let pastedText = clipboardData.getData("text");

        if (!pastedText.includes("\t") && !pastedText.includes("\n")) {
            // âœ… ì¼ë°˜ í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê¸°
            document.execCommand("insertText", false, pastedText);
            return;
        }

        // âœ… ì—‘ì…€ì—ì„œ ë³µì‚¬í•œ ë°ì´í„°ë¥¼ í…Œì´ë¸”ì— ë§ì¶° ì‚½ì…
        let rows = pastedText.split("\n").map(row => row.split("\t"));
        let startRow = parseInt(lastFocusedTd.dataset.row, 10);
        let startCol = parseInt(lastFocusedTd.dataset.col, 10);
        let table = lastFocusedTd.closest("table");

        rows.forEach((row, rowIndex) => {
            row.forEach((cellText, colIndex) => {
                let targetRow = startRow + rowIndex;
                let targetCol = startCol + colIndex;
                let targetCell = table.querySelector(`td[data-row="${targetRow}"][data-col="${targetCol}"]`);
                
                if (targetCell) {
                    targetCell.textContent = cellText.trim();
                }
            });
        });

        // âœ… ì €ì¥
        saveTableToIndexedDB(lastFocusedTd.dataset.id, lastFocusedTd.closest(".tableContainer"));
    }

/*
    // âœ… í…Œì´ë¸” ë„ˆë¹„ ì¡°ì •
    setTimeout(() => {
        adjustTableColumnWidths(tableContainer.querySelector("table"));
    }, 100);
*/    
    //enableArrowKeyNavigation(tableContainer);
    enableMultiCellSelection(tableContainer);
}



// âœ… í…Œì´ë¸”ì„ ìˆ˜ì • ê°€ëŠ¥í•˜ë„ë¡ ì´ë²¤íŠ¸ ì¶”ê°€ (ë°©í–¥í‚¤ ì´ë™ í¬í•¨)
// âœ… í…Œì´ë¸” ì…€ì˜ ë„ˆë¹„ë¥¼ ë™ì ìœ¼ë¡œ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜
// âœ… í…Œì´ë¸”ì˜ ê° ì—´ ë„ˆë¹„ë¥¼ ë™ì ìœ¼ë¡œ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜
// âœ… í…Œì´ë¸”ì˜ ê° ì—´ ë„ˆë¹„ë¥¼ ë°ì´í„° ê¸¸ì´ì— ë§ê²Œ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜
function adjustTableColumnWidths(table) {
    let colWidths = [];
    let totalWidth = 190; // âœ… í…Œì´ë¸” ì „ì²´ ë„ˆë¹„ (ê¸°ë³¸ê°’)
    let minWidth = 30;    // âœ… ìµœì†Œ ì—´ ë„ˆë¹„
    let maxWidth = 100;   // âœ… ìµœëŒ€ ì—´ ë„ˆë¹„

    // 1ï¸âƒ£ ê° ì—´ì˜ ìµœëŒ€ í…ìŠ¤íŠ¸ ê¸¸ì´ ê³„ì‚°
    table.querySelectorAll("tr").forEach(row => {
        row.querySelectorAll("td").forEach((cell, colIndex) => {
            let contentWidth = getTextWidth(cell.textContent.trim(), window.getComputedStyle(cell).font);
            colWidths[colIndex] = Math.max(colWidths[colIndex] || minWidth, contentWidth + 10); // ğŸ”¹ íŒ¨ë”© ì¶”ê°€
        });
    });

    // 2ï¸âƒ£ ê°€ì¥ ê¸´ ì—´ ì°¾ê¸°
    let totalContentWidth = colWidths.reduce((sum, w) => sum + w, 0);
    let scaleFactor = totalWidth / totalContentWidth;

    // 3ï¸âƒ£ ë¹„ìœ¨ì— ë§ì¶° ì—´ ë„ˆë¹„ ì¡°ì • (ìµœëŒ€ ë„ˆë¹„ ì œí•œ)
    colWidths = colWidths.map(w => Math.min(maxWidth, Math.max(minWidth, Math.floor(w * scaleFactor))));

    // 4ï¸âƒ£ ê° ì—´ì— ê³„ì‚°ëœ ë„ˆë¹„ ì ìš©
    table.querySelectorAll("tr").forEach(row => {
        row.querySelectorAll("td").forEach((cell, colIndex) => {
            cell.style.minWidth = colWidths[colIndex] + "px"; // âœ… ìµœì†Œ ë„ˆë¹„ ì ìš©
            cell.style.maxWidth = colWidths[colIndex] + "px"; // âœ… ìµœëŒ€ ë„ˆë¹„ ì ìš©
            cell.style.wordBreak = "break-word"; // âœ… í…ìŠ¤íŠ¸ê°€ ê¸¸ë©´ ìë™ ì¤„ë°”ê¿ˆ
        });
    });
}


// âœ… í…ìŠ¤íŠ¸ì˜ ì‹¤ì œ í”½ì…€ ë„ˆë¹„ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
function getTextWidth(text, font) {
    let canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    let context = canvas.getContext("2d");
    context.font = font || "12px Arial";
    return context.measureText(text).width;
}


// âœ… í˜„ì¬ ì„ íƒëœ ì…€ ëª©ë¡
let selectedCells = new Set();
let lastSelectedCell = null;

// âœ… ì…€ ì„ íƒ ê¸°ëŠ¥ (Shift í‚¤ ì§€ì›)
function enableMultiCellSelection(tableContainer) {
    let isMouseDown = false;

    // âœ… ê¸°ì¡´ ì´ë²¤íŠ¸ ì œê±° (ì¤‘ë³µ ë°©ì§€)
    document.removeEventListener("mouseup", handleMouseUp);
    //document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("click", handleOutsideClick);

    // âœ… ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¬ë“±ë¡
    document.addEventListener("mouseup", handleMouseUp);
    //document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("click", handleOutsideClick);

    tableContainer.querySelectorAll("td").forEach(td => {
        td.addEventListener("mousedown", function(event) {
            event.preventDefault();
            isMouseDown = true;

            if (event.shiftKey && lastSelectedCell) {
                selectRangeCells(lastSelectedCell, td, tableContainer);
            } else {
                clearSelectedCells();
                toggleCellSelection(td);
                lastSelectedCell = td;
            }
        });

        td.addEventListener("mouseover", function(event) {
            if (isMouseDown) {
                if (event.shiftKey && lastSelectedCell) {
                    selectRangeCells(lastSelectedCell, td, tableContainer);
                } else {
                    clearSelectedCells();
                    toggleCellSelection(td);
                }
            }
        });

        td.addEventListener("mouseup", function() {
            isMouseDown = false;
        });

        td.addEventListener("click", function(event) {
            event.stopPropagation();
        });
    });
}

// âœ… ë§ˆìš°ìŠ¤ ì—… ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ì¤‘ë³µ ë°©ì§€)
function handleMouseUp() {
    isMouseDown = false;
}
function handleKeyDown(event) {
    const activeElement = document.activeElement;
console.log("activeMarker :")
console.log(activeMarker)

	// âœ… case 2: ì§€ë„ ë§ˆì»¤ ì´ë™ìš© WASD

    if (activeMarker) {
        let position = activeMarker.getPosition();
        let lat = position.lat();
        let lng = position.lng();
        let step = 0.0004;

        switch (event.key) {
            case "w": case "ã…ˆ": lat += step; break;
            case "s": case "ã„´": lat -= step; break;
            case "a": case "ã…": lng -= step; break;
            case "d": case "ã…‡": lng += step; break;
            case "Escape":
                updateMarkerSelection(activeMarkerElement, false);
                activeMarker = null;
                activeMarkerElement = null;
                return;
            default:
                return;
        }

        let newPosition = new naver.maps.LatLng(lat, lng);
console.log(newPosition);
        activeMarker.setPosition(newPosition);
    }

    // âœ… case 1: í…Œì´ë¸” ì…€ ì•ˆì—ì„œ í‚¤ë³´ë“œ ì´ë²¤íŠ¸
    if (activeElement && activeElement.tagName === "TD") {
        // IME í•œê¸€ ì…ë ¥ ì¤‘ì´ë©´ ë¬´ì‹œ
        if (window.isComposing) return;

        const tableContainer = activeElement.closest(".tableContainer");
        const currentRow = parseInt(activeElement.dataset.row, 10);
        const currentCol = parseInt(activeElement.dataset.col, 10);
        const table = tableContainer.querySelector("table");

        switch (event.key) {
            case "ArrowUp":
                event.preventDefault();
                moveToCell(table, currentRow - 1, currentCol);
                return;
            case "ArrowDown":
                event.preventDefault();
                moveToCell(table, currentRow + 1, currentCol);
                return;
            case "ArrowLeft":
                event.preventDefault();
                moveToCell(table, currentRow, currentCol - 1);
                console.log("ì™¼ìª½");
                return;
            case "ArrowRight":
                event.preventDefault();
                moveToCell(table, currentRow, currentCol + 1);
                console.log("ì˜¤ë¥¸ìª½");
                return;
            case "Delete":
            case "Backspace":
                if (selectedCells.size > 1) {
                    event.preventDefault();
                    deleteSelectedCells();
                }
                return;
        }

        // âœ… Ctrl+C ë˜ëŠ” Cmd+C ë³µì‚¬ ì²˜ë¦¬
        if ((event.ctrlKey || event.metaKey) && event.key === "c") {
            if (selectedCells.size > 0) {
                event.preventDefault();

                const cellsArray = Array.from(selectedCells);
                cellsArray.sort((a, b) => {
                    const rowA = parseInt(a.dataset.row, 10);
                    const rowB = parseInt(b.dataset.row, 10);
                    if (rowA !== rowB) return rowA - rowB;
                    return parseInt(a.dataset.col, 10) - parseInt(b.dataset.col, 10);
                });

                const maxRow = Math.max(...cellsArray.map(td => parseInt(td.dataset.row)));
                const minRow = Math.min(...cellsArray.map(td => parseInt(td.dataset.row)));
                const maxCol = Math.max(...cellsArray.map(td => parseInt(td.dataset.col)));
                const minCol = Math.min(...cellsArray.map(td => parseInt(td.dataset.col)));

                const rowCount = maxRow - minRow + 1;
                const colCount = maxCol - minCol + 1;
                const grid = Array.from({ length: rowCount }, () => Array(colCount).fill(""));

                cellsArray.forEach(td => {
                    const r = parseInt(td.dataset.row) - minRow;
                    const c = parseInt(td.dataset.col) - minCol;
                    grid[r][c] = td.textContent.trim();
                });

                const tsv = grid.map(row => row.join("\t")).join("\n");

                navigator.clipboard.writeText(tsv).then(() => {
                    console.log("âœ… ì…€ ë³µì‚¬ ì™„ë£Œ");
                }).catch(err => {
                    console.error("âŒ í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:", err);
                });
            }
        }
    }

    
}



// âœ… ë§ˆì»¤ ì™¸ë¶€ í´ë¦­ ì‹œ ë¸”ë¡ í•´ì œ (ì¤‘ë³µ ë°©ì§€)
function handleOutsideClick(event) {
    if (!event.target.closest(".siseMapMarker")) {
        clearSelectedCells();
    }
}

function clearSelectedCells() {
    if (!selectedCells) return;
    selectedCells.forEach(cell => {
        cell.style.backgroundColor = ""; // âœ… ê¸°ì¡´ ì„ íƒ í•´ì œ
    });
    selectedCells.clear(); // âœ… Set ì´ˆê¸°í™”
}


// âœ… ë²”ìœ„ ì„ íƒ ê¸°ëŠ¥ (Shift í‚¤ ì‚¬ìš©)
function selectRangeCells(startCell, endCell, tableContainer) {
    let table = tableContainer.querySelector("table");
    let startRow = parseInt(startCell.dataset.row);
    let startCol = parseInt(startCell.dataset.col);
    let endRow = parseInt(endCell.dataset.row);
    let endCol = parseInt(endCell.dataset.col);

    let minRow = Math.min(startRow, endRow);
    let maxRow = Math.max(startRow, endRow);
    let minCol = Math.min(startCol, endCol);
    let maxCol = Math.max(startCol, endCol);

    selectedCells.clear();

    for (let row = minRow; row <= maxRow; row++) {
        for (let col = minCol; col <= maxCol; col++) {
            let targetCell = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
            if (targetCell) {
                selectedCells.add(targetCell);
                targetCell.style.backgroundColor = "#FFD700"; // âœ… ë…¸ë€ìƒ‰ ë¸”ë¡ í‘œì‹œ
            }
        }
    }
}

// âœ… ì…€ ì„ íƒ/í•´ì œ ê¸°ëŠ¥ (Shift ë¯¸ì‚¬ìš© ì‹œ ë‹¨ì¼ ì„ íƒ)
function toggleCellSelection(td) {
    if (selectedCells.has(td)) {
        selectedCells.delete(td);
        td.style.backgroundColor = ""; // âœ… ì„ íƒ í•´ì œ
    } else {
        selectedCells.add(td);
        td.style.backgroundColor = "#FFD700"; // âœ… ë…¸ë€ìƒ‰ ë¸”ë¡ ì§€ì •
    }
}


function enableArrowKeyNavigation(tableContainer) {
    const table = tableContainer.querySelector("table");
    if (!table) return;

    // âœ… ê¸°ì¡´ td ì´ë²¤íŠ¸ ì œê±°
    table.querySelectorAll("td").forEach(td => {
        td.removeEventListener("keydown", handleArrowKey); // ì¤‘ë³µ ì œê±°
        td.addEventListener("keydown", handleArrowKey);     // ìƒˆë¡œ ë“±ë¡
    });
}

function handleArrowKey(event) {
    const td = event.currentTarget;
    const currentRow = parseInt(td.dataset.row, 10);
    const currentCol = parseInt(td.dataset.col, 10);
    const table = td.closest("table");

    switch (event.key) {
        case "ArrowUp":
            event.preventDefault();
            moveToCell(table, currentRow - 1, currentCol);
            break;
        case "ArrowDown":
            event.preventDefault();
            moveToCell(table, currentRow + 1, currentCol);
            break;
        case "ArrowLeft":
            event.preventDefault();
            moveToCell(table, currentRow, currentCol - 1);
console.log("ì™¼ìª½");
            break;
        case "ArrowRight":
            event.preventDefault();
            moveToCell(table, currentRow, currentCol + 1);
console.log("ì˜¤ë¥¸ìª½");
            break;
        case "Delete":
        case "Backspace":
            if (selectedCells && selectedCells.size > 1) {
                event.preventDefault();
                deleteSelectedCells();
            }
            break;
    }
}
function moveToCell(table, row, col) {
    console.log("â¡ moveToCell í˜¸ì¶œ:", row, col);

    let maxRows = table.rows.length;
    let maxCols = table.rows[0].cells.length;

    if (row < 0 || row >= maxRows || col < 0 || col >= maxCols) {
        console.warn(`âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë™ ìœ„ì¹˜: row=${row}, col=${col}`);
        return;
    }

    let targetCell = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
    console.log("ğŸ¯ targetCell:", targetCell);

    if (targetCell) {
        targetCell.setAttribute("contenteditable", "true");
        setTimeout(() => {
            targetCell.focus();

            // âœ… ì»¤ì„œë¥¼ í…ìŠ¤íŠ¸ ëìœ¼ë¡œ ì´ë™
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(targetCell);
            range.collapse(false); // ëìœ¼ë¡œ ì´ë™
            selection.removeAllRanges();
            selection.addRange(range);
        }, 10);
    }
}






function rgbToHex(rgb) {
    let rgbArray = rgb.match(/\d+/g);
    if (!rgbArray || rgbArray.length < 3) return "#000000"; // ê¸°ë³¸ê°’

    return `#${rgbArray
        .slice(0, 3)
        .map(x => parseInt(x).toString(16).padStart(2, "0"))
        .join("")}`.toUpperCase();
}

function showColorPickerModal(apartmentId, defaultColor, defaultTextColor, defaultFontSize, callback) {

    // âœ… ê¸°ì¡´ ëª¨ë‹¬ ì œê±° (ì¤‘ë³µ ë°©ì§€)
    const existingModal = document.querySelector('.custom-modal-siseMap');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    // âœ… RGB ìƒ‰ìƒì´ ë“¤ì–´ì˜¤ë©´ HEXë¡œ ë³€í™˜
    if (defaultColor.startsWith("rgb")) defaultColor = rgbToHex(defaultColor);
    if (defaultTextColor.startsWith("rgb")) defaultTextColor = rgbToHex(defaultTextColor);

    // âœ… ëª¨ë‹¬ ìƒì„±
    const modal = document.createElement('div');
    modal.className = 'custom-modal-siseMap';
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = 'white';
    modal.style.border = '1px solid #ccc';
    modal.style.padding = '20px';
    modal.style.zIndex = '10000';
    modal.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
    modal.style.width = '300px';

    makeModalDraggable(modal);

    // âœ… ìƒ‰ìƒ ì„ íƒ ë¸”ë¡ ì¶”ê°€ (14ê°œ)
    const colorDiv = document.createElement('div');
    colorDiv.className = 'color-div';
    colorDiv.style.display = 'flex';
    colorDiv.style.flexWrap = 'wrap';
    colorDiv.style.marginTop = '10px';

    const colors = ['#000000', '#454648', '#474C4F', '#FF0000', '#FF6600', '#FFFF00', 
                    '#92D050', '#00B050', '#00B0F0', '#0070C0', '#000099', '#7030A0', 
                    '#CC3399', '#FF66CC'];

    colors.forEach(color => {
        const smallSquare = document.createElement('div');
        smallSquare.className = 'small-square';
        smallSquare.style.backgroundColor = color;
        smallSquare.style.width = '24px';
        smallSquare.style.height = '24px';
        smallSquare.style.margin = '2px';
        smallSquare.style.cursor = 'pointer';
        smallSquare.style.border = '1px solid #000';

        // âœ… ë¸”ë¡ í´ë¦­ ì‹œ ë°°ê²½ìƒ‰ ë³€ê²½
        smallSquare.onclick = () => {
            colorInput.value = color;
            colorPicker.value = color;
        };

        colorDiv.appendChild(smallSquare);
    });

    modal.appendChild(colorDiv);

    // âœ… ë°°ê²½ìƒ‰ ì„ íƒ (ì»¬ëŸ¬ ì„ íƒê¸° + ì§ì ‘ ì…ë ¥)
    const colorPickerWrapper = document.createElement('div');
    colorPickerWrapper.className = 'color-picker-wrapper';

    const colorPickerLabel = document.createElement('label');
    colorPickerLabel.textContent = 'ë°°ê²½ìƒ‰ : ';
    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = defaultColor || '#1C32F7';

    const colorInput = document.createElement('input');
    colorInput.type = 'text';
    colorInput.className = 'color-input';
    colorInput.placeholder = 'ìƒ‰ìƒê°’ ì…ë ¥ #000000';
    colorInput.value = defaultColor || '#1C32F7';
    colorInput.style.width = '80px';
    colorInput.style.marginTop = '0px';

    colorPicker.oninput = () => {
        colorInput.value = colorPicker.value.toUpperCase();
    };

    colorPickerWrapper.appendChild(colorPickerLabel);
    colorPickerWrapper.appendChild(colorPicker);
    colorPickerWrapper.appendChild(colorInput);

    modal.appendChild(colorPickerWrapper);

    colorInput.addEventListener('input', () => {
        if (/^#[0-9A-F]{6}$/i.test(colorInput.value)) {
            colorPicker.value = colorInput.value.toUpperCase();
        }
    });

    // âœ… ê¸€ììƒ‰ ì„ íƒ (ì»¬ëŸ¬ ì„ íƒê¸° + ì§ì ‘ ì…ë ¥)
    const textColorPickerWrapper = document.createElement('div');
    textColorPickerWrapper.className = 'color-picker-wrapper';

    const textColorPickerLabel = document.createElement('label');
    textColorPickerLabel.textContent = 'ê¸€ììƒ‰ : ';
    const textColorPicker = document.createElement('input');
textColorPicker.type = 'color';
defaultTextColor = defaultTextColor?.trim() || '#FFFFFF'; // âœ… ê¸°ë³¸ê°’ ê°•ì œ ì ìš©
textColorPicker.value = defaultTextColor;


const textColorInput = document.createElement('input');
textColorInput.type = 'text';
textColorInput.className = 'color-input';
textColorInput.placeholder = 'ìƒ‰ìƒê°’ ì…ë ¥ #FFFFFF';
textColorInput.value = defaultTextColor;

    textColorInput.style.width = '80px';
    textColorInput.style.marginTop = '0px';

    textColorPicker.oninput = () => {
        textColorInput.value = textColorPicker.value.toUpperCase();
    };

    textColorInput.addEventListener('input', () => {
        if (/^#[0-9A-F]{6}$/i.test(textColorInput.value)) {
            textColorPicker.value = textColorInput.value.toUpperCase();
        }
    });

    textColorPickerWrapper.appendChild(textColorPickerLabel);
    textColorPickerWrapper.appendChild(textColorPicker);
    textColorPickerWrapper.appendChild(textColorInput);

    modal.appendChild(textColorPickerWrapper);

    // âœ… ê¸€ì í¬ê¸° ì¡°ì ˆ
    const fontSizeWrapper = document.createElement('div');
    fontSizeWrapper.className = 'font-size-wrapper';

    const fontSizeLabel = document.createElement('label');
    fontSizeLabel.textContent = 'ê¸€ì í¬ê¸° : ';
    const fontSizeInput = document.createElement('input');
    fontSizeInput.type = 'number';
    fontSizeInput.className = 'font-size-input';
    fontSizeInput.value = parseInt(defaultFontSize) || '13';
    fontSizeInput.style.width = '80px';

    fontSizeWrapper.appendChild(fontSizeLabel);
    fontSizeWrapper.appendChild(fontSizeInput);

    modal.appendChild(fontSizeWrapper);



const rowButtonContainer = document.createElement('div');
    rowButtonContainer.style.marginTop = '10px';


    // âœ… ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '10px';
    buttonContainer.style.textAlign = 'right';

    const saveButton = document.createElement('button');
    saveButton.textContent = ' í™•ì¸ ';
    saveButton.style.marginRight = '10px';
		saveButton.onclick = () => {
		updateMarkerStyleAndSave(apartmentId, colorInput.value, textColorInput.value, fontSizeInput.value + 'px');
		closePopup();
		document.body.removeChild(modal);
	};

 const addRowButton = document.createElement('button');
    addRowButton.textContent = 'í–‰ ì¶”ê°€';
    addRowButton.onclick = () => addRowToTable(apartmentId);
    rowButtonContainer.appendChild(addRowButton);

    const removeRowButton = document.createElement('button');
    removeRowButton.textContent = 'í–‰ ì œê±°';
    removeRowButton.onclick = () => removeRowFromTable(apartmentId);
    rowButtonContainer.appendChild(removeRowButton);

    modal.appendChild(rowButtonContainer);



const resetButton = document.createElement('button');
resetButton.textContent = ' ì´ˆê¸°í™” ';
resetButton.style.marginRight = '10px';
resetButton.onclick = () => {
    // âœ… IndexedDBì—ì„œ í•´ë‹¹ ë°ì´í„° ì‚­ì œ
    const request = indexedDB.open("hongbu", 5);
    request.onsuccess = function(event) {
        const db = event.target.result;
        const transaction = db.transaction(["apartments"], "readwrite");
        const store = transaction.objectStore("apartments");
        store.delete(`${apartmentId}-ì‹œì„¸1`);
        transaction.oncomplete = () => {
            console.log("âœ… ì´ˆê¸°í™” ì™„ë£Œ (IndexedDB ì‚­ì œë¨)");
            db.close(); // âœ… DB ì—°ê²° ì •ë¦¬

            // âœ… ë§ˆì»¤ ìŠ¤íƒ€ì¼ë„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
            const markerElement = document.querySelector(`[data-apartment-id='${apartmentId}']`);
            if (markerElement) {
                markerElement.style.backgroundColor = "#9F9F9F";
                markerElement.style.color = "#ffffff";
                markerElement.style.fontSize = "12px";

                const tableContainer = markerElement.querySelector(".tableContainer");
                if (tableContainer) {
                    tableContainer.innerHTML = createEditableTableHTML(apartmentId, generateDefaultTable());
                    makeTableEditable(tableContainer);
                }
            }

            // âœ… ëª¨ë‹¬ ë‹«ê¸°
            closePopup();
            document.body.removeChild(modal);
        };
    };
};

buttonContainer.appendChild(resetButton);  // â¬… ì´ˆê¸°í™” ë²„íŠ¼ ë¨¼ì €
    buttonContainer.appendChild(saveButton);

    const cancelButton = document.createElement('button');
    cancelButton.textContent = ' ë‹«ê¸° ';
    cancelButton.onclick = () => {
        document.body.removeChild(modal);
        closePopup();
    };
    buttonContainer.appendChild(cancelButton);

    modal.appendChild(buttonContainer);

    // âœ… ëª¨ë‹¬ì„ bodyì— ì¶”ê°€
    document.body.appendChild(modal);



}

function parseTextToTable(text) {
  return text
    .trim()
    .split("\n")
    .map(row => row.split("\t"));
}

function convertTableToText(tableArray) {
  return tableArray.map(row => row.join("\t")).join("\n");
}


function addRowToTable(apartmentId) {
    const tableContainer = document.querySelector(`[data-apartment-id='${apartmentId}'] .tableContainer`);
    if (tableContainer) {
        const table = tableContainer.querySelector("table");

        if (table) {
            const newRow = table.insertRow();
            const rowIndex = table.rows.length - 1;

            for (let colIndex = 0; colIndex < 4; colIndex++) {  // ì—´ ìˆ˜ ê³ ì •
                const newCell = newRow.insertCell();
                newCell.className = "sise-cell";  // âœ… ìŠ¤íƒ€ì¼ í´ë˜ìŠ¤ë§Œ ì ìš©
                newCell.contentEditable = "true";
                newCell.dataset.row = rowIndex;
                newCell.dataset.col = colIndex;
                newCell.dataset.id = apartmentId;

                // ì´ë²¤íŠ¸ ë°”ì¸ë”©
                newCell.addEventListener("input", () => {
                    newCell.style.backgroundColor = "#ffe"; // ë³€ê²½ ê°ì§€ìš© ì„ì‹œ ìŠ¤íƒ€ì¼
                });

                newCell.addEventListener("blur", () => {
                    const value = newCell.innerText.trim();
                    const row = parseInt(newCell.dataset.row, 10);
                    const col = parseInt(newCell.dataset.col, 10);

                    getFromIndexedDB(apartmentId, "ì‹œì„¸1").then(existing => {
                        const text = existing?.text || "";
                        const parsed = parseTextToTable(text);

                        while (parsed.length <= row) parsed.push(["", "", "", ""]);
                        while (parsed[row].length < 4) parsed[row].push("");

                        parsed[row][col] = value;

                        const newText = convertTableToText(parsed);
                        saveToIndexedDB(apartmentId, "ì‹œì„¸1", newText, existing?.color, existing?.textColor, existing?.fontSize);
                    });
                });
            }

            saveTableToIndexedDB(apartmentId, tableContainer);
        }
    }
}


/*
function addRowToTable(apartmentId) {
    // í•´ë‹¹ apartmentIdì˜ í…Œì´ë¸”ì„ ì°¾ì•„ì„œ ìƒˆë¡œìš´ í–‰ ì¶”ê°€
    const tableContainer = document.querySelector(`[data-apartment-id='${apartmentId}'] .tableContainer`);
    if (tableContainer) {
        const table = tableContainer.querySelector("table");

        if (table) {
            const newRow = table.insertRow();
            // ê° ì…€ì— ê¸°ë³¸ê°’ ì¶”ê°€ (ì˜ˆ: ë¹ˆ í…ìŠ¤íŠ¸)
            for (let i = 0; i < table.rows[0].cells.length; i++) {
                const newCell = newRow.insertCell();
                newCell.textContent = ""; // ê¸°ë³¸ì ìœ¼ë¡œ ë¹ˆ í…ìŠ¤íŠ¸
                newCell.style.border = "1px solid black";
                newCell.style.padding = "0px";
                newCell.style.textAlign = "center";
				newCell.style.height = "24px";
            }
			saveTableToIndexedDB(apartmentId, tableContainer);
        }
    }
}
*/
function removeRowFromTable(apartmentId) {
    // í•´ë‹¹ apartmentIdì˜ í…Œì´ë¸”ì„ ì°¾ì•„ì„œ ì„ íƒëœ í–‰ ì œê±°
    const tableContainer = document.querySelector(`[data-apartment-id='${apartmentId}'] .tableContainer`);
    if (tableContainer) {
        const table = tableContainer.querySelector("table");

        if (table && table.rows.length > 1) {
            // ë§ˆì§€ë§‰ í–‰ì„ ì‚­ì œ (ìµœì†Œ 1ê°œ í–‰ì´ ë‚¨ì•„ì•¼ í•˜ë¯€ë¡œ)
            table.deleteRow(table.rows.length - 1);
// âœ… ì‚­ì œ í›„ ë°”ë¡œ IndexedDBì— ì €ì¥
            saveTableToIndexedDB(apartmentId, tableContainer);
        }
    }
}

function parsePriceDataFromTable(tableContainer) {
    const rows = tableContainer.querySelectorAll("tr");
    const parsed = [];

    rows.forEach(row => {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 3) {
            const í‰í˜• = cells[0].textContent.trim();
            const ë§¤ë§¤ = parseFloat(cells[1].textContent.trim());
            const ì „ì„¸ = parseFloat(cells[2].textContent.trim());

            if (!isNaN(ë§¤ë§¤) && !isNaN(ì „ì„¸)) {
                parsed.push({ í‰í˜•, ë§¤ë§¤, ì „ì„¸ });
            }
        }
    });

    return parsed;
}

function renderPriceChart(container, data) {
    const canvas = document.createElement("canvas");
    canvas.width = 200;
    canvas.height = data.length * 25 + 20; // í‰í˜• ìˆ˜ì— ë”°ë¼ ë†’ì´ ì¡°ì •
    canvas.style.margin = "5px";

    const ctx = canvas.getContext("2d");

    const maxPrice = Math.max(...data.flatMap(d => [d.ë§¤ë§¤, d.ì „ì„¸]));
    const barMaxWidth = 80;

    data.forEach((d, i) => {
        const y = i * 25 + 20;
        const label = d.í‰í˜•;
        ctx.fillStyle = "#000";
        ctx.font = "12px sans-serif";
        ctx.fillText(label, 0, y);

        const saleWidth = (d.ë§¤ë§¤ / maxPrice) * barMaxWidth;
        const leaseWidth = (d.ì „ì„¸ / maxPrice) * barMaxWidth;

        ctx.fillStyle = "#ff4d4d"; // ë¹¨ê°„ìƒ‰ ë§¤ë§¤
        ctx.fillRect(40, y - 10, saleWidth, 8);

        ctx.fillStyle = "#4d79ff"; // íŒŒë€ìƒ‰ ì „ì„¸
        ctx.fillRect(40, y, leaseWidth, 8);
    });

    container.appendChild(canvas);
}

async function exportToJSON() {
    try {
        const db = await initIndexedDB();
        const transaction = db.transaction(['apartments'], 'readonly');
        const store = transaction.objectStore('apartments');
        const request = store.getAll();

        request.onsuccess = async function(event) {
            const data = event.target.result;
            const jsonData = JSON.stringify(data, null, 2);

            // ğŸ’¾ ì €ì¥í•  íŒŒì¼ ì´ë¦„
            const now = new Date();
            const formattedDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
            const formattedTime = `${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const defaultFilename = `í™ë¶€_ì‹œì„¸ì§€ë„_ë°±ì—…_${formattedDate}_${formattedTime}.json`;

            // âœ… showSaveFilePickerë¡œ ì €ì¥ ìœ„ì¹˜ ì„ íƒ
            const handle = await window.showSaveFilePicker({
                suggestedName: defaultFilename,
                types: [
                    {
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] }
                    }
                ]
            });

            const writable = await handle.createWritable();
            await writable.write(jsonData);
            await writable.close();

            console.log('âœ… ì €ì¥ ì™„ë£Œ:', handle.name);
            db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        };

        request.onerror = function(event) {
            console.error('âŒ Export transaction error: ', event.target.errorCode);
            db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        };
    } catch (error) {
        console.error('âŒ ì˜¤ë¥˜ ë°œìƒ:', error);
    }
}


function importFromJSON(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        const data = JSON.parse(event.target.result);

        initIndexedDB().then(db => {
            const transaction = db.transaction(['apartments'], 'readwrite');
            const store = transaction.objectStore('apartments');

            data.forEach(item => {
                // âœ… ëˆ„ë½ëœ í•„ë“œ ë³´ì™„
                if (!item.type) item.type = 'ì‹œì„¸1';
                if (!item.idType) item.idType = `${item.id}-${item.type}`;
                store.put(item);
            });

            transaction.oncomplete = function() {
				alert('âœ… ì‹œì„¸ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.');
                db.close(); // âœ… DB ì—°ê²° ì •ë¦¬

				// â— ì‹œì„¸ì§€ë„ í™œì„±í™” ìƒíƒœì¼ ê²½ìš°, ë§ˆì»¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
				if (document.getElementById("toggleSiseMap").checked && window.map) {
					prevSiseMapState = "ì´ˆê¸°í™”";
					updateMarkers(window.map.getBounds());
				}
			};


            transaction.onerror = function(event) {
                console.error('âŒ Import transaction error:', event.target.errorCode);
                db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
            };
        }).catch(error => {
            console.error('âŒ Failed to initialize hongbu DB:', error);
        });
    };

    reader.readAsText(file);
}


//ì‹œì„¸ì§€ë„ver2ì—ì„œ ì‹œì„¸ ê°€ì ¸ì˜¤ê¸°
function importFromSiseVer2JSON(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        const json = JSON.parse(event.target.result);
        const data = Array.isArray(json) ? json : json.apartments;

        if (!Array.isArray(data)) {
            alert("âŒ ìœ íš¨í•œ ì‹œì„¸ì§€ë„Ver2 ë°ì´í„°ê°€ ì•„ë‹™ë‹ˆë‹¤.");
            return;
        }

        initIndexedDB().then(db => {
            if (!db.objectStoreNames.contains('importSiseVer2')) {
                alert("âŒ 'importSiseVer2' ìŠ¤í† ì–´ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. DB ë²„ì „ì„ ì˜¬ë ¤ ìŠ¤í† ì–´ë¥¼ ìƒì„±í•˜ì„¸ìš”.");
                db.close();
                return;
            }

            const transaction = db.transaction(['importSiseVer2'], 'readwrite');
            const store = transaction.objectStore('importSiseVer2');

            data.forEach(item => {
                // âœ… ëˆ„ë½ëœ í•„ë“œ ë³´ì™„
                if (!item.type && item.idType?.includes('-')) {
                    item.type = item.idType.split("-")[1];
                }
                if (!item.id && item.idType?.includes('-')) {
                    item.id = item.idType.split("-")[0];
                }
                if (!item.type) item.type = 'ì‹œì„¸1';
                if (!item.idType) item.idType = `${item.id}-${item.type}`;
                store.put(item);
            });

            transaction.oncomplete = function() {
                alert('âœ… ì‹œì„¸ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.');
                db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
                // â— ì‹œì„¸ì§€ë„ í™œì„±í™” ìƒíƒœì¼ ê²½ìš°, ë§ˆì»¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            };

            transaction.onerror = function(event) {
                console.error('âŒ Import transaction error:', event.target.error);
                db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
            };
        }).catch(error => {
            console.error('âŒ Failed to initialize hongbu DB:', error);
        });
    };

    reader.readAsText(file);
}

// ğŸ” Ver2 ì‹œì„¸ í‘œì‹œìš© í•¨ìˆ˜

function showSiseVer2DataToggle(apartmentId) {
    const dbRequest = indexedDB.open("hongbu", 5);

    dbRequest.onsuccess = function(event) {
        const db = event.target.result;

        if (!db.objectStoreNames.contains("importSiseVer2")) return;

        const transaction = db.transaction(["importSiseVer2"], "readonly");
        const store = transaction.objectStore("importSiseVer2");

        const getAllRequest = store.getAll();

        getAllRequest.onsuccess = function(e) {
            const allItems = e.target.result;
            const matched = allItems.filter(
                item => item.id === apartmentId && item.type === "ì‹œì„¸1"
            );

            if (matched.length === 0) return;

            const container = document.getElementById("apartmentInfo");

            // âœ… ë²„íŠ¼ ìƒì„±
            const button = document.createElement("button");
            button.textContent = "ğŸ“Š ì‹œì„¸ì§€ë„Ver2 ì‹œì„¸ ë³´ê¸°";
            button.style.marginTop = "10px";
            button.style.padding = "6px 10px";
            button.style.fontSize = "14px";
            button.style.borderRadius = "4px";
            button.style.cursor = "pointer";
            button.style.border = "1px solid #aaa";
            button.style.backgroundColor = "#f7f7f7";

            container.appendChild(button);

            // âœ… í´ë¦­ ì‹œ í‘œ ë Œë”ë§
            button.addEventListener("click", (e) => {
				e.stopPropagation(); // âœ… ëª¨ë‹¬ ë‹«í˜ ë°©ì§€

				matched.forEach(item => {
					const parsed = item.text.trim().split("\n").map(row => row.trim()).filter(row => row);
					if (parsed.length === 0) return;

					const table = document.createElement("table");
					table.style.marginTop = "10px";
					table.innerHTML = `
						<tr style="background: #eee;">
							<th>í‰í˜•</th>
							<th>ë§¤ë§¤</th>
							<th>ì „ì„¸</th>
							<th>ë¹„ê³ </th>
						</tr>
					`;

					parsed.forEach(line => {
						const [pyeong, maemae, jeonse, etc = ""] = line.split("\t");
						const tr = document.createElement("tr");
						tr.innerHTML = `
							<td>${pyeong || ""}</td>
							<td>${maemae || ""}</td>
							<td>${jeonse || ""}</td>
							<td>${etc || ""}</td>
						`;
						table.appendChild(tr);
					});

					const label = document.createElement("div");
					label.textContent = "ğŸ“Š ì‹œì„¸ì§€ë„ Ver2 ë°ì´í„°";
					label.style.marginTop = "10px";
					label.style.fontWeight = "bold";
					label.style.color = "#333";

					container.appendChild(label);
					container.appendChild(table);
				});

				button.remove(); // ë²„íŠ¼ ì œê±°
			});

        };
    };
}



/////////////////////////////////////////////////////////////////////////////////////////
let deletedImages = []; // ì‚­ì œëœ ì´ë¯¸ì§€ ëª©ë¡


  async function saveNote(id) {
    await initMemoIndexedDB();

    const memo = (document.getElementById("noteText").value || "").trim();
    const images = (aptMemoImageList && aptMemoImageList[id]) ? aptMemoImageList[id] : [];

    const request = indexedDB.open("hongbuMemo", 4);

    request.onerror = function (event) {
      console.error("âŒ DB ì—´ê¸° ì‹¤íŒ¨:", event.target.error);
      alert("âŒ ë©”ëª¨ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (DB ì—´ê¸° ì‹¤íŒ¨)");
    };

    request.onsuccess = function (event) {
      try {
        const db = event.target.result;
        const tx = db.transaction(["apartmentNotes"], "readwrite");
        const store = tx.objectStore("apartmentNotes");

        const getRequest = store.get(id);
        getRequest.onerror = function (event) {
          console.error("âŒ ë°ì´í„° ì½ê¸° ì‹¤íŒ¨:", event.target.error);
          alert("âŒ ë©”ëª¨ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ê¸°ì¡´ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨)");
        };

        getRequest.onsuccess = function () {
          try {
            const existing = getRequest.result || null;

            // âœ… ë©”ëª¨/ì‚¬ì§„ ëª¨ë‘ ì—†ìœ¼ë©´: ì €ì¥í•˜ì§€ ì•ŠìŒ. ê¸°ì¡´ ë ˆì½”ë“œê°€ ìˆìœ¼ë©´ ì‚­ì œ.
            if ((!memo || memo.length === 0) && (!images || images.length === 0)) {
              if (existing) {
                const delReq = store.delete(id);
                delReq.onsuccess = function () {
                   try { window.__memoPresenceCache && window.__memoPresenceCache.set(String(id), false); } catch(e) {}
                  // UI ì´ˆê¸°í™”
                  aptMemoImageList[id] = [];
                  loadNote(id);

                  // ë§ˆì»¤ ì¬ìƒì„±(ë©”ëª¨ ì•„ì´ì½˜ ì œê±° íš¨ê³¼)
                  const marker = apartmentMarkers[id];
                  if (marker) {
                    marker.setMap(null);
                    delete apartmentMarkers[id];
                  }
                  const apartment = apartmentData.find(a => String(a.id) === String(id));
                  if (apartment) {
                    const isSiseMap = document.getElementById("toggleSiseMap")?.checked;
                    const newMarker = isSiseMap ? renderSiseMapMarker(apartment) : createDefaultMarker(apartment);
                    newMarker.__siseMap = isSiseMap;
                    apartmentMarkers[id] = newMarker;
                  }
                };
                delReq.onerror = function (event) {
                  console.error("âŒ ì‚­ì œ ì‹¤íŒ¨:", event.target.error);
                  alert("âŒ ë©”ëª¨ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                };
              }
              return; // ğŸš« ì—¬ê¸°ì„œ ë â€” ë¹ˆ ë‚´ìš©ì€ ì €ì¥/ìƒì„±í•˜ì§€ ì•ŠìŒ
            }

            // âœ… ë‚´ìš©ì´ ìˆìœ¼ë©´ ì €ì¥/ê°±ì‹ 
            const toSave = existing || { id, memo: "", images: [] };
            toSave.memo = memo;
            toSave.images = images;

            const putRequest = store.put(toSave);
            putRequest.onsuccess = function () {
               try { window.__memoPresenceCache && window.__memoPresenceCache.set(String(id), true); } catch(e) {}
              loadNote(id);

              // ë§ˆì»¤ ì¬ìƒì„±(ë©”ëª¨ ì•„ì´ì½˜ ë°˜ì˜)
              const marker = apartmentMarkers[id];
              if (marker) {
                marker.setMap(null);
                delete apartmentMarkers[id];
              }
              const apartment = apartmentData.find(a => String(a.id) === String(id));
              if (apartment) {
                const isSiseMap = document.getElementById("toggleSiseMap")?.checked;
                const newMarker = isSiseMap ? renderSiseMapMarker(apartment) : createDefaultMarker(apartment);
                newMarker.__siseMap = isSiseMap;
                apartmentMarkers[id] = newMarker;
              }
            };
            putRequest.onerror = function (event) {
              console.error("âŒ ì €ì¥ ì‹¤íŒ¨:", event.target.error);
              alert("âŒ ë©”ëª¨ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ì €ì¥ ì‹¤íŒ¨)");
            };

          } catch (error) {
            console.error("âŒ ë‚´ë¶€ ì²˜ë¦¬ ì‹¤íŒ¨:", error);
            alert("âŒ ë©”ëª¨ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ì²˜ë¦¬ ì˜¤ë¥˜)");
          }
        };
      } catch (error) {
        console.error("âŒ DB ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸:", error);
        alert("âŒ ë©”ëª¨ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    };
  }



function base64ToBlobUrl(base64) {
    const byteString = atob(base64.split(',')[1]);
    const mimeString = base64.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    const blob = new Blob([ab], { type: mimeString });
    return URL.createObjectURL(blob);
}

function createCanvasThumbnail(blobUrl, base64, idx, onDelete) {
    const wrapper = document.createElement("div");
    wrapper.style.position = "relative";
    wrapper.style.display = "inline-block";
    wrapper.style.marginRight = "6px";
    wrapper.style.width = "60px";
    wrapper.style.height = "60px";

    const canvas = document.createElement("canvas");
    canvas.width = 60;
    canvas.height = 60;
    canvas.style.border = "1px solid #ccc";
    canvas.style.borderRadius = "4px";
    canvas.style.cursor = "pointer";
    canvas.title = `ì‚¬ì§„ ${idx + 1}`;

    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
        ctx.drawImage(img, 0, 0, 60, 60);
    };
    img.src = blobUrl;

    canvas.onclick = (e) => {
	  e.stopPropagation();

	  const modal = document.getElementById("imageModal");
	  const modalCanvas = document.getElementById("modalCanvas");
	  const ctx = modalCanvas.getContext("2d");

	  
  __clearModalCanvas();
const img = new Image();
	  img.onload = () => {
		// ì´ë¯¸ì§€ í¬ê¸°ì— ë§ê²Œ ìº”ë²„ìŠ¤ ì¡°ì ˆ
		modalCanvas.width = img.width;
		modalCanvas.height = img.height;
		ctx.drawImage(img, 0, 0);
		modal.style.display = "flex";
		window.imageModalShowYn = true;
	  };
	  img.src = blobUrl;
window.lastOpenedBase64 = img.dataset.original || img.src;

	};


    const deleteBtn = document.createElement("div");
    deleteBtn.textContent = "âœ•";
    deleteBtn.style.position = "absolute";
    deleteBtn.style.top = "2px";
    deleteBtn.style.right = "2px";
    deleteBtn.style.background = "rgba(0,0,0,0.6)";
    deleteBtn.style.color = "white";
    deleteBtn.style.borderRadius = "50%";
    deleteBtn.style.width = "16px";
    deleteBtn.style.height = "16px";
    deleteBtn.style.display = "flex";
    deleteBtn.style.alignItems = "center";
    deleteBtn.style.justifyContent = "center";
    deleteBtn.style.cursor = "pointer";
    deleteBtn.style.fontSize = "12px";

    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        if (confirm("ì‚¬ì§„ì„ ì‚­ì œí•©ë‹ˆë‹¤")) {
            // âœ… ì¸ë„¤ì¼ì— blob: URLì„ ì“°ëŠ” ê²½ìš° í•´ì œ
            __safeRevokeObjectURL(blobUrl);
            onDelete(base64);
            wrapper.remove();
        }
    };

    wrapper.appendChild(canvas);
    wrapper.appendChild(deleteBtn);
    return wrapper;
}

async function loadNote(id) {
await initMemoIndexedDB()
  const request = indexedDB.open("hongbuMemo", 4);
  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readonly");
    const store = transaction.objectStore("apartmentNotes");

    const getRequest = store.get(id);
    getRequest.onsuccess = function () {
      const result = getRequest.result;
      //if (!result) return;
	const noteEl = document.getElementById("noteText");
      const preview = document.getElementById("imagePreview");
    

 if (!result) {
        // âœ… ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° UI ì´ˆê¸°í™”
        if (noteEl) noteEl.value = "";
        if (preview) {
          preview.innerHTML = "";
          preview.style.display = "none";
        }
        aptMemoImageList[id] = [];
        db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
        return;
      }


  
preview.innerHTML = "";
      document.getElementById("noteText").value = result.memo || "";
	  if(result.images.length > 0){
		preview.style.display = "flex";
	 }
      aptMemoImageList[id] = result.images || [];

      
    

      for (const imageDataUrl of aptMemoImageList[id]) {
        const wrapper = document.createElement("div");
        wrapper.style.position = "relative";
        wrapper.style.display = "inline-block";
        wrapper.style.marginRight = "6px";
        wrapper.style.width = "60px";
        wrapper.style.height = "60px";

        const canvas = document.createElement("canvas");
        canvas.width = 60;
        canvas.height = 60;
        canvas.style.border = "1px solid #ccc";
        canvas.style.borderRadius = "4px";
        canvas.style.cursor = "pointer";
        canvas.title = "ë¯¸ë¦¬ë³´ê¸°";

        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, 60, 60);
        };
        img.src = imageDataUrl;

       canvas.onclick = (e) => {
  e.stopPropagation();
  const modal = document.getElementById("imageModal");
  const modalCanvas = document.getElementById("modalCanvas");
  const modalCtx = modalCanvas.getContext("2d");

  const fullImage = new Image();
  fullImage.onload = () => {
    modalCanvas.width = fullImage.width;
    modalCanvas.height = fullImage.height;
    modalCtx.drawImage(fullImage, 0, 0);
    modal.style.display = "flex";
    window.imageModalShowYn = true;
  };
  fullImage.src = img.src; // âœ… ì¸ë„¤ì¼ ì´ë¯¸ì§€ ë§ê³  ì›ë³¸ìœ¼ë¡œ ìƒˆë¡œ ë¡œë“œ
window.lastOpenedBase64 = img.dataset.original || img.src;

};


        const deleteBtn = document.createElement("div");
        deleteBtn.textContent = "âœ•";
        deleteBtn.style.position = "absolute";
        deleteBtn.style.top = "2px";
        deleteBtn.style.right = "2px";
        deleteBtn.style.background = "rgba(0,0,0,0.6)";
        deleteBtn.style.color = "white";
        deleteBtn.style.borderRadius = "50%";
        deleteBtn.style.width = "16px";
        deleteBtn.style.height = "16px";
        deleteBtn.style.display = "flex";
        deleteBtn.style.alignItems = "center";
        deleteBtn.style.justifyContent = "center";
        deleteBtn.style.cursor = "pointer";
        deleteBtn.style.fontSize = "12px";

        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm("ì‚¬ì§„ì„ ì‚­ì œí•©ë‹ˆë‹¤")) {
            // âœ… blob: URLì¼ ê²½ìš° í•´ì œ
            __safeRevokeObjectURL(imageDataUrl);
            aptMemoImageList[id] = aptMemoImageList[id].filter(img => img !== imageDataUrl);
            wrapper.remove();
          }
        };

        wrapper.appendChild(canvas);
        wrapper.appendChild(deleteBtn);
        preview.appendChild(wrapper);
      }
      db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
    };

    getRequest.onerror = function () {
      console.error("âŒ loadNote ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨:", getRequest.error);
      db.close(); // âœ… ì‹¤íŒ¨ ì‹œì—ë„ DB ì—°ê²° ì •ë¦¬
    };
  };

  request.onerror = function (event) {
    console.error("âŒ loadNote DB ì—´ê¸° ì‹¤íŒ¨:", event.target.error);
  };
}




// âœ… ëª¨ë‹¬ ë‹«ê¸° ì´ë²¤íŠ¸ë„ ë“±ë¡
document.getElementById("imageModal").addEventListener("click", (e) => {
    // âœ… ë°°ê²½(ë°”ê¹¥ ì˜ì—­) í´ë¦­ì¼ ë•Œë§Œ ë‹«ê¸°
    if (e.target === e.currentTarget) {
        closeImageModal();
    }
    // ğŸ”¥ document í´ë¦­ìœ¼ë¡œ ì „íŒŒë˜ì–´ ë””í…Œì¼ ì°½ì´ ë‹«íˆëŠ” ê²ƒ ë°©ì§€
    e.stopPropagation();
});

// âœ… ëª¨ë‹¬ ë‚´ë¶€ ìš”ì†Œ í´ë¦­ë„ ì „íŒŒ ì°¨ë‹¨
(function(){
  const canvas = document.getElementById("modalCanvas");
  const copyBtn = document.getElementById("copyImageButton");
  const downBtn = document.getElementById("downloadImageButton");
  [canvas, copyBtn, downBtn].forEach(el=>{
    if(!el) return;
    el.addEventListener("click", (ev)=> ev.stopPropagation());
  });
})();
function showImageModal(src) {
  const modal = document.getElementById("imageModal");
  const modalCanvas = document.getElementById("modalCanvas");
  const ctx = modalCanvas && modalCanvas.getContext && modalCanvas.getContext("2d");
  if (!modal || !modalCanvas || !ctx) return;
  const img = new Image();
  img.onload = () => {
    modalCanvas.width = img.width;
    modalCanvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    modal.style.display = "flex";
    window.imageModalShowYn = true;
    window.lastOpenedBase64 = src;
  };
  img.src = src;
}

async function backupMemoDB() {
  const request = indexedDB.open("hongbuMemo", 4);

  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readonly");
    const store = transaction.objectStore("apartmentNotes");

    const chunkList = [];
    const chunkSize = 10;

    const now = new Date();
    const koreaTime = new Date(now.getTime() + 9 * 60 * 60 * 1000);
    const timestamp = koreaTime.toISOString()
      .replace(/T/, "_")
      .replace(/:/g, "-")
      .replace(/\..+/, "");

    const cursorRequest = store.openCursor();
    cursorRequest.onsuccess = async function (event) {
      const cursor = event.target.result;
      if (cursor) {
        chunkList.push(cursor.value);
        cursor.continue();
      } else {
        const totalChunks = Math.ceil(chunkList.length / chunkSize);

        for (let i = 0; i < totalChunks; i++) {
          const chunk = chunkList.slice(i * chunkSize, (i + 1) * chunkSize);
          const json = JSON.stringify(chunk, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          await new Promise(resolve => {
            const a = document.createElement("a");
            a.href = url;
            a.download = `í™ë¶€_ë©”ëª¨ë°±ì—…_${timestamp}_part${i + 1}.json`;
            document.body.appendChild(a); // iOSìš© í•„ìš”
            a.click();

            setTimeout(() => {
              URL.revokeObjectURL(url);
              a.remove();
              resolve();
            }, 1000); // ë‹¤ìš´ë¡œë“œ ì™„ë£Œ ëŒ€ê¸° ì‹œê°„
          });
        }

        db.close();
        alert("âœ… ë°±ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
      }
    };

    cursorRequest.onerror = function () {
      alert("âŒ ë°±ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ (cursor ì‹¤íŒ¨)");
      db.close();
    };
  };

  request.onerror = function () {
    alert("âŒ DB ì—´ê¸° ì‹¤íŒ¨");
  };
}


// âœ… ë©”ëª¨ ë°±ì—…
async function backupMemoDB_OLD() {
  const request = indexedDB.open("hongbuMemo", 4);

  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readonly");
    const store = transaction.objectStore("apartmentNotes");

    const chunkList = [];
    const chunkSize = 10;

    // âœ… í•œêµ­ ì‹œê°„ ê¸°ì¤€ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
    const now = new Date();
    const koreaTime = new Date(now.getTime() + 9 * 60 * 60 * 1000); // UTC+9 ë³´ì •
    const timestamp = koreaTime.toISOString()
      .replace(/T/, "_")
      .replace(/:/g, "-")
      .replace(/\..+/, "");

    store.openCursor().onsuccess = function (event) {
      const cursor = event.target.result;
      if (cursor) {
        const item = cursor.value;
        chunkList.push(item);
        cursor.continue();
      } else {
        const totalChunks = Math.ceil(chunkList.length / chunkSize);
        for (let i = 0; i < totalChunks; i++) {
          const chunk = chunkList.slice(i * chunkSize, (i + 1) * chunkSize);
          const json = JSON.stringify(chunk, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `í™ë¶€_ë©”ëª¨ë°±ì—…_${timestamp}_part${i + 1}.json`;
          a.click();

          URL.revokeObjectURL(url); // ë©”ëª¨ë¦¬ í•´ì œ
        }

        db.close();
      }
    };

    store.openCursor().onerror = function () {
      alert("âŒ ë°±ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ (cursor ì‹¤íŒ¨)");
      db.close();
    };
  };

  request.onerror = function () {
    alert("âŒ DB ì—´ê¸° ì‹¤íŒ¨");
  };
}

function refreshApartmentMarkers() {
  if (!window.map) return;

  // ê¸°ì¡´ ì•„íŒŒíŠ¸ ë§ˆì»¤ ì œê±° + ìºì‹œ ì´ˆê¸°í™”
  Object.values(apartmentMarkers).forEach(m => {
    if (m instanceof naver.maps.Marker) m.setMap(null);
  });
  apartmentMarkers = {};

  // í˜„ì¬ ì§€ë„ bounds ê¸°ì¤€ìœ¼ë¡œ ì¬ìƒì„±
  updateMarkers(window.map.getBounds());
}



// âœ… ë©”ëª¨ ë³µì› (ì •ìƒ ë™ì‘ ë²„ì „)
function restoreMemoDB() {
  const input = document.getElementById("memoRestoreInput");
  input.accept = ".json";
  input.multiple = true;

  input.onchange = async function (event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // ê°™ì€ íŒŒì¼ ë‹¤ì‹œ ì„ íƒ ê°€ëŠ¥í•˜ê²Œ ì´ˆê¸°í™”
    input.value = "";

    try {
      hongbuDebugLog("INFO", `ğŸ“‚ ë©”ëª¨ ë³µì› ì‹œì‘: ${files.length}ê°œ íŒŒì¼`);
      hongbuDebugToast("â³ ë©”ëª¨ ë³µì› ì¤‘ì…ë‹ˆë‹¤...", 100000); // ì˜¤ë˜ í‘œì‹œ
      
      // 1) íŒŒì¼ë“¤ ì½ì–´ì„œ ì „ë¶€ flatten (FileReader ì‚¬ìš© - iOS í˜¸í™˜ì„±)
      let records = [];
      
      for (const file of files) {
        hongbuDebugLog("INFO", `íŒŒì¼ ì½ëŠ” ì¤‘: ${file.name}`);
        
        // âœ… file.text() ëŒ€ì‹  FileReader ì‚¬ìš© (iOS Safari í˜¸í™˜ì„± í–¥ìƒ)
        const text = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error(`íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ${file.name}`));
          reader.readAsText(file, 'UTF-8');
        });
        
        try {
          const parsed = JSON.parse(text);
          if (Array.isArray(parsed)) records.push(...parsed);
          else records.push(parsed);
          hongbuDebugLog("INFO", `âœ… ${file.name} íŒŒì‹± ì™„ë£Œ`);
        } catch (parseErr) {
          hongbuDebugLog("WARN", `íŒŒì¼ íŒŒì‹± ì‹¤íŒ¨ (${file.name})`, parseErr.message);
          continue;
        }
      }

      // 2) ë ˆì½”ë“œ ì •ê·œí™” (keyPath=idë¼ì„œ id í•„ìˆ˜)
      const normalized = records
        .filter((r) => r && typeof r === "object")
        .map((r) => {
          if (r.id === undefined || r.id === null) return null;
          return {
            id: String(r.id),
            memo: r.memo ? String(r.memo) : "",
            images: Array.isArray(r.images) ? r.images : [],
          };
        })
        .filter(Boolean);

      hongbuDebugLog("INFO", `ğŸ“‹ ì •ê·œí™”ëœ ë©”ëª¨: ${normalized.length}ê°œ`);

      if (!normalized.length) {
        hongbuDebugLog("WARN", "âŒ ë³µì›í•  ìœ íš¨í•œ ë©”ëª¨ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
        hongbuDebugToast("âŒ ë³µì›í•  ë©”ëª¨ê°€ ì—†ìŠµë‹ˆë‹¤.", 3000);
        return;
      }

      // 3) IndexedDB put - ë°°ì¹˜ ì²˜ë¦¬ë¡œ ë©”ëª¨ë¦¬ ë¶€ë‹´ ì¤„ì„
      hongbuDebugLog("INFO", "ğŸ—ƒï¸ IndexedDBì— ì €ì¥ ì¤‘... (ë°°ì¹˜ ì²˜ë¦¬)");
      const BATCH_SIZE = 100; // 100ê°œì”© ì²˜ë¦¬
      let totalOk = 0, totalFail = 0;

      for (let i = 0; i < normalized.length; i += BATCH_SIZE) {
        const batch = normalized.slice(i, i + BATCH_SIZE);
        
        await new Promise((resolvePromise, rejectPromise) => {
          const request = indexedDB.open("hongbuMemo", 4);

          request.onsuccess = function (e) {
            const db = e.target.result;
            const tx = db.transaction(["apartmentNotes"], "readwrite");
            const store = tx.objectStore("apartmentNotes");

            let batchOk = 0, batchFail = 0;

            batch.forEach((item) => {
              const putReq = store.put(item);
              putReq.onsuccess = () => batchOk++;
              putReq.onerror = (err) => {
                batchFail++;
                hongbuDebugLog("WARN", `put ì‹¤íŒ¨: ${item.id}`, err?.target?.error?.message);
              };
            });

            tx.oncomplete = () => {
              totalOk += batchOk;
              totalFail += batchFail;
              hongbuDebugLog("INFO", `ë°°ì¹˜ ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(normalized.length / BATCH_SIZE)} ì™„ë£Œ`);
              db.close();
              resolvePromise();
            };

            tx.onerror = (err) => {
              hongbuDebugLog("ERR", "âŒ ë°°ì¹˜ íŠ¸ëœì­ì…˜ ì˜¤ë¥˜", err?.target?.error?.message);
              db.close();
              rejectPromise(err);
            };
          };

          request.onerror = function (err) {
            hongbuDebugLog("ERR", "âŒ DB ì—´ê¸° ì‹¤íŒ¨", err?.target?.error?.message);
            rejectPromise(err);
          };
        });

        // ë°°ì¹˜ ê°„ ì§§ì€ ì§€ì—°ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œê°„ ì œê³µ
        await new Promise(r => setTimeout(r, 50));
      }

      hongbuDebugLog("INFO", `âœ… ë³µì› ì™„ë£Œ: ì„±ê³µ ${totalOk} / ì‹¤íŒ¨ ${totalFail}`);
      hongbuDebugToast(`âœ… ë³µì› ì™„ë£Œ! ${totalOk}ê°œ ë©”ëª¨ ì €ì¥ë¨`, 5000);
      
      hongbuDebugLog("INFO", "â³ 2ì´ˆ í›„ ë§ˆì»¤ ìƒˆë¡œê³ ì¹¨...");
      
      // 2ì´ˆ ì§€ì—° í›„ ë§ˆì»¤ ìƒˆë¡œê³ ì¹¨ (ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œê°„ ì œê³µ)
      setTimeout(() => {
        hongbuDebugLog("INFO", "ğŸ”„ ë§ˆì»¤ ìƒˆë¡œê³ ì¹¨ ì‹œì‘...");
        refreshApartmentMarkers();
        hongbuDebugLog("INFO", "ğŸ”„ ë§ˆì»¤ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ");
      }, 2000);

    } catch (err) {
      hongbuDebugLog("ERR", "âŒ ë³µì› ì¤‘ ì˜ˆì™¸", err.message);
      hongbuDebugToast("âŒ ì˜¤ë¥˜ ë°œìƒ: " + err.message, 5000);
    }
  };

  input.click();
}





function restoreMemoDB_OLD() {
    document.getElementById("memoRestoreInput").click();

    document.getElementById("memoRestoreInput").onchange = function (e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
            try {
                const jsonData = JSON.parse(event.target.result);
                if (!Array.isArray(jsonData)) {
                    alert("ìœ íš¨í•˜ì§€ ì•Šì€ ë°±ì—… íŒŒì¼ì…ë‹ˆë‹¤.");
                    return;
                }

                const request = indexedDB.open("hongbuMemo", 4);
                request.onsuccess = function (event) {
                    const db = event.target.result;
                    const transaction = db.transaction(["apartmentNotes"], "readwrite");
                    const store = transaction.objectStore("apartmentNotes");

                    jsonData.forEach(entry => store.put(entry));
                    alert("ë©”ëª¨ ë³µì›ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
                };
            } catch (err) {
                alert("íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: " + err.message);
            }
        };
        reader.readAsText(file);
    };
}

document.getElementById("copyImageButton").onclick = async () => {
  const canvas = document.getElementById("modalCanvas");

  canvas.toBlob(async (blob) => {
    try {
      await navigator.clipboard.write([
        new ClipboardItem({ "image/png": blob })
      ]);
      //alert("ì´ë¯¸ì§€ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!");
    } catch (err) {
      console.error("ì´ë¯¸ì§€ ë³µì‚¬ ì‹¤íŒ¨:", err);
      alert("ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }
  }, "image/png");
};
let lastOpenedBase64;

document.getElementById("downloadImageButton").addEventListener("click", () => {
  if (!window.lastOpenedBase64) {
    alert("âŒ ë‹¤ìš´ë¡œë“œí•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  const a = document.createElement("a");
  a.href = window.lastOpenedBase64;

  // âœ… í•œêµ­ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ íŒŒì¼ëª… ìƒì„±
  const now = new Date();
  const koreaTime = new Date(now.getTime() + 9 * 60 * 60 * 1000);
  const timestamp = koreaTime.toISOString().slice(0, 19).replace(/T/, "_").replace(/:/g, "-");

  a.download = `í™ë¶€_ë©”ëª¨_${timestamp}.png`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
});



function deleteMemoDB() {
  if (!confirm("ì •ë§ ëª¨ë“  ë©”ëª¨ì™€ ì´ë¯¸ì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

  const request = indexedDB.open("hongbuMemo", 4);
  request.onsuccess = function (event) {
    const db = event.target.result;
    db.close(); // ğŸ‘‰ ì—°ê²° ë¨¼ì € ë‹«ê¸°

    const deleteRequest = indexedDB.deleteDatabase("hongbuMemo");

    deleteRequest.onsuccess = function () {alert("âœ… ë©”ëª¨ DB ì‚­ì œ ì™„ë£Œ");
      setTimeout(() => location.reload(), 300); // ë„ˆë¬´ ë¹¨ë¦¬ reload ë˜ì§€ ì•Šê²Œ ì•½ê°„ ì§€ì—°
    };

    deleteRequest.onerror = function (e) {
      alert("âŒ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + e.target.error);
    };

    deleteRequest.onblocked = function () {
      alert("âŒ ë‹¤ë¥¸ íƒ­ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. ëª¨ë“  íƒ­ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
    };
  };

  request.onerror = function (e) {
    alert("âŒ DB ì—´ê¸° ì‹¤íŒ¨: " + e.target.errorCode);
  };
}



function deleteNote(id) {
  if (!confirm("ì •ë§ ì´ ë©”ëª¨ì™€ ì´ë¯¸ì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

  const request = indexedDB.open("hongbuMemo", 4);

  request.onsuccess = function (event) {
    const db = event.target.result;
    const transaction = db.transaction(["apartmentNotes"], "readwrite");
    const store = transaction.objectStore("apartmentNotes");

    const deleteRequest = store.delete(id);

    deleteRequest.onsuccess = function () {
       try { window.__memoPresenceCache && window.__memoPresenceCache.set(String(id), false); } catch(e) {}
      alert("í•´ë‹¹ ë©”ëª¨ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
      db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
      loadNote(id); // ì‚­ì œ í›„ í™”ë©´ ê°±ì‹ 
    };

    deleteRequest.onerror = function (event) {
      console.error("âŒ ì‚­ì œ ì¤‘ ì˜¤ë¥˜:", event.target.error);
      alert("âŒ ë©”ëª¨ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      db.close(); // âœ… DB ì—°ê²° ì •ë¦¬
    };
  };

  request.onerror = function (event) {
    console.error("âŒ DB ì—°ê²° ì‹¤íŒ¨:", event.target.error);
    alert("âŒ ë©”ëª¨ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (DB ì—°ê²° ì‹¤íŒ¨)");
  };
}

async function getMemoFromIndexedDB(id) {
  return new Promise(async (resolve, reject) => {
    await initMemoIndexedDB();

    const request = indexedDB.open("hongbuMemo", 4);
    request.onerror = () => reject("DB ì—´ê¸° ì‹¤íŒ¨");

    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(["apartmentNotes"], "readonly");
      const store = transaction.objectStore("apartmentNotes");
      const getRequest = store.get(String(id));

      getRequest.onsuccess = () => {
        resolve(getRequest.result);
        db.close(); // âœ… ë°˜ë“œì‹œ ë‹«ê¸°
      };

      getRequest.onerror = () => {
        reject("ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨");
        db.close(); // âœ… ì‹¤íŒ¨ ì‹œì—ë„ ë‹«ê¸°
      };
    };
  });
}


async function findWay() {
    // ì˜¤ë²„ë ˆì´ ìƒì„±
    var overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = `calc(100px)`;
    overlay.style.left = '0px';
    overlay.style.width = `calc(100% - 50px)`;
    overlay.style.height = `calc(100% - 100px)`;
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    overlay.style.display = 'none';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.zIndex = '9999';

    // ë‹«ê¸° ë²„íŠ¼ ìƒì„±
    var closeButton = document.createElement('button');
    closeButton.innerText = 'ë‹«ê¸°';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '0px';
    closeButton.style.right = '20px';
    closeButton.style.backgroundColor = 'red';
    closeButton.style.color = 'white';
    closeButton.style.padding = '10px';
    closeButton.style.border = 'none';
    closeButton.style.cursor = 'pointer';

    // iframe ìƒì„±
    var iframe = document.createElement('iframe');
    iframe.id = 'iframeOverlay';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.border = 'none';

    // ì˜¤ë²„ë ˆì´ì— ë‹«ê¸° ë²„íŠ¼ê³¼ iframe ì¶”ê°€
    overlay.appendChild(closeButton);
    overlay.appendChild(iframe);

    // ì˜¤ë²„ë ˆì´ë¥¼ bodyì— ì¶”ê°€
    document.body.appendChild(overlay);

    // ë‹«ê¸° ë²„íŠ¼ í´ë¦­ ì‹œ ì˜¤ë²„ë ˆì´ ë‹«ê¸°
    closeButton.addEventListener('click', function() {
	  overlay.style.display = 'none';
	  iframe.src = '';

	  const mapWrap = document.querySelector('.map_wrap');
	  if (mapWrap) mapWrap.style.height = '100%';

	  // í˜¹ì‹œ ë„ˆë¹„ ë³µêµ¬ ì½”ë“œ ë‹¤ì‹œ ì“¸ ê±°ë©´ ì´ê²ƒë„ ì•ˆì „í•˜ê²Œ:
	  const ctn = document.querySelector('.ctn_wrap.open');
	  if (ctn) ctn.style.width = '390px';

	  if (mapWrap && ctn) mapWrap.style.width = `calc(100% - ${ctn.offsetWidth}px)`;
	});


    // "ê¸¸ì°¾ê¸°" ë²„íŠ¼ ìƒì„±
    var routeButton = document.createElement('button');
    routeButton.innerText = 'ê¸¸ì°¾ê¸°';
    routeButton.style.position = 'absolute';
    routeButton.style.display = 'none';
    routeButton.style.zIndex = '9999';
    routeButton.style.padding = '10px';
    routeButton.style.backgroundColor = '#007bff';
    routeButton.style.color = 'white';
    routeButton.style.border = 'none';
    routeButton.style.cursor = 'pointer';
    routeButton.style.borderRadius = '5px';

    // "ê¸¸ì°¾ê¸°" ë²„íŠ¼ì„ bodyì— ì¶”ê°€
    document.body.appendChild(routeButton);

    // ì²´í¬ë°•ìŠ¤ ì»¨í…Œì´ë„ˆ ìƒì„±
    var checkboxContainer = document.createElement('div');
    checkboxContainer.style.position = 'absolute';
    checkboxContainer.style.display = 'none';
    checkboxContainer.style.backgroundColor = 'white';
    checkboxContainer.style.padding = '10px';
    checkboxContainer.style.zIndex = '9999';
    checkboxContainer.style.border = '1px solid #ccc';
    checkboxContainer.style.borderRadius = '5px';

    // ëª©ì ì§€ ì²´í¬ë°•ìŠ¤ ë¦¬ìŠ¤íŠ¸ ìƒì„±
    const destinations = [
        { id: 'chk1', lat: 37.497951, lng: 127.027636, name: 'ê°•ë‚¨ì—­2í˜¸ì„ ', code: 222 },
        { id: 'chk2', lat: 37.564719, lng: 126.977022, name: 'ì„œìš¸ì‹œì²­ì—­2í˜¸ì„ ', code: 273 },
        { id: 'chk3', lat: 37.521624, lng: 126.924374, name: 'ì—¬ì˜ë„ì—­5í˜¸ì„ ', code: 526 },
        { id: 'chk4', lat: 37.481339, lng: 126.882734, name: 'ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€ì—­1í˜¸ì„ ', code: 172 },
        { id: 'chk8', lat: 37.485266, lng: 126.900198, name: 'êµ¬ë¡œì§€ë””í„¸ë‹¨ì§€ì—­2í˜¸ì„ ', code: 232 },
        { id: 'chk5', lat: 37.394768, lng: 127.111699, name: 'íŒêµì—­ì‹ ë¶„ë‹¹ì„ ', code: 1914 },
        { id: 'chk6', lat: 37.560143, lng: 126.825231, name: 'ë§ˆê³¡ì—­5í˜¸ì„ ', code: 514 },
        { id: 'chk7', lat: 37.576528, lng: 126.898109, name: 'DMCì—­6í˜¸ì„ ', code: 618 }
    ];

  var style = document.createElement('style');
style.innerHTML = `
    input[type="checkbox"] {
        width: 15px;   /* ê¸°ë³¸ í¬ê¸° ì„¤ì • */
        height: 15px;  /* ê¸°ë³¸ í¬ê¸° ì„¤ì • */
        visibility: visible; /* ì²´í¬ë°•ìŠ¤ê°€ ë³´ì´ë„ë¡ ì„¤ì • */
        appearance: auto;  /* ê¸°ë³¸ ì²´í¬ë°•ìŠ¤ ìŠ¤íƒ€ì¼ë¡œ ì„¤ì • */
        -webkit-appearance: checkbox; /* ë¸Œë¼ìš°ì € í˜¸í™˜ì„± */
    }
`;
document.head.appendChild(style);


    destinations.forEach((dest, index) => {
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = dest.id;
    checkbox.style.display = 'inline-block'; // ì²´í¬ë°•ìŠ¤ê°€ ë³´ì´ë„ë¡ ì„¤ì •
    checkbox.style.visibility = 'visible';   // ì²´í¬ë°•ìŠ¤ê°€ ìˆ¨ê²¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì •

    // ì²˜ìŒ 3ê°œì˜ ì²´í¬ë°•ìŠ¤ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì²´í¬
    if (index < 3) {
        checkbox.checked = true;
    }

    var label = document.createElement('label');
    label.htmlFor = dest.id;  // labelì˜ for ì†ì„±ì„ ì²´í¬ë°•ìŠ¤ idì™€ ì—°ê²°
    label.innerText = dest.name;
    label.style.fontSize = '16px'; // í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì •

    var container = document.createElement('div');
    container.style.display = 'flex';  // ì²´í¬ë°•ìŠ¤ì™€ ë ˆì´ë¸”ì„ ë‚˜ë€íˆ ë°°ì¹˜
    container.style.alignItems = 'center'; // ì„¸ë¡œë¡œ ì •ë ¬ì„ ë§ì¶¤
    container.style.marginBottom = '5px'; // í•­ëª© ì‚¬ì´ì— ê°„ê²© ì¶”ê°€

    container.appendChild(checkbox);
    container.appendChild(label);

    checkboxContainer.appendChild(container);
});



    // ì²´í¬ë°•ìŠ¤ ì»¨í…Œì´ë„ˆë¥¼ bodyì— ì¶”ê°€
    document.body.appendChild(checkboxContainer);

    // ìš°í´ë¦­ ì‹œ ì´ë²¤íŠ¸ë¥¼ ë“±ë¡í•˜ì—¬ "ê¸¸ì°¾ê¸°" ë²„íŠ¼ì„ í‘œì‹œ
    naver.maps.Event.addListener(window.map, 'rightclick', function(e) {

		if(!document.getElementById("toggleFindWay")?.checked){
			return;
		}
        var latlng = e.coord;  // ìš°í´ë¦­í•œ ìœ„ì¹˜ì˜ ì¢Œí‘œ (ì§€ë„ ìƒì˜ ìœ„ë„, ê²½ë„)
        var startX = latlng.lng();  // ìš°í´ë¦­í•œ ìœ„ì¹˜ì˜ ê²½ë„
        var startY = latlng.lat();  // ìš°í´ë¦­í•œ ìœ„ì¹˜ì˜ ìœ„ë„

        // ìš°í´ë¦­í•œ í™”ë©´ìƒì˜ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸° (clientX, clientY)
        var mouseEvent = e.pointerEvent;
        var mouseX = mouseEvent.clientX;
        var mouseY = mouseEvent.clientY;

        // ë§ˆìš°ìŠ¤ ìš°í´ë¦­ ìœ„ì¹˜ì— "ê¸¸ì°¾ê¸°" ë²„íŠ¼ê³¼ ì²´í¬ë°•ìŠ¤ í‘œì‹œ
        routeButton.style.left = mouseX + 'px';
        routeButton.style.top = mouseY + 'px';
        routeButton.style.display = 'block';  // ë²„íŠ¼ì„ í™”ë©´ì— í‘œì‹œ

        checkboxContainer.style.left = (mouseX + 65) + 'px';
        checkboxContainer.style.top = mouseY + 'px';
        checkboxContainer.style.display = 'block';

        // "ê¸¸ì°¾ê¸°" ë²„íŠ¼ í´ë¦­ ì‹œ ì˜¤ë²„ë ˆì´ë¥¼ í‘œì‹œí•˜ê³ , iframeì— ê²½ë¡œ í‘œì‹œ
        routeButton.onclick = function() {
            var selectedDestinations = destinations.filter(dest => document.getElementById(dest.id).checked);


            if (selectedDestinations.length > 0) {
                var destinationIds = selectedDestinations.map(dest => dest.id).join(',');

                // URLì— ì„ íƒëœ ëª©ì ì§€ id ì¶”ê°€
                var url = `https://luciferhong.github.io/luciferhong/public2.html?startX=${startX}&startY=${startY}&selected=${destinationIds}`;
                 //var url = `https://luciferhong.github.io/luciferhong/public2.html?startX=${startX}&startY=${startY}&mode=transit`;
                //var url = `http://localhost:8000/test2.html?startX=${startX}&startY=${startY}&selected=${destinationIds}`;

                iframe.src = url;
                overlay.style.display = 'flex';
                routeButton.style.display = 'none';
                checkboxContainer.style.display = 'none';
               //document.querySelector('.ctn_wrap.open').style.width = '0px';
              //document.querySelector('.map_wrap').style.width = `calc(100% - 390px)`;
        //document.querySelector('.map_wrap').style.height = '40%';
            } else {
                alert('ì ì–´ë„ í•˜ë‚˜ì˜ ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
            }


            // ë²„íŠ¼ê³¼ ì²´í¬ë°•ìŠ¤ë¥¼ ë‹¤ì‹œ ìˆ¨ê¹€
            routeButton.style.display = 'none';
            checkboxContainer.style.display = 'none';
        };
    });

    // ì§€ë„ í´ë¦­ ì‹œ "ê¸¸ì°¾ê¸°" ë²„íŠ¼ ìˆ¨ê¸°ê¸°
    window.map.getElement().addEventListener('click', function() {
        routeButton.style.display = 'none';
        checkboxContainer.style.display = 'none';
    });
};



let inguData = [];
let currentSort = { key: null, asc: true };

document.getElementById("showInguBtn").addEventListener("click", async () => {
  // âœ… ë³µì›ëœ UI ìƒíƒœ(IndexedDB settings)ì—ì„œ ì‹œë„/ì‹œêµ°êµ¬ ì„ íƒê°’ì„ ê°€ì ¸ì˜´
  const _savedUI = await getHongbuSetting(UI_STATE_KEY).catch(() => null);
  const _savedSido = _savedUI && typeof _savedUI === "object" ? _savedUI["sidoSelect"] : null;
  const _savedSigungu = _savedUI && typeof _savedUI === "object" ? _savedUI["sigunguSelect"] : null;
  if (inguData.length === 0) {
    const res = await fetch("ingu.txt");
    const text = await res.text();
    const lines = text.trim().split("\n");
    const headers = lines[0].split("\t");
    inguData = lines.slice(1).map(line => {
      const [ì‹œë„, ì‹œêµ°êµ¬, ìë©´ë™, ì´ì¸êµ¬ìˆ˜, ì„¸ëŒ€ìˆ˜, ì„¸ëŒ€ë‹¹ì¸êµ¬] = line.split("\t");
      return { ì‹œë„, ì‹œêµ°êµ¬, ìë©´ë™, ì´ì¸êµ¬ìˆ˜, ì„¸ëŒ€ìˆ˜, ì„¸ëŒ€ë‹¹ì¸êµ¬ };
    });

    // ì‹œë„ ì˜µì…˜ ì„¤ì •
    const sidoSet = new Set(inguData.map(d => d.ì‹œë„).filter(Boolean));
    const sidoSelect = document.getElementById("sidoSelect");
    sidoSelect.innerHTML = [...sidoSet].map(s => {
      const isSel = (_savedSido && s === _savedSido) || (!_savedSido && s === "ì„œìš¸íŠ¹ë³„ì‹œ");
      return `<option value="${s}" ${isSel ? "selected" : ""}>${s}</option>`;
    }).join("");

    // âœ… ì €ì¥ëœ ì‹œë„ê°€ ì˜µì…˜ì— ìˆìœ¼ë©´ ì„ íƒê°’ì„ ê°•ì œë¡œ ë§ì¶¤(ì˜µì…˜ ìƒì„± íƒ€ì´ë° ì´ìŠˆ ë°©ì§€)
    if (_savedSido && [...sidoSelect.options].some(o => o.value === _savedSido)) {
      sidoSelect.value = _savedSido;
    }

    sidoSelect.addEventListener("change", () => {
      updateSigunguSelect(_savedSigungu);
      updateTable();
    });

    document.getElementById("sigunguSelect").addEventListener("change", updateTable);

    updateSigunguSelect(_savedSigungu);
  }

  document.getElementById("inguModal").style.display = "block";
  updateTable();
});

function updateSigunguSelect(preferredSigungu) {
  const selectedSido = document.getElementById("sidoSelect").value;
  const sigunguSet = new Set(inguData.filter(d => d.ì‹œë„ === selectedSido).map(d => d.ì‹œêµ°êµ¬).filter(Boolean));
  const sigunguSelect = document.getElementById("sigunguSelect");
  sigunguSelect.innerHTML = [...sigunguSet].map(s => {
    const isSel = (preferredSigungu && s === preferredSigungu) || (!preferredSigungu && s === "ì¢…ë¡œêµ¬");
    return `<option value="${s}" ${isSel ? "selected" : ""}>${s}</option>`;
  }).join("");
  // âœ… ì €ì¥ëœ ì‹œêµ°êµ¬ê°€ ì˜µì…˜ì— ìˆìœ¼ë©´ ì„ íƒê°’ì„ ê°•ì œë¡œ ë§ì¶¤
  if (preferredSigungu && [...sigunguSelect.options].some(o => o.value === preferredSigungu)) {
    sigunguSelect.value = preferredSigungu;
  }
}

function updateTable() {
  const sido = document.getElementById("sidoSelect").value;
  const sigungu = document.getElementById("sigunguSelect").value;
  let filtered = inguData.filter(d => (!sido || d.ì‹œë„ === sido) && (!sigungu || d.ì‹œêµ°êµ¬ === sigungu));

  // ì •ë ¬ ì ìš©
  if (currentSort.key) {
    filtered.sort((a, b) => {
      let valA = a[currentSort.key] || "";
      let valB = b[currentSort.key] || "";
      if (!isNaN(valA.replace(/,/g, '')) && !isNaN(valB.replace(/,/g, ''))) {
        valA = parseFloat(valA.replace(/,/g, ''));
        valB = parseFloat(valB.replace(/,/g, ''));
      }
      return currentSort.asc ? (valA > valB ? 1 : -1) : (valA < valB ? 1 : -1);
    });
  }

  const tbody = document.querySelector("#inguTable tbody");
  tbody.innerHTML = filtered.map(d => `
    <tr>
      <td>${d.ì‹œë„}</td><td>${d.ì‹œêµ°êµ¬ || ""}</td><td>${d.ìë©´ë™ || ""}</td>
      <td style="text-align:right">${d.ì´ì¸êµ¬ìˆ˜}</td><td style="text-align:right">${d.ì„¸ëŒ€ìˆ˜}</td><td style="text-align:right">${d.ì„¸ëŒ€ë‹¹ì¸êµ¬}</td>
    </tr>
  `).join("");

  updateHeaderArrows(); // ğŸ”½ or â–²â–¼ í‘œì‹œ
}

function sortTable(key) {
  if (currentSort.key === key) {
    currentSort.asc = !currentSort.asc;
  } else {
    currentSort.key = key;
    currentSort.asc = true;
  }
  updateTable();
  updateHeaderArrows();
}


function updateHeaderArrows() {
  const headerRow = document.getElementById("inguHeaderRow");
  const headers = headerRow.querySelectorAll("th");
  const keys = ["ì‹œë„", "ì‹œêµ°êµ¬", "ìë©´ë™", "ì´ì¸êµ¬ìˆ˜", "ì„¸ëŒ€ìˆ˜", "ì„¸ëŒ€ë‹¹ì¸êµ¬"];

  headers.forEach((th, i) => {
    const key = keys[i];
    let arrow = "â‡…"; // ê¸°ë³¸ ê¸°í˜¸
    if (currentSort.key === key) {
      arrow = currentSort.asc ? "â¬†" : "â¬‡"; // ì •ë ¬ ì¤‘ì¸ ì—´ì´ë©´ ë‹¨ì¼ ê¸°í˜¸
    }
    th.innerHTML = `${key} ${arrow}`;
    th.onclick = () => sortTable(key); // í´ë¦­ ì´ë²¤íŠ¸ ìœ ì§€
  });
}


// â–¼ í•„í„° ì…€ë ‰íŠ¸ ì°¸ì¡°

async function restoreRegionFiltersFromUIState() {
  const { sidoSel, sigunguSel } = getFilterEls();
  if (!sidoSel || !sigunguSel) return;

  let saved = null;
  try { saved = await getHongbuSetting(UI_STATE_KEY); } catch(e) { saved = null; }
  if (!saved || typeof saved !== 'object') return;

  const savedSido = (saved['sidoFilter'] ?? saved['sidoSelect'] ?? '').toString().trim();
  const savedSigungu = (saved['sigunguFilter'] ?? saved['sigunguSelect'] ?? '').toString().trim();

  // 1) ì‹œë„ ë³µì›
  if (savedSido && Array.from(sidoSel.options).some(o => o.value === savedSido)) {
    sidoSel.value = savedSido;
    // ì‹œë„ ê¸°ì¤€ìœ¼ë¡œ ì‹œêµ°êµ¬ ì˜µì…˜ ì¬ìƒì„±
    buildRegionFiltersFromApartments();
  }

  // 2) ì‹œêµ°êµ¬ ë³µì›
  if (savedSigungu && Array.from(sigunguSel.options).some(o => o.value === savedSigungu)) {
    sigunguSel.value = savedSigungu;
  }

  // 3) ì§€ë„/ë§ˆì»¤ì— ì¦‰ì‹œ ë°˜ì˜
  applyRegionFilterUpdate();
}

function getFilterEls() {
  return {
    sidoSel: document.getElementById('sidoFilter'),
    sigunguSel: document.getElementById('sigunguFilter'),
  };
}

// â–¼ ì˜µì…˜ ì±„ìš°ê¸° ìœ í‹¸
// â–¼ ì˜µì…˜ ì±„ìš°ê¸° ìœ í‹¸ (items: string | {value, label})
function fillOptions(selectEl, items) {
  const prev = selectEl.value;
  selectEl.innerHTML = '';

  // ì²« ì˜µì…˜: ì „ì²´(ë¹ˆê°’)
  const optAll = document.createElement('option');
  optAll.value = '';
  optAll.textContent = 'ì „ì²´';
  selectEl.appendChild(optAll);

  (items || []).forEach(item => {
    const opt = document.createElement('option');
    if (typeof item === 'string') {
      // ë¬¸ìì—´ë§Œ ì˜¨ ê²½ìš°: value/label ë™ì¼
      opt.value = item;
      opt.textContent = item;
    } else {
      // { value: ì½”ë“œê°’, label: í™”ë©´í‘œì‹œì´ë¦„ }
      opt.value = item.value;
      opt.textContent = item.label;
    }
    selectEl.appendChild(opt);
  });

  // ì´ì „ ì„ íƒ ìœ ì§€(ê°€ëŠ¥í•˜ë©´)
  if ([...selectEl.options].some(o => o.value === prev)) {
    selectEl.value = prev;
  } else {
    selectEl.value = '';
  }
}

// â–¼ ì‹œë„/ì‹œêµ°êµ¬ ì˜µì…˜ êµ¬ì„± (apartmentData ê¸°ë°˜)
//   - ì‹œë„: label=ì‹œë„ëª…(sidoNm), value=ì‹œë„ì½”ë“œ(sido)
//   - ì‹œêµ°êµ¬: label=ì‹œêµ°êµ¬ëª…(sigunguNm), value=ì‹œêµ°êµ¬ì½”ë“œ(sigungu)
function buildRegionFiltersFromApartments() {
  const { sidoSel, sigunguSel } = getFilterEls();
  if (!sidoSel || !sigunguSel || !Array.isArray(apartmentData)) return;

  // ì‹œë„ì½”ë“œ -> { name: ì‹œë„ëª…, sigungu: Map(ì‹œêµ°êµ¬ì½”ë“œ -> ì‹œêµ°êµ¬ëª…) }
  const bySido = new Map();
  apartmentData.forEach(a => {
    const sc = String(a.sido || '').trim();
    const sn = String(a.sidoNm || '').trim();
    const gc = String(a.sigungu || '').trim();
    const gn = String(a.sigunguNm || '').trim();
    if (!sc) return;
    if (!bySido.has(sc)) bySido.set(sc, { name: sn || sc, sigungu: new Map() });
    if (gc) bySido.get(sc).sigungu.set(gc, gn || gc);
  });

  // ì‹œë„ ì˜µì…˜: value=ì½”ë“œ, label=ì´ë¦„
  const sidoItems = Array.from(bySido.entries())
    .map(([code, obj]) => ({ value: code, label: obj.name }))
    .sort((a, b) => a.label.localeCompare(b.label, 'ko'));
  fillOptions(sidoSel, sidoItems);

  // ì„ íƒëœ ì‹œë„ì— ë”°ë¼ ì‹œêµ°êµ¬ ì˜µì…˜ ìƒì„±
  const selectedSidoCode = (sidoSel.value || '').trim();
  if (selectedSidoCode && bySido.has(selectedSidoCode)) {
    const sigunguItems = Array.from(bySido.get(selectedSidoCode).sigungu.entries())
      .map(([code, name]) => ({ value: code, label: name }))
      .sort((a, b) => a.label.localeCompare(b.label, 'ko'));
    fillOptions(sigunguSel, sigunguItems); // value=ì½”ë“œ, label=ì´ë¦„
    sigunguSel.disabled = false;
  } else {
    fillOptions(sigunguSel, []);
    sigunguSel.disabled = true;
  }
}


// â–¼ í•„í„° ë³€ê²½ ì´ë²¤íŠ¸
function applyRegionFilterUpdate() {
  // ì‹œë„/ì‹œêµ°êµ¬ í•„í„°ê°€ ë°”ë€Œë©´: ê¸°ì¡´ ë§ˆì»¤(ìºì‹œ)ë¥¼ ì¦‰ì‹œ ì œê±°í•˜ê³ , í˜„ì¬ boundsë¡œ ë‹¤ì‹œ ê·¸ë¦¼
  if (window.apartmentMarkers) {
    Object.values(window.apartmentMarkers).forEach(m => {
      try { if (m && typeof m.setMap === 'function') m.setMap(null); } catch(e) {}
    });
    window.apartmentMarkers = {};
  }
  try {
    if (window.markerCluster && typeof window.markerCluster.setMarkers === 'function') {
      window.markerCluster.setMarkers([]);
    }
  } catch(e) {}

  // ì„ íƒëœ ì§€ì—­ìœ¼ë¡œ ì§€ë„ ì´ë™(ê°€ëŠ¥í•˜ë©´)
  // âœ… mapPosition ë³µì› ì§í›„(ì´ˆê¸° ë¡œë”©)ì—ëŠ” region filterê°€ ì„¼í„°ë¥¼ ë®ì–´ì“°ì§€ ì•Šê²Œ ë³´í˜¸
  try { if (!window.__suppressAutoFocusRegion) focusMapToSelectedRegion(15); } catch(e) {}

  if (window.map && window.map.getBounds) {
    updateMarkers(window.map.getBounds());
  }
}

// â–¼ í•„í„° ë³€ê²½ ì´ë²¤íŠ¸
function attachRegionFilterEvents() {
  const { sidoSel, sigunguSel } = getFilterEls();
  if (!sidoSel || !sigunguSel) return;

  // ì‹œë„ ë³€ê²½ì‹œ: ì‹œêµ°êµ¬ ëª©ë¡ ì¬êµ¬ì„± + ì¦‰ì‹œ ë°˜ì˜
  sidoSel.addEventListener('change', (e) => {
    if (e && e.isTrusted) window.__suppressAutoFocusRegion = false; // âœ… ì‚¬ìš©ì ì§ì ‘ ë³€ê²½ì‹œì—ë§Œ ì§€ì—­ í¬ì»¤ì‹± í—ˆìš©
    buildRegionFiltersFromApartments();
    applyRegionFilterUpdate();
  });

  // ì‹œêµ°êµ¬ ë³€ê²½ì‹œ: 'ì „ì²´' í¬í•¨ ì¦‰ì‹œ ë°˜ì˜
  sigunguSel.addEventListener('change', (e) => {
    if (e && e.isTrusted) window.__suppressAutoFocusRegion = false; // âœ… ì‚¬ìš©ì ì§ì ‘ ë³€ê²½ì‹œì—ë§Œ ì§€ì—­ í¬ì»¤ì‹± í—ˆìš©
    applyRegionFilterUpdate();
  });
}


function getFilterEls() {
  return {
    sidoSel: document.getElementById('sidoFilter'),
    sigunguSel: document.getElementById('sigunguFilter'),
  };
}

// âœ… ì„ íƒëœ ì‹œêµ°êµ¬/ì‹œë„ì˜ "ì²« ë²ˆì§¸ ì•„íŒŒíŠ¸" ì¢Œí‘œë¡œ ì§€ë„ ì´ë™
function focusMapToSelectedRegion(zoomLevel = 15) {
  if (!window.map || !Array.isArray(apartmentData)) return;
  const { sidoSel, sigunguSel } = getFilterEls();
  const sigCode = (sigunguSel?.value || '').trim();
  const siCode  = (sidoSel?.value    || '').trim();

  let target = null;
  if (sigCode) {
    target = apartmentData.find(a => String(a.sigungu).trim() === sigCode);
  }
  if (!target && siCode) {
    target = apartmentData.find(a => String(a.sido).trim() === siCode);
  }
  if (!target) return;

  const center = new naver.maps.LatLng(parseFloat(target.lat), parseFloat(target.lng));
  window.map.setCenter(center);
  if (window.map.getZoom() < zoomLevel) {
    window.map.setZoom(zoomLevel);
  }
}
document.getElementById("unitFilter")
  .addEventListener("input", () => updateMarkers(window.map.getBounds()));


</script>
<script>


  // ğŸ”¹ ë„¤ì´í‹°ë¸Œ ì „ì²´í™”ë©´ì€ ì „í˜€ ì“°ì§€ ì•Šê³ ,
  //    pseudoFullscreenActive + toggleFullscreen() ì¡°í•©ë§Œ ì‚¬ìš©
  let pseudoFullscreenActive = false;

  function injectMaximizeButton() {
    const mapEl = document.getElementById('map');
    if (!mapEl) return;

    /* 1) ì „ì²´í™”ë©´(ìµœëŒ€í™”) ë²„íŠ¼ */
    if (!mapEl.querySelector('#mapMaxBtn')) {
      const maxBtn = document.createElement('button');
      maxBtn.id = 'mapMaxBtn';
      maxBtn.className = 'map-float-btn';
      maxBtn.title = 'ì „ì²´í™”ë©´';
      maxBtn.setAttribute('aria-label', 'ì§€ë„ ì „ì²´í™”ë©´');
      // ë„¤ì´í‹°ë¸ŒëŠ” ì•ˆ ì“°ë¯€ë¡œ pseudoFullscreenActiveë§Œ ê¸°ì¤€
      maxBtn.textContent = pseudoFullscreenActive ? 'â¤¡' : 'â¤¢';
      mapEl.appendChild(maxBtn);

      maxBtn.addEventListener('click', () => {
        // ì´ë¯¸ ê°€ì§œ ì „ì²´í™”ë©´ì´ë©´ â†’ í•´ì œ
        if (pseudoFullscreenActive) {
          if (typeof toggleFullscreen === 'function') {
            try { toggleFullscreen(); } catch (e) { console.warn(e); }
          }
          onExitPseudoFullscreen();
          return;
        }

        // í‰ìƒì‹œ â†’ ê°€ì§œ ì „ì²´í™”ë©´ ì§„ì…
        if (typeof toggleFullscreen === 'function') {
          try { toggleFullscreen(); } catch (e) { console.warn(e); }
        }
        onEnterPseudoFullscreen();
      });
    }


    // âœ… ì§ì „ ì „ì²´í™”ë©´ ìƒíƒœ ë³µì› (ì•± ì „í™˜/ìƒˆë¡œê³ ì¹¨ ëŒ€ë¹„)
    // injectMaximizeButton()ì€ ì—¬ëŸ¬ ë²ˆ ë¶ˆë¦´ ìˆ˜ ìˆìœ¼ë¯€ë¡œ 1íšŒë§Œ ìˆ˜í–‰
    if (!window.__hongbuFullscreenRestored) {
      window.__hongbuFullscreenRestored = true;
      try {
        getHongbuSetting(MAP_FULLSCREEN_KEY).then((v) => {
          if (v === true && !pseudoFullscreenActive) {
            // (ì„ íƒ) ê¸°ì¡´ ë¡œì§ ìœ ì§€: toggleFullscreenì´ ìˆë‹¤ë©´ í•¨ê»˜ í˜¸ì¶œ
            if (typeof toggleFullscreen === 'function') {
              try { toggleFullscreen(); } catch (e) { console.warn(e); }
            }
            onEnterPseudoFullscreen();
          }
        }).catch(console.warn);
      } catch (e) {
        console.warn(e);
      }
    }


    /* 2) í˜„ì¬ ìœ„ì¹˜ ë²„íŠ¼ */
    if (!mapEl.querySelector('#mapLocateBtn')) {
      const locBtn = document.createElement('button');
      locBtn.id = 'mapLocateBtn';
      locBtn.className = 'map-locate-btn';
      locBtn.title = 'í˜„ì¬ ìœ„ì¹˜';
      locBtn.setAttribute('aria-label', 'í˜„ì¬ ìœ„ì¹˜ ì°¾ê¸°');
      locBtn.textContent = 'ğŸ“';

      mapEl.appendChild(locBtn);
      locBtn.addEventListener('click', () => {
        if (typeof clickLocationButton === 'function') clickLocationButton();
      });
    }

    /* 3) ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€ ë²„íŠ¼ */
    if (!mapEl.querySelector('#mapStopBtn')) {
      const stopBtn = document.createElement('button');
      stopBtn.id = 'mapStopBtn';
      stopBtn.className = 'map-stoptrack-btn';
      stopBtn.title = 'ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€';
      stopBtn.setAttribute('aria-label', 'ìœ„ì¹˜ ì¶”ì  ì¤‘ì§€');
      stopBtn.textContent = 'ğŸ›‘';

      mapEl.appendChild(stopBtn);
      stopBtn.addEventListener('click', () => {
        if (typeof stopTracking === 'function') stopTracking();
      });
    }
  }

  // âœ… ê°€ì§œ ì „ì²´í™”ë©´ ì§„ì…/í•´ì œ ì‹œ UI ìƒíƒœë§Œ ê´€ë¦¬
  function onEnterPseudoFullscreen() {
    pseudoFullscreenActive = true;
    document.body.classList.add('fullscreen-active'); // ì´ë¯¸ CSSì—ì„œ ì´ í´ë˜ìŠ¤ë¥¼ ì“°ê³  ìˆìœ¼ë¯€ë¡œ ìœ ì§€
    const btn = document.getElementById('mapMaxBtn');
    if (btn) btn.textContent = 'â¤¡';  // ë‚˜ê°€ê¸° ì•„ì´ì½˜
    resizeMapToContainer();

    // âœ… ì „ì²´í™”ë©´ ìƒíƒœ ì €ì¥(ì•± ì „í™˜/ìƒˆë¡œê³ ì¹¨ ë³µì›ìš©)
    try { setHongbuSetting(MAP_FULLSCREEN_KEY, true); } catch(e) { console.warn(e); }
  }

  function onExitPseudoFullscreen() {
    pseudoFullscreenActive = false;
    document.body.classList.remove('fullscreen-active');
    const btn = document.getElementById('mapMaxBtn');
    if (btn) btn.textContent = 'â¤¢';  // ë“¤ì–´ê°€ê¸° ì•„ì´ì½˜
    resizeMapToContainer();

    // âœ… ì „ì²´í™”ë©´ ìƒíƒœ ì €ì¥(ì•± ì „í™˜/ìƒˆë¡œê³ ì¹¨ ë³µì›ìš©)
    try { setHongbuSetting(MAP_FULLSCREEN_KEY, false); } catch(e) { console.warn(e); }
  }

  function resizeMapToContainer() {
    const mapEl = document.getElementById('map');
    if (mapEl && window.map) {
      // inline styleë¡œ ì´ìƒí•˜ê²Œ ì»¤ì§€ëŠ” ê²ƒ ë°©ì§€
      mapEl.style.height = 'calc(100svh - 150px)';
      mapEl.style.maxHeight = 'calc(100svh - 150px)';

      setTimeout(() => {
        try {
          window.map.setSize(new naver.maps.Size(mapEl.clientWidth, mapEl.clientHeight));
        } catch (e) {
          console.warn(e);
        }
      }, 150);
    }
  }

  window.addEventListener('orientationchange', resizeMapToContainer);
  window.addEventListener('resize', resizeMapToContainer);





  function onEnterPseudoFullscreen(){
    pseudoFullscreenActive = true;
    document.body.classList.add('fullscreen-active');
    const btn = document.getElementById('mapMaxBtn');
    if (btn) btn.textContent = 'â¤¡';
    resizeMapToContainer();

    // âœ… ì „ì²´í™”ë©´ ìƒíƒœ ì €ì¥(ì•± ì „í™˜/ìƒˆë¡œê³ ì¹¨ ë³µì›ìš©)
    try { setHongbuSetting(MAP_FULLSCREEN_KEY, true); } catch(e) { console.warn(e); }
  }
  function onExitPseudoFullscreen(){
    pseudoFullscreenActive = false;
    document.body.classList.remove('fullscreen-active');
    const btn = document.getElementById('mapMaxBtn');
    if (btn) btn.textContent = 'â¤¢';
    resizeMapToContainer();

    // âœ… ì „ì²´í™”ë©´ ìƒíƒœ ì €ì¥(ì•± ì „í™˜/ìƒˆë¡œê³ ì¹¨ ë³µì›ìš©)
    try { setHongbuSetting(MAP_FULLSCREEN_KEY, false); } catch(e) { console.warn(e); }
  }
  function resizeMapToContainer(){
  const mapEl = document.getElementById('map');
  if (mapEl && window.map) {
    // inline styleë¡œ ì»¤ì§€ëŠ” ê±¸ ë°©ì§€
    mapEl.style.height = 'calc(100svh - 150px)';
    mapEl.style.maxHeight = 'calc(100svh - 150px)';

    setTimeout(() => {
      try {
        window.map.setSize(new naver.maps.Size(mapEl.clientWidth, mapEl.clientHeight));
      } catch(e){}
    }, 150);
  }
}

  window.addEventListener('orientationchange', resizeMapToContainer);
  window.addEventListener('resize', resizeMapToContainer);


// ===== EMD label position blend: polylabel + centroid (override) =====
function _emd_lerp(a, b, t){
  return [a[0] + (b[0]-a[0])*t, a[1] + (b[1]-a[1])*t];
}
function _emd_ringCentroidLngLat(ring){
  let area = 0, cx = 0, cy = 0;
  const n = ring.length;
  if (n < 3) return null;
  for (let i=0;i<n;i++){
    const [x1,y1]=ring[i];
    const [x2,y2]=ring[(i+1)%n];
    const a = x1*y2 - x2*y1;
    area += a;
    cx += (x1+x2)*a;
    cy += (y1+y2)*a;
  }
  area *= 0.5;
  if (Math.abs(area) < 1e-12) return null;
  return [cx/(6*area), cy/(6*area)];
}

// New function used by redraw (same name as before to override)
function getLabelLatLngByPolylabel(geometry, bbox){
  const polys = (geometry.type === "MultiPolygon") ? geometry.coordinates : [geometry.coordinates];
  let bestPoly = polys[0], bestArea = -1;
  for (const p of polys){
    const ring = p[0];
    let a = 0;
    for (let i=0;i<ring.length;i++){
      const [x1,y1]=ring[i], [x2,y2]=ring[(i+1)%ring.length];
      a += (x1*y2 - x2*y1);
    }
    a = Math.abs(a*0.5);
    if (a > bestArea){ bestArea = a; bestPoly = p; }
  }
  const p = _emd_polylabel(bestPoly, 1e-5);
  const c = _emd_ringCentroidLngLat(bestPoly[0]);
  let lnglat = p;
  if (p && c){
    const t = 0.35; // blend factor
    lnglat = _emd_lerp(p, c, t);
  }
  if (!lnglat && bbox){
    const [minLng, minLat, maxLng, maxLat] = bbox;
    lnglat = [(minLng+maxLng)/2, (minLat+maxLat)/2];
  }
  if (!lnglat) return null;
  return new naver.maps.LatLng(lnglat[1], lnglat[0]);
}

</script>



</body>
</html>




