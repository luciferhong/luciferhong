<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta id="dynamicViewport" name="viewport" content="width=device-width, initial-scale=0.85, user-scalable=no">

    <link rel="icon" href="route.png" type="image/png">
    <title>[루시퍼홍] 시세지도 Ver.2</title>
	<script src="https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=hcuap73kdc"></script>
	<script type="text/javascript" src="MarkerClustering.js"></script>



    <style>
        #map { width: 100%; height: calc(100vh - 160px); resize: both; }
        #controls { margin: 10px; }
        button { margin: 5px; padding: 10px; cursor: pointer; }

		/* 현재 위치 버튼 스타일 */
		#locationButton {
			position: absolute;
			top: 90px; /* 🔹 지도 내부의 상단 */
			left: 8px; /* 🔹 지도 내부의 왼쪽 */
			background-color: white;
			border: 2px solid gray;
			padding: 10px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 12px;
			text-align: center;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
			z-index: 1000; /* 🔹 지도 위에 표시 */
		}

		/* 위치 추적 종료 버튼 */
		#stopTrackingButton {
			position: absolute;
			top: 125px; /* 🔹 지도 내부의 상단 */
			left: 60px; /* 🔹 현재 위치 버튼과 간격 유지 */
			background-color: white;
			border: 2px solid gray;
			padding: 10px;
			border-radius: 50%;
			cursor: pointer;
			font-size: 14px;
			text-align: center;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
			z-index: 1000; /* 🔹 지도 위에 표시 */
		}


		#unitFilter {
			width: 45px; /* 숫자 3자리(최대 999) 입력 가능 */
			height: 10px;
			font-size: 16px;
			text-align: center;
			border: 2px solid #4A90E2; /* 파란색 테두리 */
			border-radius: 8px;
			padding: 5px;
			outline: none;
			transition: all 0.3s ease-in-out;
		}

		#unitFilter:focus {
			border-color: #2D5DA7; /* 포커스 시 더 진한 파란색 */
			box-shadow: 0px 0px 5px rgba(74, 144, 226, 0.5);
		}

	#controls {
    display: flex; /* ✅ 가로 정렬 */
    align-items: center; /* ✅ 내부 요소 세로 정렬 */
    gap: 10px; /* ✅ 요소 간격 조정 */
	}

	#scaleControls {
		display: flex; /* ✅ 가로 정렬 */
		align-items: center; /* ✅ 버튼이 체크박스와 같은 높이로 */
		margin-left: 5px; /* ✅ 간격 조정 */
	}

	#scaleControls button {
		width: 30px;
		height: 30px;
		font-size: 16px;
		font-weight: bold;
		background-color: white;
		border: 2px solid gray;
		border-radius: 5px;
		cursor: pointer;
		text-align: center;
		margin-left: 5px; /* ✅ 버튼 사이 간격 */
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
		display: flex;
		justify-content: center;
		align-items: center;
	}

	#scaleControls button:hover {
		background-color: #f0f0f0;
	}
	.fullscreen-btn {
		position: fixed;
		top: 170px;
		left: 20px;
		background-color: white;
		border: 2px solid gray;
		padding: 10px;
		border-radius: 50%;
		cursor: pointer;
		font-size: 14px;
		text-align: center;
		box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
		z-index: 10000; /* ✅ 최상단 유지 */
	}
#apartmentInfo {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 1px solid black;
    padding: 8px;
    width: auto;
    font-size: 16px;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    display: none;
    z-index: 10000;
    
    max-width: 90%;
    max-height: 50vh; /* ✅ 화면 높이의 80%까지 확장 */
    overflow-y: auto; /* ✅ 내부 스크롤 활성화 */
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch; /* ✅ iOS 부드러운 스크롤 */
}


#apartmentInfo table {
    width: auto; /* 🔹 표 크기를 내용에 맞게 자동 조정 */
    table-layout: auto; /* 🔹 테이블 레이아웃 자동 조정 */
    border-collapse: collapse;
}

#apartmentInfo th, #apartmentInfo td {
    border: 1px solid black;
    padding: 2px 5px; /* 🔹 내부 여백 최소화 */
    text-align: center;
    white-space: nowrap; /* 🔹 텍스트 줄바꿈 방지 */
}

#apartmentInfo th {
    background: #f0f0f0;
    font-weight: bold;
}

#apartmentInfo .close-button {
    position: absolute;
    top: 5px;
    right: 8px;
    background: red;
    color: white;
    border: none;
    font-size: 14px;
    padding: 3px 6px;
    cursor: pointer;
    border-radius: 3px;
}
table {
    border-collapse: collapse; /* ✅ 테두리 중복 제거 */
    width: 100%; /* ✅ 테이블 크기 조정 */
}

td, th {
    border: 1px solid black; /* ✅ 테두리 스타일 확인 */
    padding: 5px; /* ✅ 내부 여백 조정 */
    text-align: center;
    white-space: nowrap; /* ✅ 줄바꿈 방지 */
}
buttonContainer {
    display: flex;
    justify-content: center; /* ✅ 버튼들을 중앙 정렬 */
    gap: 10px; /* ✅ 버튼 간격 조정 */
    margin-top: 10px;
}
 #toggleSiseMapLabel {
    display: none;
  }
    </style>
</head>
<body>
<h1 style="font-size: 20px; font-weight: bold; text-align: left;">
    [루시퍼홍] 시세지도 Ver.2
</h1>

<div id="controls">
    <label for="unitFilter">최소세대수: </label>
    <input type="number" id="unitFilter" min="0" value="190">
    <label><input type="checkbox" id="toggleApartments" checked>아파트</label>
    <label><input type="checkbox" id="toggleSchools" >초</label>
	<label><input type="checkbox" id="toggleMiddleSchools" >중</label>
	<label><input type="checkbox" id="toggleFacilities">환경</label>
	<label><input type="checkbox" id="toggleStarbucks">스벅</label>
	<label id="toggleSiseMapLabel"><input type="checkbox" id="toggleSiseMap" checked>시세지도</label>





    <!-- ✅ 스케일 조정 버튼을 '초등학교' 체크박스 옆으로 이동 
    <div id="scaleControls">
		<label>배율</label>
        <button id="scaleUpButton">+</button>
        <button id="scaleDownButton">-</button>
    </div>
-->
</div>



    <div id="map"></div>
    <div id="controls">
        <button id="startPolyline" style="display: none;">경로 그리기</button>
		<button id="undoLastPointButton" style="display: none;">직전 취소</button>
        <button id="completePolyline" style="display: none;">경로 그리기 완료</button>
        <button id="downloadGPX" style="display: none;">GPX 다운로드</button>
        <button id="uploadGPX" style="display: none;">GPX 불러오기</button>
        <input type="file" id="gpxFileInput" style="display: none;" accept=".gpx">
        <button id="clearMap" style="display: none;">경로 초기화</button> 
<button id="siseExportBtn" style="display: block;">시세지도 백업</button>
<button id="siseImportBtn" style="display: block;">시세지도 복원</button>
<button id="siseResetBtn" style="display: block;">시세지도 초기화</button>
<button id="colorExportBtn" style="display: block;">색상 설정 백업</button>
<button id="colorImportBtn" style="display: block;">색상 설정 복원</button>
<button id="colorResetBtn" style="display: none;">색상 설정 초기화</button>
<button id="priceColorSettingsBtn">💰차트 색상 설정</button>
<button id="yearColorSettingsBtn">📅연식 색상 설정</button>



    </div>
    <div id="locationButton" title="현재 위치">📍</div> <!-- ✅ 현재 위치 버튼 -->
    <div id="stopTrackingButton" style="display:none" title="위치 추적 중지">🛑</div> <!-- ✅ 위치 추적 중지 버튼 -->
   

<div id="apartmentInfo" style="border: 1px solid black; padding: 10px; display:none">
    <p>아파트 정보를 확인하려면 마커를 클릭하세요.</p>
</div>

<script>
 class MapHandler {

		

            constructor(map) {
                this.map = map;
                this.shapes = [];
                this.currentPath = [];
                this.currentPolyline = null;
                this.markers = [];
                this.initUI();
            }
				
            initUI() {
				document.getElementById("startPolyline").addEventListener("click", () => this.startPolylineMode());
				document.getElementById("undoLastPointButton").addEventListener("click", () => this.undoLastPoint());
				document.getElementById("completePolyline").addEventListener("click", () => this.completePolyline()); // ✅ 추가됨*				
				document.getElementById("downloadGPX").addEventListener("click", () => this.downloadGPX());
				 // ✅ 시세지도 백업 (익스포트)
				document.getElementById("siseExportBtn").addEventListener("click", () => {
					exportHongSiseToJSON();
				});
				document.getElementById("colorExportBtn").addEventListener("click", () => {
					exportColorSettingsToJSON();
				});
				document.getElementById("colorImportBtn").addEventListener("click", () => {
					const input = document.createElement("input");
					  input.type = "file";
					  input.accept = ".json";
					  input.onchange = () => {
						const file = input.files[0];
						if (file) {
						  importFromJSONForColor(file);
						}
					  };
					  input.click();
					});
				document.getElementById("colorResetBtn").addEventListener("click", () => {
					resetColorSettingsDB();
				});


				// ✅ 시세지도 복원 (임포트)
				document.getElementById("siseImportBtn").addEventListener("click", () => {
					const input = document.createElement('input');
					input.type = 'file';
					input.accept = 'application/json';
					input.onchange = function (event) {
						const file = event.target.files[0];
						if (file) {
							importFromJSONToHongSise(file);
						}
					};
					input.click();
				});

				document.getElementById("siseResetBtn").addEventListener("click", () => {
					const confirmReset = confirm("⚠️ 시세 데이터를 초기화하면 복구할 수 없습니다. 시세지도 백업을 권장드립니다. \n계속하시겠습니까?");
					if (!confirmReset) return;

					const request = indexedDB.open("hongSise", 1);

					request.onsuccess = function (event) {
						const db = event.target.result;
						const storeNames = Array.from(db.objectStoreNames);
						const tx = db.transaction(storeNames, "readwrite");

						let clearCount = 0;
						let hasError = false;

						storeNames.forEach(storeName => {
							const store = tx.objectStore(storeName);
							const clearRequest = store.clear();

							clearRequest.onsuccess = () => {
								clearCount++;
								if (clearCount === storeNames.length && !hasError) {
									alert("✅ 시세지도 데이터가 전체 초기화되었습니다.");
									prevSiseMapState = "초기화";
									updateMarkers(window.map.getBounds());
								}
							};

							clearRequest.onerror = (e) => {
								console.error(`❌ ${storeName} 초기화 실패:`, e.target.error);
								hasError = true;
								alert(`❌ ${storeName} 초기화 중 오류 발생`);
							};
						});
					};

					request.onerror = function (event) {
						console.error("❌ hongSise DB 열기 실패:", event);
						alert("❌ 시세지도 DB 연결 실패");
					};
				});

	


				document.getElementById("uploadGPX").addEventListener("click", () => document.getElementById("gpxFileInput").click());

				// 🔹 `this`를 `MapHandler` 인스턴스로 유지
				document.getElementById("gpxFileInput").addEventListener("change", this.handleFileChange.bind(this));

				document.getElementById("clearMap").addEventListener("click", () => this.clearMap());
				
				document.addEventListener("keydown", (e) => {
					if (e.key === "Escape") {
						this.completePolyline();
					} else if (e.key === "Backspace") {
						this.undoLastPoint();
					}
				});

				naver.maps.Event.addListener(this.map, "click", (e) => {
					if (!this.currentPolyline) {
						console.warn("⚠️ 경로 그리기 모드가 아님");
						return; // 🚫 실행 중단 (오류 방지)
					}
					this.currentPath.push(e.coord);
					this.currentPolyline.setPath(this.currentPath);
					this.addMilestoneMarker(e.coord);
				});

				naver.maps.Event.addListener(this.map, "rightclick", () => {
					this.completePolyline();
				});

			
			}

			handleFileChange(event) {
				const file = event.target.files[0];
				if (!file) return; // 선택된 파일이 없으면 종료

				this.loadGPX(file);

				// 🔹 동일한 파일 다시 선택 가능하도록 input 값 초기화
				event.target.value = ""; 
			}


			startPolylineMode() {
				if (this.shapes.length > 0) {
					const userConfirmed = confirm("이전에 그린 경로가 삭제됩니다. 계속하시겠습니까?");
					if (!userConfirmed) return;

					this.clearMap(); // 기존 경로 초기화
				}

				this.currentPath = [];
				this.markers = [];
				this.currentPolyline = new naver.maps.Polyline({
					map: this.map,
					path: this.currentPath,
					strokeColor: "#FF0000",
					strokeWeight: 3.33,
					strokeOpacity: 0.8
				});	
			}
		
			downloadGPX() {
				if (this.shapes.length === 0) {
					alert("다운로드할 경로가 없습니다.");
					return;
				}

				let gpxData = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="MapHandler">\n  <trk>\n    <trkseg>\n`;
				
				this.shapes.forEach(({ polyline }) => {
					polyline.getPath().forEach((coord) => {
						gpxData += `      <trkpt lat="${coord.y}" lon="${coord.x}"></trkpt>\n`;
					});
				});

				gpxData += `    </trkseg>\n  </trk>\n</gpx>`;
				
				const blob = new Blob([gpxData], { type: "application/gpx+xml" });
				const a = document.createElement("a");
				a.href = URL.createObjectURL(blob);
				a.download = "route.gpx";
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
			}

            completePolyline() {
                if (this.currentPolyline && this.currentPath.length > 1) {
                    this.addStartEndMarkers();
                    this.shapes.push({ polyline: this.currentPolyline, markers: [...this.markers] });
                    this.currentPolyline = null;
                }
            }

            addMilestoneMarker(coord) {
                const marker = new naver.maps.Marker({
                    position: coord,
                    map: this.map,
                    icon: {
                        content: `<div style="width: 8px; height: 8px; background-color: #FF0000; border-radius: 50%; border: 2px solid #FFF;"></div>`,
                        anchor: new naver.maps.Point(4, 4)
                    }
                });
                this.markers.push(marker);
            }

            addStartEndMarkers() {
                if (this.currentPath.length < 2) return;
                this.createLabeledMarker(this.currentPath[0], "출발");
                this.createEndMarker(this.currentPath[this.currentPath.length - 1]);
            }

            createLabeledMarker(coord, label) {
                const marker = new naver.maps.Marker({
                    position: coord,
                    map: this.map,
                    icon: {
                        content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
                                    <span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
                                  </div>`
                    }
                });
                this.markers.push(marker);
            }
			clearMap() {
				if (!Array.isArray(this.shapes)) {
					this.shapes = []; // shapes가 배열이 아니면 초기화
				}

				// 기존 경로 및 마커 제거
				this.shapes.forEach(({ polyline, markers }) => {
					if (polyline) polyline.setMap(null);
					if (Array.isArray(markers)) {
						markers.forEach(marker => marker.setMap(null));
					}
				});

				// 🔹 출발 & 도착 마커 삭제
				if (Array.isArray(this.markers)) {
					this.markers.forEach(marker => marker.setMap(null));
				}

				// 🔹 도착 마커 삭제 추가
				if (this.endMarker) {
					this.endMarker.setMap(null);
					this.endMarker = null; // 도착 마커 변수 초기화
				}

				// 데이터 초기화
				this.shapes = [];
				this.markers = [];
				this.currentPath = [];
				this.currentPolyline = null;
			}

		loadGPX(file) {

			this.clearMap();
			const reader = new FileReader();
			reader.onload = (event) => {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(event.target.result, "text/xml");

				const trkpts = xmlDoc.getElementsByTagName("trkpt");
				if (trkpts.length === 0) {
					alert("유효한 GPX 파일이 아닙니다.");
					return;
				}

				let path = [];
				for (let i = 0; i < trkpts.length; i++) {
					const lat = parseFloat(trkpts[i].getAttribute("lat"));
					const lon = parseFloat(trkpts[i].getAttribute("lon"));
					path.push(new naver.maps.LatLng(lat, lon));
				}

				this.drawGPXPath(path);
				this.updateEndMarker(path); // 🔹 GPX 로드 후 도착 마커 업데이트
			};
			reader.readAsText(file);
		}

		updateEndMarker(path) {
			if (path.length < 2) return; // 유효한 경로가 없으면 종료

			const totalDistance = this.calculateTotalDistance(path); // 거리 재계산
			const formattedDistance = totalDistance >= 1000 
				? (totalDistance / 1000).toFixed(2) + "km" 
				: totalDistance.toFixed(0) + "m";

			const estimatedTime = this.calculateWalkingTime(totalDistance / 1000); // 예상 시간 계산
			const label = `도착<br>${formattedDistance}<br>${estimatedTime}<br>(시속 4km 기준)`;

			// 기존 도착 마커 삭제
			if (this.endMarker) this.endMarker.setMap(null);

			// 새 도착 마커 추가
			this.endMarker = new naver.maps.Marker({
				position: path[path.length - 1],
				map: this.map,
				icon: {
					content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
								<span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
							  </div>`
				}
			});
		}




		drawGPXPath(path) {
			if (path.length < 2) {
				alert("경로 데이터가 충분하지 않습니다.");
				return;
			}

			const polyline = new naver.maps.Polyline({
				map: this.map,
				path: path,
				strokeColor: "#0000FF", // GPX 경로 색상 (파란색)
				strokeWeight: 3.33,
				strokeOpacity: 0.8
			});

			this.shapes.push({ polyline });

			this.createLabeledMarker(path[0], "출발");
			this.createEndMarker(path[path.length - 1]);
		}

		createEndMarker(coord) {
			const totalDistance = this.calculateTotalDistance(); // m 단위로 가져옴
			const formattedDistance = totalDistance >= 1000 
				? (totalDistance / 1000).toFixed(2) + "km" 
				: totalDistance.toFixed(0) + "m";

			const estimatedTime = this.calculateWalkingTime(totalDistance / 1000); // km 단위로 변환
			const label = `도착<br>${formattedDistance}<br>${estimatedTime}<br>(시속 4km 기준)`;

			const marker = new naver.maps.Marker({
				position: coord,
				map: this.map,
				icon: {
					content: `<div style="padding:5px; background-color:#fff; border:1px solid #000; text-align:center;">
								<span style="font-size:12px; font-weight:bold; color:#f00;">${label}</span>
							  </div>`
				}
			});
			this.markers.push(marker);
		}


		calculateTotalDistance(path = this.currentPath) {
			if (!Array.isArray(path) || path.length < 2) {
				return 0; // 🔹 경로가 없으면 거리 0 반환
			}

			let total = 0;
			for (let i = 1; i < path.length; i++) {
				total += this.computeDistance(path[i - 1], path[i]);
			}
			return total; // 거리 반환 (m 단위)
		}




		computeDistance(coord1, coord2) {
			const R = 6371000;
			const lat1 = coord1.y * Math.PI / 180;
			const lat2 = coord2.y * Math.PI / 180;
			const deltaLat = (coord2.y - coord1.y) * Math.PI / 180;
			const deltaLng = (coord2.x - coord1.x) * Math.PI / 180;

			const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
					  Math.cos(lat1) * Math.cos(lat2) *
					  Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return R * c;
		}

        calculateWalkingTime(distanceKm) { 
			const speed = 4; // 시속 4km
			const hours = Math.floor(distanceKm / speed);
			const minutes = Math.round((distanceKm % speed) * 60 / speed);
			return (hours > 0 ? `${hours}시간 ${minutes}분` : `${minutes}분`);
		}


        undoLastPoint() {
			if (this.currentPath.length > 0) {
				this.currentPath.pop(); // 마지막 좌표 삭제
				this.currentPolyline.setPath(this.currentPath); // 반영

				// 마지막 마커 삭제
				const lastMarker = this.markers.pop();
				if (lastMarker) lastMarker.setMap(null);
			}
		}

    }


	document.addEventListener("DOMContentLoaded", async () => {
		
	});



	const mapElement = document.getElementById('map');

	function getMapSize() {
		return new naver.maps.Size(mapElement.offsetWidth, mapElement.offsetHeight);
	}

	let isTracking = false; // ✅ 위치 추적 여부 (true: 추적 중)

	document.getElementById("locationButton").addEventListener("click", () => {
		if (!window.map || !(window.map instanceof naver.maps.Map)) {
			console.error("네이버 지도 객체가 올바르게 초기화되지 않았습니다.");
			return;
		}

		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(
				(position) => {
					updateUserLocation(position, true); // ✅ 강제 이동 (true)
					startTracking(); // ✅ 위치 추적 시작
				},
				(error) => {
					alert("현재 위치를 찾을 수 없습니다. 위치 권한을 확인하세요.");
				}
			);
		} else {
			alert("이 브라우저에서는 위치 정보를 지원하지 않습니다.");
		}
	});

	function startTracking() {
		if (navigator.geolocation) {
			isTracking = true; // ✅ 위치 추적 활성화
			window.watchId = navigator.geolocation.watchPosition(
				(position) => {
					updateUserLocation(position, false); // ✅ 센터 이동 X (false)
				},
				(error) => {
					alert("실시간 위치 추적에 실패했습니다.");
				},
				{ enableHighAccuracy: true }
			);
			//console.log("위치 추적 시작 (watchId):", window.watchId);
		}
	}

	function stopTracking() {
		if (window.watchId !== null) {
			navigator.geolocation.clearWatch(window.watchId);
			//console.log("위치 추적이 중지되었습니다. watchId:", window.watchId);
			window.watchId = null;
			isTracking = false; // ✅ 위치 추적 비활성화

			// ✅ 마커 제거
			if (window.currentLocationMarker) {
				window.currentLocationMarker.setMap(null);
				window.currentLocationMarker = null;
			}
		} else {
			console.warn("위치 추적이 이미 중지된 상태입니다.");
		}
	}

	// ✅ "위치 추적 중지" 버튼 이벤트
	document.getElementById("stopTrackingButton").addEventListener("click", stopTracking);

	function updateUserLocation(position, forceCenter = false) {
		const lat = position.coords.latitude;
		const lon = position.coords.longitude;
		const currentLocation = new naver.maps.LatLng(lat, lon);

		//console.log("현재 위치 업데이트:", currentLocation, "강제 이동 여부:", forceCenter);

		// ✅ 위치 추적 중이 아니거나, 강제 이동 플래그가 true일 때만 지도 중심 이동
		if (!isTracking || forceCenter) {
			window.map.setCenter(currentLocation);
			window.map.setZoom(16);
		}

		// ✅ 기존 마커 삭제
		if (window.currentLocationMarker) {
			window.currentLocationMarker.setMap(null);
		}

		// ✅ 현재 위치 마커 추가
		window.currentLocationMarker = new naver.maps.Marker({
			position: currentLocation,
			map: window.map,
			icon: {
				content: `<div style="width: 14px; height: 14px; background-color: red; border-radius: 50%; border: 3px solid white;"></div>`,
				anchor: new naver.maps.Point(7, 7)
			}
		});
	}


	let map; // ✅ 전역 변수 설정
	let watchId = null; // ✅ 전역 변수로 위치 추적 ID 저장

	let locationCircle = null; // ✅ 반경 500m 원 객체 저장
	let currentLocationMarker = null; // ✅ 현재 위치 마커 저장

	let apartmentData = []; // ✅ 전체 아파트 데이터 저장
	let apartmentMarkers = []; // ✅ 지도에 표시된 마커 저장
	let markerCluster = null; // ✅ 마커 클러스터링 객체

	// ✅ 2. 아파트 데이터를 fetch()로 가져오기
	async function loadApartments() { 
    
		try {
			//const response = await fetch("https://your-github-username.github.io/data/apt.json"); // ✅ JSON 파일 사용
			const response = await fetch("apt.json");
			const data = await response.json();

			apartmentData = data.map((apt, index) => ({
				id: apt.id,
				name: apt.name, // ✅ 올바른 속성 접근
				year: apt.year, // ✅ 올바른 속성 접근
				units: parseInt(apt.units, 10), // ✅ 올바른 속성 접근
				lat: parseFloat(apt.lat), // ✅ 올바른 속성 접근
				lng: parseFloat(apt.lng), // ✅ 올바른 속성 접근
				lease: apt.lease // ✅ 올바른 속성 접근
			}));

			
			//console.log("✅ 아파트 데이터 fetch 완료");
			updateMarkers(window.map.getBounds())
		} catch (error) {
			console.error("❌ 아파트 데이터 불러오기 실패:", error);
		}
	}



function closePopup() {
  //console.log("호출")
    isPopupOpen = false;
    if (activeMarkerSet) {

        activeMarkerSet = null;
    }
    //console.log("❌ 이동 모드 종료");
}

function makeModalDraggable(modal) {
        let isDragging = false;
        let offsetX, offsetY;

        const header = document.createElement('div');
        header.className = 'draggable';
        header.style.padding = '10px';
        header.style.cursor = 'move';
        header.style.backgroundColor = '#f1f1f1';
        header.style.borderBottom = '1px solid #ccc';
        header.textContent = 'Drag me';

        modal.insertBefore(header, modal.firstChild);

        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - modal.offsetLeft;
            offsetY = e.clientY - modal.offsetTop;
            document.addEventListener('mousemove', moveModal);
            document.addEventListener('mouseup', stopDragging);
        });

        function moveModal(e) {
            if (isDragging) {
                modal.style.left = `${e.clientX - offsetX}px`;
                modal.style.top = `${e.clientY - offsetY}px`;
            }
        }

        function stopDragging() {
            isDragging = false;
            document.removeEventListener('mousemove', moveModal);
            document.removeEventListener('mouseup', stopDragging);
        }
    }


// ✅ 시세 마커에서 테이블이 아닌 영역을 우클릭하면 색상 선택 모달 표시
function addSiseMapMarkerLeftClickEvent(marker, markerElement) {
//console.log("addSiseMapMarkerLeftClickEvent 실행됨");
    naver.maps.Event.addListener(marker, "click", (e) => {
        e.domEvent.preventDefault(); // 기본 우클릭 메뉴 방지
        e.domEvent.stopPropagation();

        const tableContainer = markerElement.querySelector(".tableContainer");

        // ✅ 테이블 영역을 클릭한 경우 색상 선택 모달을 띄우지 않음
        if (e.domEvent.target.closest(".tableContainer")) {
            return;
        }

        //console.log("🚀 마커 우클릭 감지:", markerElement.dataset);

        let apartmentId = markerElement.dataset.apartmentId;
        if (!apartmentId) {
            console.error("❌ apartmentId 찾을 수 없음!");
            return;
        }

        showColorPickerModal(apartmentId, markerElement.style.backgroundColor, markerElement.style.color, markerElement.style.fontSize, 
			(selectedColor, textColor, fontSize) => {
				markerElement.style.backgroundColor = selectedColor;
				markerElement.style.color = textColor;
				markerElement.style.fontSize = fontSize;

				updateMarkerStyleAndSave(apartmentId, selectedColor, textColor, fontSize); // ✅ apartmentId가 정상적으로 전달됨
			});



    });
}

function updateMarkerStyleAndSave(id, selectedColor, textColor, fontSize) {
    getFromIndexedDB(id, "시세1").then(existingData => {
        let existingText = existingData?.text || generateDefaultTable();

        // ✅ 기본값 강제 적용
        selectedColor = selectedColor?.trim() || '#9F9F9F';
        textColor = textColor?.trim() || '#FFFFFF';
        fontSize = fontSize?.trim() || '12px';

        //console.log(`🎨 마커 스타일 업데이트 시도 (ID: ${id})`, { selectedColor, textColor, fontSize });

        // ✅ IndexedDB 저장
        saveToIndexedDB(id, "시세1", existingText, selectedColor, textColor, fontSize);

        // ✅ 마커 스타일 즉시 업데이트
        let markerElement = document.querySelector(`[data-apartment-id='${id}']`);
        if (!markerElement) {
            console.error(`❌ 마커를 찾을 수 없습니다. ID: ${id}`);
            return;
        }

        // ✅ 💡 중요: 글자 색상 및 크기 즉시 반영
        markerElement.style.backgroundColor = selectedColor;
        markerElement.style.color = textColor;
        markerElement.style.setProperty("color", textColor, "important"); // ✅ 즉시 적용 (중요도 높이기)
        markerElement.style.setProperty("font-size", fontSize, "important");

        markerElement.style.setProperty("font-size", fontSize, "important"); // ✅ 즉시 적용 (중요도 높이기)


        // ✅ 내부 테이블의 글자색 & 크기 즉시 반영
        let tableContainer = markerElement.querySelector(".tableContainer");
        if (tableContainer) {
            tableContainer.style.color = textColor;
            tableContainer.style.fontSize = fontSize;
            tableContainer.style.setProperty("font-size", fontSize, "important");
        }

    }).catch(error => {
        console.error("❌ IndexedDB 불러오기 실패:", error);
    });
}








// ✅ 기본 마커 생성 (시세지도 체크 해제 시)
function createDefaultMarker(apartment) {
    let yearValue = parseInt(apartment.year.slice(2), 10);
    let bgColor = "#FFFA00"; // yellow
    let fongColor = "white";

    if (yearValue > 50) bgColor = "#5C6267";
    else if (yearValue >= 20) bgColor = "#3E24D7";
    else if (yearValue >= 10) bgColor = "#EE1A24";

    if (yearValue >= 00 && yearValue < 10) fongColor = "black"; 

    const markerElement = document.createElement("div");
	markerElement.style = `
		background-color: ${bgColor};
		color: ${fongColor};
		border-radius: 6px;
		padding: 0px;
		border: 3px  black;  /* ✅ 테두리 두께 2px, 검정색 */
		text-align: center;
		font-size: 12px;
		font-weight: bold;
		box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
		white-space: nowrap;
		display: inline-block;
	`;

	const nameElement = document.createElement("div");
	nameElement.style = `
		background: white;
		color: black;
		font-size: 12px;
		font-weight: bold;
		display: flex; /* ✅ Flexbox 사용 */
		align-items: center;
		justify-content: center;
		padding: 2px 5px; /* ✅ 최소 패딩 유지 */
		border-radius: 3px;
		min-width: 85px; /* ✅ 최소 너비 고정 */
		max-width: 85px; /* ✅ 최대 너비 고정 */
		overflow: hidden;
		text-overflow: ellipsis;
	`;

	const detailsElement = document.createElement("div");
	detailsElement.style = `
		font-size: 12px;
		padding: 2px 5px;
		min-width: 85px; /* ✅ 세부 정보도 최소 크기 동일 */
		max-width: 85px;
		display: flex;
		justify-content: center;
	`;


    nameElement.textContent = apartment.name.length > 7 ? apartment.name.slice(0, 6) + "..." : apartment.name;
    detailsElement.textContent = `${apartment.year.slice(-5)} ${apartment.units}세대`;

    markerElement.appendChild(nameElement);
    markerElement.appendChild(detailsElement);


		// ✅ 마커 클릭 시 가로 길이 확장 → 3초 후 다시 축소
    

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: markerElement,
            anchor: new naver.maps.Point(10, 30)
        }
    });
	marker.apartmentId = apartment.id; // ✅ 마커 객체에 직접 ID 저장

	naver.maps.Event.addListener(marker, "click",  function(e) {
		showApartmentInfo(apartment.id, {
			x: e.offset.x,
			y: e.offset.y
		});
	});

	addMarkerRightClickEvent(marker, markerElement); // ✅ 마커 선택 이벤트 등록

	return marker;
}


let prevSiseMapState = null; // 🔹 전역 변수로 이전 시세지도 상태 저장


function removeLinesAllBounds(bounds) {
    Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        //const position = marker.getPosition();
        //const line = marker.lineToOrigin;

        //const isMarkerInside = bounds.hasLatLng(position);

   
            //console.log(`❌ 마커 제거됨: ${id}`);
			if(marker.movementLine){
				marker.movementLine.setMap(null);
				marker.movementLine = null;
			}
            marker.setMap(null);
            delete apartmentMarkers[id];

            // 선도 같이 제거
           
                //console.log(`❌ 선도 같이 제거됨: ${id}`);
               
        
    });
}

function removeLinesOutsideBounds(bounds) {
    Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        const position = marker.getPosition();
        const line = marker.lineToOrigin;

        const isMarkerInside = bounds.hasLatLng(position);

        // 마커가 bounds 바깥이면
        if (!isMarkerInside) {
            //console.log(`❌ 마커 제거됨: ${id}`);
			if(marker.movementLine){
				marker.movementLine.setMap(null);
				marker.movementLine = null;
			}
            marker.setMap(null);
            delete apartmentMarkers[id];

            // 선도 같이 제거
            if (line) {
                //console.log(`❌ 선도 같이 제거됨: ${id}`);
                line.setMap(null);
                delete marker.lineToOrigin;
            }
        }
    });
}

function removeAllLines() {
	
     Object.entries(apartmentMarkers).forEach(([id, marker]) => {
        const position = marker.getPosition();
        const isMarkerInside = window.map.getBounds().hasLatLng(position);

        if (isMarkerInside) {
            // 🔥 범위 안의 마커에 연결된 이동선 제거
            if (marker.movementLine) {
                marker.movementLine.setMap(null);
                marker.movementLine = null;
                //console.log(`🧹 ${id}의 이동선 제거됨`);
            }
        }
    });
}

	// ✅ 3. 지도 이동할 때마다 범위 내 아파트만 마커로 표시
	function updateMarkers(bounds, all = false) {
		if(all == false){
		console.log("부분삭제");
			removeLinesOutsideBounds(bounds);
		}else if(all == true){
		console.log("전체삭제");
			removeLinesAllBounds(bounds);
		}
		//범위 벗어나면 마커 삭제


		const minUnits = parseInt(document.getElementById("unitFilter").value, 10) || 0;
		const showApartments = document.getElementById("toggleApartments").checked;
		const isSiseMapActive = document.getElementById("toggleSiseMap").checked;

		if (!showApartments || window.map.getZoom() < 14) return;

		const filtered = apartmentData.filter(apartment =>
			bounds.hasLatLng(new naver.maps.LatLng(apartment.lat, apartment.lng)) &&
			apartment.units >= minUnits
		);

		const newMarkers = [];

		// ✅ 시세지도 체크 상태가 바뀐 경우 → 모든 마커 제거
		if (prevSiseMapState !== isSiseMapActive) {
			Object.values(apartmentMarkers).forEach(marker => {
				if (marker instanceof naver.maps.Marker) {
					naver.maps.Event.clearInstanceListeners(marker);
					marker.setMap(null);
				}
			});
			apartmentMarkers = {}; // 캐시 초기화
			prevSiseMapState = isSiseMapActive; // 상태 갱신
		}

		// ✅ 새 마커 생성 or 재사용
		filtered.forEach(apartment => {
			let marker = apartmentMarkers[apartment.id];

			if (!marker) {
				marker = isSiseMapActive
					? renderSiseMapMarker(apartment)
					: createDefaultMarker(apartment);

				marker.__siseMap = isSiseMapActive;
				apartmentMarkers[apartment.id] = marker;
			}

			newMarkers.push(marker);
		});


		if (markerCluster) {
			markerCluster.setMarkers(newMarkers);
		}



	}




let schoolMarkers = []; // ✅ 지도에 표시된 학교 마커 저장

async function loadSchools() {
    try {
        const response = await fetch("eliSchools.json");
        const schools = await response.json();
        
        //console.log("✅ 학교 데이터 로드 완료", schools);

        window.schoolData = schools; // ✅ 전체 학교 데이터 저장

        // ✅ 초기 마커 업데이트
        updateSchoolMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 학교 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateSchoolMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 학교 데이터 로드 실패:", error);
    }
}

function updateSchoolMarkers() {
    const showSchools = document.getElementById("toggleSchools").checked;

    // ✅ 기존 학교 마커 제거
    schoolMarkers.forEach(marker => marker.setMap(null));
    schoolMarkers = [];

    if (!showSchools) return; // 초등학교 표시 체크 해제 시 종료
	if (window.map.getZoom() < 14) { 
			return; // ✅ 줌 레벨이 14보다 작으면 실행 중단
	}
    let bounds = window.map.getBounds();
    let filteredSchools = window.schoolData.filter(school =>
        bounds.hasLatLng(new naver.maps.LatLng(school.latitude, school.longitude))
    );

    filteredSchools.forEach(school => {
    // ✅ 마커 컨테이너를 markerElement로 활용
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = "eliSchool.png";
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;
    infoBox.textContent = `${school.schoolName.replace(/등학교/g, "")} (${school.studentCountPerClassroom}/${school.totalStudentCount})`;

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(school.latitude, school.longitude),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // ✅ 우클릭 이벤트에 markerElement 전달 (테두리 활성화 가능)
    addMarkerRightClickEvent(marker, markerElement);

    schoolMarkers.push(marker);
});

}


// ✅ 페이지 로드 시 실행
document.addEventListener("DOMContentLoaded", async () => {
	

window.map = new naver.maps.Map("map", {
			center: new naver.maps.LatLng(37.5665, 126.9780),
			zoom: 15
		});

		// ✅ `MapHandler` 클래스 생성 후 지도 객체와 연결
		new MapHandler(window.map);

		// ✅ 아파트 데이터 불러오기
		

		// ✅ 지도 이동 시 현재 범위 내 아파트 마커 업데이트
		naver.maps.Event.addListener(window.map, "idle", () => {
			const bounds = window.map.getBounds();
			updateMarkers(bounds);
		});

		console.log("✅ 네이버 지도 초기화 완료.");


    await loadSchools();
    await loadMiddleSchools();
	await loadApartmentsDetail();
    await loadFacilities();
    await loadStarbucks();
	await initIndexedDB();


	try {
		await initColorSettingsDB(); // DB 연결
 console.log("초기화");
		const settings = await loadColorSettingsFromDB(); // DB에서 불러오기
console.log("로드");
		if (settings) {
		  priceColorSettings = settings; // 메모리에 저장
		  console.log("🎨 초기 색상 설정 불러옴:", priceColorSettings);
		} else {
		  console.log("ℹ️ 저장된 색상 설정 없음, 기본값 사용");
		}
	  } catch (e) {
		console.error("❌ 색상 설정 초기화 실패", e);
	  }


try {
	  //await initColorSettingsDB(); // DB 연결
	  window.yearColorSettings = await loadYearColorSettingsFromDB();
	  
	} catch (e) {
	  console.error("❌ 연식 색상 설정 초기화 실패", e);
	}



	if (window.map) {
        setupRightClickEvent();
    } else {
        // ✅ 지도 로드 후 이벤트를 추가하는 방식
        const checkMapLoaded = setInterval(() => {
            if (window.map) {
                clearInterval(checkMapLoaded);
                setupRightClickEvent();
            }
        }, 100); // 🔹 100ms 간격으로 지도 로드 확인
    }


await loadApartments();

});

document.getElementById("toggleApartments").addEventListener("change", () => {
    updateMarkers(window.map.getBounds()); // ✅ 즉시 업데이트
});

document.getElementById("toggleSchools").addEventListener("change", () => {
    updateSchoolMarkers(); // ✅ 즉시 업데이트
});

let observer = new ResizeObserver(() => {
    if (window.map) {
        let mapElement = document.getElementById("map");
        let width = mapElement.clientWidth;
        let height = mapElement.clientHeight;
        window.map.setSize(new naver.maps.Size(width, height)); // 지도 크기 업데이트
		//console.log("지도 변함");
    }
});

// `#map` 요소의 크기 변화를 감지하여 자동 업데이트
observer.observe(document.getElementById("map"));

let isFullscreen = false; // 현재 전체 화면 여부 저장
let originalHeight = document.getElementById("map").style.height; // 기존 지도 높이 저장

function toggleFullscreen() {
    let mapElement = document.getElementById("map");

    if (!isFullscreen) {
        // 🔹 전체 화면 모드로 전환
        originalHeight = mapElement.style.height; // 원래 높이 저장
        mapElement.style.position = "fixed";
        mapElement.style.top = "0";
        mapElement.style.left = "0";
        mapElement.style.width = "100vw";
        mapElement.style.height = "100vh";
        mapElement.style.zIndex = "9999";
        document.body.style.overflow = "hidden"; // 스크롤 방지
        isFullscreen = true;
    } else {
        // 🔹 원래 상태로 복귀
        mapElement.style.position = "";
        mapElement.style.top = "";
        mapElement.style.left = "";
        mapElement.style.width = "100%";
        mapElement.style.height = originalHeight; // 저c장된 높이 복원
        mapElement.style.zIndex = "";
        document.body.style.overflow = ""; // 스크롤 가능하게 설정
        isFullscreen = false;
    }

    // 지도 크기 갱신
    window.map.setSize(new naver.maps.Size(mapElement.clientWidth, mapElement.clientHeight));
}






let apartmentDetailData = {};

// JSON 데이터 로드
async function loadApartmentsDetail() {
    try {
        //console.log("📌 JSON 데이터 로드 시작");

        // 🔹 두 개의 JSON 파일 fetch()
        const [res1, res2] = await Promise.all([
            fetch("apartments1.json").then(res => res.json()),
            fetch("apartments2.json").then(res => res.json())
        ]);

        // 🔹 JSON 병합 (Object.assign() 사용)
        apartmentDetailData = Object.assign({}, res1, res2);

        //console.log("✅ 아파트 데이터 로드 완료:", apartmentDetailData);

        // 🔹 마커 업데이트
        updateMarkers(window.map.getBounds());

    } catch (error) {
        console.error("❌ 아파트 데이터 불러오기 실패:", error);
    }
}

   
// 마커 클릭 시 정보 표시
function showApartmentInfo(apartmentId, markerPosition) {
//console.log(apartmentId)
	// ✅ 시세 지도가 체크되어 있으면 아파트 정보 표시 안 함
    if (document.getElementById("toggleSiseMap").checked) {
        //console.log("🚫 시세 지도가 활성화되어 있어 아파트 정보 표시 안 함");
        return;
    }
    apartmentId = String(apartmentId);
    if (!apartmentDetailData[apartmentId]) {
        alert("데이터를 찾을 수 없습니다.");
        return;
    }

    let apt = apartmentDetailData[apartmentId];
	//let aptInfo = apartmentData[apartmentId];
	let aptInfo = apartmentData.find(apartment => String(apartment.id) === apartmentId);

    let leaseInfo = aptInfo ? aptInfo.lease : "정보 없음"; // ✅ lease 정보 가져오기
    let typeInfo = apt.타입정보 || [];

    let infoHtml = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; text-align: left;">${apt.아파트명}</h3>
            <button onclick="openNaverRealEstate(${apartmentId})" 
                style="padding: 8px; background: #4A90E2; color: white; border: none; border-radius: 4px; cursor: pointer;">
                네부 바로가기
            </button>
        </div>
        <p>입주시기: ${apt.입주시기}</p>
        <p>총세대수: ${apt.총세대수} (임대 : ${leaseInfo})</p>
        <table style="width: 100%; border-collapse: collapse;">
            <tr>
                <th>공급평수</th>
                <th>공급㎡</th>
                <th>전용㎡</th>
                <th>구조</th>
                <th>방</th>
                <th>화</th>
                <th>타입</th>
                <th>세대수</th>
            </tr>`;

    typeInfo.forEach(type => {
        infoHtml += `
            <tr>
                <td>${type["공급평수"]}</td>
				<td>${type["공급면적"]}</td>
                <td>${type["전용면적"]}</td>
                <td>${type["구조"]}</td>
                <td>${type["방 갯수"]}</td>
                <td>${type["화장실 갯수"]}</td>
                <td>${type["타입"]}</td>
                <td>${type["평형 세대수"]}</td>
            </tr>`;
    });

	

    infoHtml += `</table>`;



	

    let infoDiv = document.getElementById("apartmentInfo");
    infoDiv.innerHTML = infoHtml;
    infoDiv.style.display = "block"; // ✅ 표시

// 🔹 위치 재확인 (강제 적용)
    setTimeout(() => {
        infoDiv.style.top = "50%";
        infoDiv.style.left = "50%";
        infoDiv.style.transform = "translate(-50%, -50%)";
    }, 10);




     event.stopPropagation();

}


// ✅ 네이버 부동산 링크 열기 함수 추가
	function openNaverRealEstate(apartmentId) {
		let url = `https://new.land.naver.com/complexes/${apartmentId}`;
		window.open(url, "_blank");
	}

document.addEventListener("click", (event) => {
    const apartmentInfo = document.getElementById("apartmentInfo");

    // ✅ 클릭한 요소가 apartmentInfo 내부일 경우 유지
    if (apartmentInfo.contains(event.target)) {
        return;
    }

    // ✅ 클릭 순간 표시되었는지 확인 후 100ms 지연 후 닫기 (버블링 방지)
    setTimeout(() => {
        if (apartmentInfo.style.display === "block") {
            apartmentInfo.style.display = "none";
        }
    }, 0);
});

document.getElementById("apartmentInfo").addEventListener("touchstart", function(event) {
    const infoDiv = event.currentTarget;
    infoDiv.dataset.startY = event.touches[0].clientY;
    infoDiv.dataset.startScrollTop = infoDiv.scrollTop;
}, { passive: false });

document.getElementById("apartmentInfo").addEventListener("touchmove", function(event) {
    const infoDiv = event.currentTarget;
    
    // 내부 스크롤이 가능한 경우
    if (infoDiv.scrollHeight > infoDiv.clientHeight) {
        let startY = parseFloat(infoDiv.dataset.startY);
        let startScrollTop = parseFloat(infoDiv.dataset.startScrollTop);
        let currentY = event.touches[0].clientY;
        let scrollDiff = startScrollTop + (startY - currentY);

        // ✅ 최상단에서 아래로 당기려고 할 때
        if (infoDiv.scrollTop <= 0 && scrollDiff < 0) {
            event.preventDefault();
        }
        
         // ✅ 최하단에서 위로 스크롤할 때 제한을 해제
		if (infoDiv.dataset.atBottom === "true" && scrollDiff > 0) {
			event.preventDefault();
			infoDiv.scrollTop = infoDiv.scrollHeight - infoDiv.clientHeight - 1; // ✅ 스크롤을 조정하여 정상 작동
		}

    } else {
        // ✅ 내부 스크롤이 없는 경우 바디 스크롤 차단
        event.preventDefault();
    }
}, { passive: false });

document.addEventListener("touchmove", function(event) {
    const infoDiv = document.getElementById("apartmentInfo");

    if (infoDiv.style.display === "block") {
        if (infoDiv.scrollHeight <= infoDiv.clientHeight) {
            event.preventDefault(); // 내부 스크롤이 없으면 바디 스크롤 막기
        }
    }
}, { passive: false });

let middleSchoolMarkers = []; // ✅ 지도에 표시된 중학교 마커 저장

async function loadMiddleSchools() {
    try {
        const response = await fetch("middleSchools.json");
        let middleSchools = await response.json();

        // ✅ 중복 제거: 학교 ID를 기준으로 첫 번째 값만 유지
        const uniqueSchools = [];
        const seenIds = new Set();

        middleSchools.forEach(school => {
            if (!seenIds.has(school["학교 ID"])) {
                seenIds.add(school["학교 ID"]);
                uniqueSchools.push(school);
            }
        });

        //console.log("✅ 중복 제거 완료: 총", uniqueSchools.length, "개 학교 로드됨");

        window.middleSchoolData = uniqueSchools; // ✅ 중복 제거된 데이터 저장

        // ✅ 마커 업데이트
        updateMiddleSchoolMarkers();

        // ✅ 지도 이동 시 현재 범위 내 중학교 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            updateMiddleSchoolMarkers();
        });

    } catch (error) {
        console.error("❌ 중학교 데이터 로드 실패:", error);
    }
}



function updateMiddleSchoolMarkers() {
    const showMiddleSchools = document.getElementById("toggleMiddleSchools").checked;
	
    // ✅ 기존 중학교 마커 제거
    middleSchoolMarkers.forEach(marker => marker.setMap(null));
    middleSchoolMarkers = [];

    if (!showMiddleSchools) return; // 중학교 표시 체크 해제 시 종료
	
	if (window.map.getZoom() < 14) { 
        return; // ✅ 줌 레벨이 14보다 작으면 실행 중단
    }

    let bounds = window.map.getBounds();
    let filteredSchools = window.middleSchoolData.filter(school =>
        bounds.hasLatLng(new naver.maps.LatLng(school["위도"], school["경도"]))
    );

    filteredSchools.forEach(school => {
    // ✅ 마커 컨테이너를 markerElement로 활용
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = "midSchool.png";
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;
    infoBox.textContent = `${school["학교명"]} (${school["학업성취도"]})`;

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(school["위도"], school["경도"]),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // ✅ 우클릭 이벤트에 markerElement 전달 (테두리 활성화 가능)
    addMarkerRightClickEvent(marker, markerElement);

    middleSchoolMarkers.push(marker);
});

}


// ✅ 중학교 체크박스 변경 시 마커 업데이트
document.getElementById("toggleMiddleSchools").addEventListener("change", () => {
    updateMiddleSchoolMarkers(); // ✅ 즉시 업데이트
});

let facilityMarkers = []; // ✅ 지도에 표시된 시설 마커 저장

async function loadFacilities() {
    try {
        const response = await fetch("facility.json");
        const facilities = await response.json();

        //console.log("✅ 시설 데이터 로드 완료", facilities);
        window.facilityData = facilities; // ✅ 전체 시설 데이터 저장

        // ✅ 초기 마커 업데이트
        updateFacilityMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 시설 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateFacilityMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 시설 데이터 로드 실패:", error);
    }
}

function updateFacilityMarkers() {
    const showFacilities = document.getElementById("toggleFacilities").checked;

    // ✅ 기존 시설 마커 제거
    facilityMarkers.forEach(marker => marker.setMap(null));
    facilityMarkers = [];

    if (!showFacilities) return; // 체크 해제 시 종료
    if (window.map.getZoom() < 14) return; // ✅ 줌 레벨이 14보다 작으면 실행 중단

    let bounds = window.map.getBounds();
    let filteredFacilities = window.facilityData.filter(facility =>
        bounds.hasLatLng(new naver.maps.LatLng(facility.lat, facility.lng))
    );

    filteredFacilities.forEach(facility => {
    let iconSrc = "default.png"; // 기본 아이콘 (예외처리)
    if (facility.category === 10) {
        iconSrc = facility.description.includes("백화점") ? "depart.png" : "mart.png";
    } else if (facility.category === 9) {
        iconSrc = "hospital.png";
    }

    // ✅ 마커 컨테이너를 markerElement로 활용
    const markerElement = document.createElement("div");
    markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

    const markerIcon = document.createElement("img");
    markerIcon.src = iconSrc;
    markerIcon.style = "width: 32px; height: 32px;";

    const infoBox = document.createElement("div");
    infoBox.style = `
        background: white;
        border: 1px solid gray;
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        display: inline-block;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
    `;

    if (facility.category === 10) {
        infoBox.textContent = `${facility.description} (${facility.name})`;
    } else if (facility.category === 9) {
        infoBox.textContent = `${facility.name}`;
    }

    markerElement.appendChild(markerIcon);
    markerElement.appendChild(infoBox);

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(facility.lat, facility.lng),
        map: window.map,
        icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
    });

    // ✅ 우클릭 이벤트에 markerElement 전달 (테두리 활성화 가능)
    addMarkerRightClickEvent(marker, markerElement);

    facilityMarkers.push(marker);
});

}

// ✅ 시설 체크박스 변경 시 마커 업데이트
document.getElementById("toggleFacilities").addEventListener("change", () => {
    updateFacilityMarkers(); // ✅ 즉시 업데이트
});

let starbucksMarkers = []; // ✅ 지도에 표시된 스타벅스 마커 저장

async function loadStarbucks() {
    try {
        const response = await fetch("starbucks.json");
        const starbucks = await response.json();

        //console.log("✅ 스타벅스 데이터 로드 완료", starbucks);
        window.starbucksData = starbucks; // ✅ 전체 스타벅스 데이터 저장

        // ✅ 초기 마커 업데이트
        updateStarbucksMarkers(window.map.getBounds());

        // ✅ 지도 이동 시 현재 범위 내 스타벅스 마커 업데이트
        naver.maps.Event.addListener(window.map, "idle", function () {
            const bounds = window.map.getBounds();
            updateStarbucksMarkers(bounds);
        });

    } catch (error) {
        console.error("❌ 스타벅스 데이터 로드 실패:", error);
    }
}

function updateStarbucksMarkers() {
    const showStarbucks = document.getElementById("toggleStarbucks").checked;

    // ✅ 기존 스타벅스 마커 제거
    starbucksMarkers.forEach(marker => marker.setMap(null));
    starbucksMarkers = [];

    if (!showStarbucks) return; // 체크 해제 시 종료
    if (window.map.getZoom() < 14) return; // ✅ 줌 레벨이 14보다 작으면 실행 중단

    let bounds = window.map.getBounds();
    let filteredStarbucks = window.starbucksData.filter(store =>
        bounds.hasLatLng(new naver.maps.LatLng(store.lat, store.lot))
    );

     filteredStarbucks.forEach(store => {
        let iconSrc = store.s_name.includes("R") ? "starbucksReserve.png" : "starbucks.png";

        // ✅ 마커 컨테이너를 markerElement로 활용
        const markerElement = document.createElement("div");
        markerElement.style = "text-align: center; display: flex; flex-direction: column; align-items: center;";

        const markerIcon = document.createElement("img");
        markerIcon.src = iconSrc;
        markerIcon.style = "width: 32px; height: 32px;";

        markerElement.appendChild(markerIcon);

        const marker = new naver.maps.Marker({
            position: new naver.maps.LatLng(store.lat, store.lot),
            map: window.map,
            icon: { content: markerElement, anchor: new naver.maps.Point(16, 32) }
        });

        // ✅ 우클릭 이벤트에 markerElement 전달
        addMarkerRightClickEvent(marker, markerElement);

        starbucksMarkers.push(marker);
    });
}

// ✅ 스타벅스 체크박스 변경 시 마커 업데이트
document.getElementById("toggleStarbucks").addEventListener("change", () => {
    updateStarbucksMarkers(); // ✅ 즉시 업데이트
});


////////////////////////// 이동 이벤트 //////////////////////////
var activeMarker = null; // ✅ 현재 선택된 마커
var activeMarkerElement = null; // ✅ 현재 선택된 마커의 요소 (테두리 변경용)

// ✅ 🔥 마커 스타일 업데이트 함수 (선택된 경우 강조)
function updateMarkerSelection(markerElement, isSelected) {
    if (markerElement) {
        setTimeout(() => {
            markerElement.style.outline = isSelected ? "3px solid red" : "";
        }, 50); // ✅ DOM 업데이트 대기 후 스타일 적용
    }
}


function addMarkerRightClickEvent(marker, markerElement) {
    naver.maps.Event.addListener(marker, "rightclick", (e) => {
        e.domEvent.preventDefault();
        e.domEvent.stopPropagation();

        const isSiseMapActive = document.getElementById("toggleSiseMap").checked;

        console.log("🚀 마커 우클릭 감지 (ID: " + marker.apartmentId + ")");

        // ✅ 기존 선택된 마커 테두리 제거
        if (activeMarkerElement) {
            updateMarkerSelection(activeMarkerElement, false);
        }

        // ✅ 현재 선택된 마커 업데이트
        activeMarker = marker;
        activeMarkerElement = markerElement; // ✅ 기존 방식
        updateMarkerSelection(activeMarkerElement, true);

        // ✅ 만약 마커가 시세지도 마커이면 `.siseMapMarker`를 다시 찾고 스타일 적용
        if (isSiseMapActive) {
            setTimeout(() => {
                const updatedMarkerElement = markerElement.querySelector(".siseMapMarker");
                if (updatedMarkerElement) {
                    activeMarkerElement = updatedMarkerElement;
                    updateMarkerSelection(updatedMarkerElement, true);
                }
            }, 100); // ✅ DOM 업데이트 대기 후 스타일 적용
        }
    });
}





// ✅ 키보드 이벤트 등록
document.removeEventListener("keydown", handleKeyDown);
document.addEventListener("keydown", handleKeyDown);



function setupRightClickEvent() {
    let radiusCircle = null; // ✅ 반경 원 객체
    let centerMarker = null; // ✅ 반경 중심 마커

    // ✅ 지도에서 우클릭 시 (반경 1km 원 + 중심 빨간 점 추가)
    naver.maps.Event.addListener(window.map, "mousedown", function (e) {
        if (e.domEvent.button !== 2) return; // ✅ 우클릭이 아닐 경우 무시

        let clickedPosition = e.coord; // ✅ 우클릭한 위치의 좌표
        //console.log("📍 우클릭 위치:", clickedPosition);

        // ✅ 이미 반경 원이 있는 경우, 제거 후 종료 (토글 방식)
        if (radiusCircle) {
            radiusCircle.setMap(null);
            radiusCircle = null;
        }
        if (centerMarker) {
            centerMarker.setMap(null);
            centerMarker = null;
            return; // ✅ 삭제 후 새로 생성하지 않음
        }

        // ✅ 반경 1km 원 추가
        radiusCircle = new naver.maps.Circle({
            map: window.map,
            center: clickedPosition,
            radius: 1000, // ✅ 반경 1km
            strokeColor: "#FF0000",
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: "#FF0000",
            fillOpacity: 0.08
        });

        // ✅ 반경 중심에 빨간색 작은 점 추가
        centerMarker = new naver.maps.Marker({
            position: clickedPosition,
            map: window.map,
            icon: {
                content: `<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%; border: 1px solid white;"></div>`,
                anchor: new naver.maps.Point(4, 4) // ✅ 중심 정렬
            }
        });

        // ✅ 지도 중심을 클릭한 위치로 이동
        window.map.panTo(clickedPosition);
    });

    // ✅ 기본적인 우클릭 메뉴 방지
    document.addEventListener("contextmenu", function (e) {
        e.preventDefault();
    });

    //console.log("✅ 지도 로드 완료 후 우클릭 이벤트 등록됨");
}

//////////////////////////////////시세 지도 ////////////////////////////




var activeMarkerSet = null;

// ✅ IndexedDB 초기화
function initIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('hongSise', 1);

        request.onupgradeneeded = function(event) {
            const db = event.target.result;

            if (!db.objectStoreNames.contains('apartments')) {
                const store = db.createObjectStore('apartments', { keyPath: 'idType' });
                store.createIndex('id', 'id', { unique: false });
                console.log('✅ IndexedDB 업그레이드 완료: apartments store 생성됨');
            }
        };

        request.onsuccess = function(event) {
            console.log('📌 IndexedDB 연결 성공 (DB: hongSise)');
            resolve(event.target.result);
        };

        request.onerror = function(event) {
            console.error('❌ IndexedDB 연결 실패:', event.target.error);
            reject(event.target.error);
        };
    });
}

// ✅ IndexedDB 저장 함수
function saveToIndexedDB(id, type, text, color, textColor, fontSize) {
    const request = indexedDB.open("hongSise", 1);
    request.onsuccess = function(event) {
        const db = event.target.result;
        const transaction = db.transaction(["apartments"], "readwrite");
        const store = transaction.objectStore("apartments");

        store.put({ idType: `${id}-${type}`, text, color, textColor, fontSize });

        transaction.oncomplete = () => console.log(`✅ IndexedDB 저장 완료: ${id}`);
        transaction.onerror = (e) => console.error(`❌ IndexedDB 저장 오류: ${e.target.error}`);

    };
	markerElement = document.querySelector(`[data-apartment-id='${id}']`);
	markerElement.style.maxWidth = '160px';


}

// ✅ IndexedDB에서 데이터 가져오기
function getFromIndexedDB(id, type) {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("hongSise", 1);

        request.onerror = (event) => {
            reject("❌ IndexedDB 열기 오류: " + event.target.errorCode);
        };

        request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(["apartments"], "readonly");
            const store = transaction.objectStore("apartments");

            const idType = `${id}-${type}`;
            const getRequest = store.get(idType);

            getRequest.onsuccess = () => {
                if (getRequest.result) {
                    resolve(getRequest.result);
                } else {
                    resolve({ text: "", color: "#9F9F9F", textColor: "#ffffff", fontSize: "12px" });
                }
            };

            getRequest.onerror = () => {
                reject("❌ IndexedDB 데이터 가져오기 실패");
            };
        };
    });
}
/*
document.getElementById("toggleSiseMap").addEventListener("change", function() {
    const isChecked = this.checked;

	document.getElementById("siseExportBtn").style.display = isChecked ? "inline-block" : "none";
    document.getElementById("siseImportBtn").style.display = isChecked ? "inline-block" : "none";
	document.getElementById("siseResetBtn").style.display = isChecked ? "inline-block" : "none";
	if(!isChecked){
		removeAllLines(window.map.getBounds());
	}
    updateMarkers(window.map.getBounds())
	
});
*/

// ✅ 기본 마커 생성 (시세지도 체크 해제 시)
function renderSiseMapMarker(apartment) {
    let yearValue = apartment.year.slice(0,4);
    let bgColor = "#f9daae"; // 기본 배경색
    let fontColor = "#000000"; // 기본 글자색

    if (Array.isArray(window.yearColorSettings) && window.yearColorSettings.length > 0) {
//console.log(yearValue  )
        const matched = window.yearColorSettings.find(setting => yearValue >= setting.from && yearValue <= setting.to);
//console.log(matched);
        if (matched) {
            bgColor = matched.color;
            fontColor = matched.fontColor;
        }
    } else {
        // 기존 하드코딩된 값 (fallback)
        if (yearValue > 50) bgColor = "#5C6267";
        else if (yearValue >= 20) bgColor = "#3E24D7";
        else if (yearValue >= 10) bgColor = "#EE1A24";

        if (yearValue >= 0 && yearValue < 10) fontColor = "#000000"; 
    }

//console.log(`${bgColor} + "|" + ${fontColor}`);
    const markerElement = document.createElement("div");
	markerElement.style = `
		background-color: ${bgColor};
		color: ${fontColor};
		border-radius: 6px;
		padding: 0px;
		border: 3px  black;  /* ✅ 테두리 두께 2px, 검정색 */
		text-align: center;
		font-size: 12px;
		font-weight: bold;
		box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
		white-space: nowrap;
		display: inline-block;
max-height : 40px;
	`;

	const nameElement = document.createElement("div");
	nameElement.style = `
		background: white;
		color: black;
		font-size: 12px;
		font-weight: bold;
		display: flex; /* ✅ Flexbox 사용 */
		align-items: center;
		justify-content: center;
		padding: 2px 5px; /* ✅ 최소 패딩 유지 */
		border-radius: 3px;
		min-width: 85px; /* ✅ 최소 너비 고정 */
		max-width: 85px; /* ✅ 최대 너비 고정 */
		overflow: hidden;
		text-overflow: ellipsis;
	`;

	const detailsElement = document.createElement("div");
	detailsElement.style = `
		font-size: 12px;
		padding: 2px 5px;
		min-width: 85px; /* ✅ 세부 정보도 최소 크기 동일 */
		max-width: 85px;
		display: flex;
		justify-content: center;
height: 20px
	`;
// 기존



    nameElement.textContent = apartment.name.length > 7 ? apartment.name.slice(0, 6) + "..." : apartment.name;
    detailsElement.textContent = `${apartment.year.slice(-5)} ${apartment.units}세대`;
	markerElement.setAttribute("data-apartment-id", apartment.id);
    markerElement.appendChild(nameElement);
    markerElement.appendChild(detailsElement);



const chartContainer = document.createElement("div");
chartContainer.className = "priceChartContainer";
chartContainer.style = `
    margin-top: 0px;
 align-items: flex-end;
`;

const outerWrapper  = document.createElement("div");
// ... 스타일 설정
outerWrapper.style = `
		
	
display: flex; flex-direction: row; align-items: flex-end;
		
	`;
outerWrapper.appendChild(markerElement);
outerWrapper.appendChild(chartContainer);



		// ✅ 마커 클릭 시 가로 길이 확장 → 3초 후 다시 축소
    

    const marker = new naver.maps.Marker({
        position: new naver.maps.LatLng(apartment.lat, apartment.lng),
        map: window.map,
        icon: {
            content: outerWrapper,
            anchor: new naver.maps.Point(10, 30)
        }
    });
	marker.apartmentId = apartment.id; // ✅ 마커 객체에 직접 ID 저장

	naver.maps.Event.addListener(marker, "click",  function(e) {
		showApartmentInfo(apartment.id, {
			x: e.offset.x,
			y: e.offset.y
		});
	});



// ✅ 중복 이벤트 방지 위해 기존 리스너 제거 후 다시 추가
    addSiseMapMarkerLeftClickEvent(marker, markerElement);
    addMarkerRightClickEvent(marker, markerElement);

    // ✅ IndexedDB에서 데이터 불러오기
    //updateT2FromIndexedDB(apartment.id, markerElement, tableContainer);

	getFromIndexedDB(apartment.id, "시세1").then(data => {
		const tableData = data?.text || generateDefaultTable();
		
		const dummyDiv = document.createElement("div");
		dummyDiv.innerHTML = createEditableTableHTML(apartment.id, tableData);
		
		const parsed = parsePriceDataFromTable(dummyDiv);

		if (parsed.length > 0) {
			renderPriceChart(chartContainer, parsed);
		}
	});


		
	// ✅ 기존 마커 제거 및 캐시 업데이트
	if (apartmentMarkers[apartment.id]) {
		apartmentMarkers[apartment.id].setMap(null);
		delete apartmentMarkers[apartment.id];
	}

	apartment.marker = marker;
	apartmentMarkers[apartment.id] = marker;
	return marker;
}





// ✅ 기본 3x4 테이블 생성
function generateDefaultTable() {
    let defaultTable = [];
    for (let i = 0; i < 3; i++) {
        let row = [];
        for (let j = 0; j < 4; j++) {
            row.push("");  // 기본값 설정
        }
        defaultTable.push(row.join('\t'));
    }
    return defaultTable.join('\n'); // 줄바꿈 포함하여 저장
}

// ✅ 수정 가능한 테이블을 생성하는 함수
function createEditableTableHTML(id, textData) {

   


    let rows = textData.split('\n').map(row => row.split('\t'));
    const table = document.createElement("table");
    table.style.borderCollapse = "collapse";
    table.style.width = "100%";             // ✅ 자동 너비
    table.style.tableLayout = "auto";       // ✅ 열마다 유동적 너비
    table.style.color = "black";

    rows.forEach((row, rowIndex) => {
        const tr = document.createElement("tr");
        row.forEach((cell, colIndex) => {
            const td = document.createElement("td");
            td.dataset.id = id;
            td.dataset.row = rowIndex;
            td.dataset.col = colIndex;
            td.textContent = cell.trim();

            td.style = `
				border: 1px solid black;
				padding: 2px 4px;
				text-align: center;
				height: 24px;

				vertical-align: middle;
				white-space: normal;  /* ✅ 줄바꿈 허용 */
				word-break: break-word; /* ✅ 텍스트 줄바꿈 */
			`;


            tr.appendChild(td);
        });
        table.appendChild(tr);
    });

    return table.outerHTML;
}



// ✅ IndexedDB에 테이블 데이터 저장 (tableContainer가 없을 경우 복구)
function saveTableToIndexedDB(id, tableContainer) {
    if (!tableContainer) {
        console.warn(`⚠️ [saveTableToIndexedDB] tableContainer가 없습니다. ID: ${id || "undefined"}`);
        return;
    }

    // ✅ 이미 저장 중인지 체크하여 중복 실행 방지
    if (window.isSaving) {
        console.warn("⚠️ IndexedDB 저장 중, 중복 호출 방지");
        return;
    }
    window.isSaving = true;  // ✅ 저장 중 상태 플래그 설정

    let tableData = [];
    tableContainer.querySelectorAll("tr").forEach(row => {
        let rowData = [];
        row.querySelectorAll("td").forEach(td => {
            rowData.push(td.textContent.trim());
        });
        tableData.push(rowData.join('\t'));
    });

    // ✅ IndexedDB에서 기존 색상 데이터를 불러와 유지
    getFromIndexedDB(id, "시세1").then(existingData => {
        let existingColor = existingData?.color || "#9F9F9F"; // ✅ 기존 배경색 유지
        let existingTextColor = existingData?.textColor || "#ffffff"; // ✅ 기존 글자색 유지
        let existingFontSize = existingData?.fontSize || "12px"; // ✅ 기존 폰트 크기 유지

        saveToIndexedDB(id, "시세1", tableData.join('\n'), existingColor, existingTextColor, existingFontSize);
    }).catch(error => {
        console.error("❌ IndexedDB 불러오기 실패:", error);
    }).finally(() => {
        setTimeout(() => {
            window.isSaving = false;  // ✅ 일정 시간 후 다시 저장 가능하게 설정
        }, 100);
    });
}




// ✅ 셀 삭제 함수 수정 (삭제 후 오류 방지)
function deleteSelectedCells() {
    if (!selectedCells || selectedCells.size === 0) {
        console.warn("⚠️ 선택된 셀이 없음");
        return;
    }

    selectedCells.forEach(td => {
        if (td && td instanceof HTMLElement) {
            td.textContent = ""; // ✅ 내용만 삭제
        }
    });

    // ❗ activeMarkerElement가 없을 경우 복구 시도
    if (!activeMarkerElement && selectedCells.size > 0) {
        let firstCell = Array.from(selectedCells)[0];
        activeMarkerElement = firstCell.closest(".siseMapMarker");
    }

    if (activeMarkerElement) {
        let tableContainer = activeMarkerElement.querySelector(".tableContainer");
        let id = activeMarkerElement.dataset.apartmentId;

        if (!id || id === "undefined") {
            console.warn("⚠️ 삭제 후 저장할 ID가 없음.");
            return;
        }

        if (tableContainer) {
            // ✅ 불필요한 setTimeout 제거 (즉시 저장)
            saveTableToIndexedDB(id, tableContainer);
        } else {
            console.warn("⚠️ tableContainer 찾을 수 없음");
        }
    } else {
        console.warn("⚠️ activeMarkerElement가 없음");
    }
}

// ✅ 셀을 수정 가능하도록 설정 + IME 한글 입력 처리 (중복 방지)
function makeTableEditable(tableContainer) {

    let isComposing = false; // ✅ 한글 입력 중인지 확인
    let lastFocusedTd = null; // ✅ 마지막으로 포커스된 셀 저장

    tableContainer.querySelectorAll("td").forEach(td => {
        // ✅ 기존 이벤트 제거 (중복 방지)
        td.removeEventListener("click", handleTdClick);
        td.removeEventListener("compositionstart", handleCompositionStart);
        td.removeEventListener("compositionend", handleCompositionEnd);
        //td.removeEventListener("keydown", handleKeyDown);
        td.removeEventListener("blur", handleTdBlur);
        td.removeEventListener("paste", handlePaste);

        // ✅ 새로운 이벤트 추가
        td.addEventListener("click", handleTdClick);
        td.addEventListener("compositionstart", handleCompositionStart);
        td.addEventListener("compositionend", handleCompositionEnd);
        //td.addEventListener("keydown", handleKeyDown);
        td.addEventListener("blur", handleTdBlur);
        td.addEventListener("paste", handlePaste);
    });

    // ✅ 클릭 이벤트 핸들러 (셀을 클릭하면 편집 가능)
    function handleTdClick(event) {
		const td = event.target;
		td.setAttribute("contenteditable", "true");
		td.focus();
		lastFocusedTd = td;

		// ✅ 커서를 제일 오른쪽으로 이동시키기
		const range = document.createRange();
		const selection = window.getSelection();

		range.selectNodeContents(td);
		range.collapse(false); // false → 커서를 끝으로 보냄
		selection.removeAllRanges();
		selection.addRange(range);
	}


    // ✅ 한글 입력 시작 (IME 입력 감지)
    function handleCompositionStart() {
        isComposing = true;
    }

    // ✅ 한글 입력 완료 (포커스 유지 중이면 저장 안 함)
    function handleCompositionEnd(event) {
    isComposing = false; // ✅ 조합 종료 플래그
    setTimeout(() => {
        saveTableToIndexedDB(event.target.dataset.id, event.target.closest(".tableContainer"));
    }, 50);
}


    

    // ✅ 포커스 아웃 시 저장 (IME 입력 중이면 저장 방지)
    function handleTdBlur(event) {
        setTimeout(() => {
            if (isComposing) return; // ✅ IME 입력 중이면 blur 저장 방지
            isComposing = false; // ✅ 포커스가 아웃되었을 때 입력 종료
            saveTableToIndexedDB(event.target.dataset.id, event.target.closest(".tableContainer"));
        }, 50);
    }

    // ✅ 붙여넣기 이벤트 (붙여넣기 후 즉시 저장)
     function handlePaste(event) {
        event.preventDefault();
        let clipboardData = event.clipboardData || window.clipboardData;
        let pastedText = clipboardData.getData("text");

        if (!pastedText.includes("\t") && !pastedText.includes("\n")) {
            // ✅ 일반 텍스트 붙여넣기
            document.execCommand("insertText", false, pastedText);
            return;
        }

        // ✅ 엑셀에서 복사한 데이터를 테이블에 맞춰 삽입
        let rows = pastedText.split("\n").map(row => row.split("\t"));
        let startRow = parseInt(lastFocusedTd.dataset.row, 10);
        let startCol = parseInt(lastFocusedTd.dataset.col, 10);
        let table = lastFocusedTd.closest("table");

        rows.forEach((row, rowIndex) => {
            row.forEach((cellText, colIndex) => {
                let targetRow = startRow + rowIndex;
                let targetCol = startCol + colIndex;
                let targetCell = table.querySelector(`td[data-row="${targetRow}"][data-col="${targetCol}"]`);
                
                if (targetCell) {
                    targetCell.textContent = cellText.trim();
                }
            });
        });

        // ✅ 저장
        saveTableToIndexedDB(lastFocusedTd.dataset.id, lastFocusedTd.closest(".tableContainer"));
    }

    enableMultiCellSelection(tableContainer);
}





// ✅ 텍스트의 실제 픽셀 너비를 계산하는 함수
function getTextWidth(text, font) {
    let canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    let context = canvas.getContext("2d");
    context.font = font || "12px Arial";
    return context.measureText(text).width;
}


// ✅ 현재 선택된 셀 목록
let selectedCells = new Set();
let lastSelectedCell = null;

// ✅ 셀 선택 기능 (Shift 키 지원)
function enableMultiCellSelection(tableContainer) {
    let isMouseDown = false;

    // ✅ 기존 이벤트 제거 (중복 방지)
    document.removeEventListener("mouseup", handleMouseUp);
    //document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("click", handleOutsideClick);

    // ✅ 이벤트 핸들러 재등록
    document.addEventListener("mouseup", handleMouseUp);
    //document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("click", handleOutsideClick);

    tableContainer.querySelectorAll("td").forEach(td => {
        td.addEventListener("mousedown", function(event) {
            event.preventDefault();
            isMouseDown = true;

            if (event.shiftKey && lastSelectedCell) {
                selectRangeCells(lastSelectedCell, td, tableContainer);
            } else {
                clearSelectedCells();
                toggleCellSelection(td);
                lastSelectedCell = td;
            }
        });

        td.addEventListener("mouseover", function(event) {
            if (isMouseDown) {
                if (event.shiftKey && lastSelectedCell) {
                    selectRangeCells(lastSelectedCell, td, tableContainer);
                } else {
                    clearSelectedCells();
                    toggleCellSelection(td);
                }
            }
        });

        td.addEventListener("mouseup", function() {
            isMouseDown = false;
        });

        td.addEventListener("click", function(event) {
            event.stopPropagation();
        });
    });
}

// ✅ 마우스 업 이벤트 핸들러 (중복 방지)
function handleMouseUp() {
    isMouseDown = false;
}
function handleKeyDown(event) {
    const activeElement = document.activeElement;

	// ✅ case 2: 지도 마커 이동용 WASD
console.log("2494")
//console.log(activeMarker)
    if (activeMarker) {
        let position = activeMarker.getPosition();
        let lat = position.lat();
        let lng = position.lng();
        let step = 0.0004;

        switch (event.key) {
            case "w": case "ㅈ": lat += step; break;
            case "s": case "ㄴ": lat -= step; break;
            case "a": case "ㅁ": lng -= step; break;
            case "d": case "ㅇ": lng += step; break;
            case "Escape":
                updateMarkerSelection(activeMarkerElement, false);
                activeMarker = null;
                activeMarkerElement = null;
                return;
            default:
                return;
        }

        let newPosition = new naver.maps.LatLng(lat, lng);
        activeMarker.setPosition(newPosition);
    }

    // ✅ case 1: 테이블 셀 안에서 키보드 이벤트
    if (activeElement && activeElement.tagName === "TD") {
        // IME 한글 입력 중이면 무시
        if (window.isComposing) return;

        const tableContainer = activeElement.closest(".tableContainer");
        const currentRow = parseInt(activeElement.dataset.row, 10);
        const currentCol = parseInt(activeElement.dataset.col, 10);
        const table = tableContainer.querySelector("table");

        switch (event.key) {
            case "ArrowUp":
                event.preventDefault();
                moveToCell(table, currentRow - 1, currentCol);
                return;
            case "ArrowDown":
                event.preventDefault();
                moveToCell(table, currentRow + 1, currentCol);
                return;
            case "ArrowLeft":
                event.preventDefault();
                moveToCell(table, currentRow, currentCol - 1);
                console.log("왼쪽");
                return;
            case "ArrowRight":
                event.preventDefault();
                moveToCell(table, currentRow, currentCol + 1);
                console.log("오른쪽");
                return;
            case "Delete":
            case "Backspace":
                if (selectedCells.size > 1) {
                    event.preventDefault();
                    deleteSelectedCells();
                }
                return;
        }

        // ✅ Ctrl+C 또는 Cmd+C 복사 처리
        if ((event.ctrlKey || event.metaKey) && event.key === "c") {
            if (selectedCells.size > 0) {
                event.preventDefault();

                const cellsArray = Array.from(selectedCells);
                cellsArray.sort((a, b) => {
                    const rowA = parseInt(a.dataset.row, 10);
                    const rowB = parseInt(b.dataset.row, 10);
                    if (rowA !== rowB) return rowA - rowB;
                    return parseInt(a.dataset.col, 10) - parseInt(b.dataset.col, 10);
                });

                const maxRow = Math.max(...cellsArray.map(td => parseInt(td.dataset.row)));
                const minRow = Math.min(...cellsArray.map(td => parseInt(td.dataset.row)));
                const maxCol = Math.max(...cellsArray.map(td => parseInt(td.dataset.col)));
                const minCol = Math.min(...cellsArray.map(td => parseInt(td.dataset.col)));

                const rowCount = maxRow - minRow + 1;
                const colCount = maxCol - minCol + 1;
                const grid = Array.from({ length: rowCount }, () => Array(colCount).fill(""));

                cellsArray.forEach(td => {
                    const r = parseInt(td.dataset.row) - minRow;
                    const c = parseInt(td.dataset.col) - minCol;
                    grid[r][c] = td.textContent.trim();
                });

                const tsv = grid.map(row => row.join("\t")).join("\n");

                navigator.clipboard.writeText(tsv).then(() => {
                    console.log("✅ 셀 복사 완료");
                }).catch(err => {
                    console.error("❌ 클립보드 복사 실패:", err);
                });
            }
        }
    }

    
}



// ✅ 마커 외부 클릭 시 블록 해제 (중복 방지)
function handleOutsideClick(event) {
    if (!event.target.closest(".siseMapMarker")) {
        clearSelectedCells();
    }
}

function clearSelectedCells() {
    if (!selectedCells) return;
    selectedCells.forEach(cell => {
        cell.style.backgroundColor = ""; // ✅ 기존 선택 해제
    });
    selectedCells.clear(); // ✅ Set 초기화
}


// ✅ 범위 선택 기능 (Shift 키 사용)
function selectRangeCells(startCell, endCell, tableContainer) {
    let table = tableContainer.querySelector("table");
    let startRow = parseInt(startCell.dataset.row);
    let startCol = parseInt(startCell.dataset.col);
    let endRow = parseInt(endCell.dataset.row);
    let endCol = parseInt(endCell.dataset.col);

    let minRow = Math.min(startRow, endRow);
    let maxRow = Math.max(startRow, endRow);
    let minCol = Math.min(startCol, endCol);
    let maxCol = Math.max(startCol, endCol);

    selectedCells.clear();

    for (let row = minRow; row <= maxRow; row++) {
        for (let col = minCol; col <= maxCol; col++) {
            let targetCell = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
            if (targetCell) {
                selectedCells.add(targetCell);
                targetCell.style.backgroundColor = "#FFD700"; // ✅ 노란색 블록 표시
            }
        }
    }
}

// ✅ 셀 선택/해제 기능 (Shift 미사용 시 단일 선택)
function toggleCellSelection(td) {
    if (selectedCells.has(td)) {
        selectedCells.delete(td);
        td.style.backgroundColor = ""; // ✅ 선택 해제
    } else {
        selectedCells.add(td);
        td.style.backgroundColor = "#FFD700"; // ✅ 노란색 블록 지정
    }
}


function enableArrowKeyNavigation(tableContainer) {
    const table = tableContainer.querySelector("table");
    if (!table) return;

    // ✅ 기존 td 이벤트 제거
    table.querySelectorAll("td").forEach(td => {
        td.removeEventListener("keydown", handleArrowKey); // 중복 제거
        td.addEventListener("keydown", handleArrowKey);     // 새로 등록
    });
}

function handleArrowKey(event) {
    const td = event.currentTarget;
    const currentRow = parseInt(td.dataset.row, 10);
    const currentCol = parseInt(td.dataset.col, 10);
    const table = td.closest("table");

    switch (event.key) {
        case "ArrowUp":
            event.preventDefault();
            moveToCell(table, currentRow - 1, currentCol);
            break;
        case "ArrowDown":
            event.preventDefault();
            moveToCell(table, currentRow + 1, currentCol);
            break;
        case "ArrowLeft":
            event.preventDefault();
            moveToCell(table, currentRow, currentCol - 1);

            break;
        case "ArrowRight":
            event.preventDefault();
            moveToCell(table, currentRow, currentCol + 1);

            break;
        case "Delete":
        case "Backspace":
            if (selectedCells && selectedCells.size > 1) {
                event.preventDefault();
                deleteSelectedCells();
            }
            break;
    }
}
function moveToCell(table, row, col) {
    console.log("➡ moveToCell 호출:", row, col);

    let maxRows = table.rows.length;
    let maxCols = table.rows[0].cells.length;

    if (row < 0 || row >= maxRows || col < 0 || col >= maxCols) {
        console.warn(`⚠️ 유효하지 않은 이동 위치: row=${row}, col=${col}`);
        return;
    }

    let targetCell = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
    //console.log("🎯 targetCell:", targetCell);

    if (targetCell) {
        targetCell.setAttribute("contenteditable", "true");
        setTimeout(() => {
            targetCell.focus();

            // ✅ 커서를 텍스트 끝으로 이동
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(targetCell);
            range.collapse(false); // 끝으로 이동
            selection.removeAllRanges();
            selection.addRange(range);
        }, 10);
    }
}






function rgbToHex(rgb) {
    let rgbArray = rgb.match(/\d+/g);
    if (!rgbArray || rgbArray.length < 3) return "#000000"; // 기본값

    return `#${rgbArray
        .slice(0, 3)
        .map(x => parseInt(x).toString(16).padStart(2, "0"))
        .join("")}`.toUpperCase();
}


async function showColorPickerModal(apartmentId, defaultColor, defaultTextColor, defaultFontSize, callback) {

    // ✅ 기존 모달 제거 (중복 방지)
    const existingModal = document.querySelector('.custom-modal-siseMap');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    // ✅ RGB 색상이 들어오면 HEX로 변환
    if (defaultColor.startsWith("rgb")) defaultColor = rgbToHex(defaultColor);
    if (defaultTextColor.startsWith("rgb")) defaultTextColor = rgbToHex(defaultTextColor);

    // ✅ 모달 생성
    const modal = document.createElement('div');
    modal.className = 'custom-modal-siseMap';
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = 'white';
    modal.style.border = '1px solid #ccc';
    modal.style.padding = '20px';
    modal.style.zIndex = '10000';
    modal.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
    modal.style.width = '300px';

    makeModalDraggable(modal);

	const tableContainer = document.createElement("div");
    tableContainer.className = "tableContainer";



    await getFromIndexedDB(apartmentId, "시세1").then(data => {
        let tableData = data?.text || generateDefaultTable();
/*
console.log("2851");
console.log(tableData);
console.log(createEditableTableHTML(apartmentId, tableData));
*/
        tableContainer.innerHTML = createEditableTableHTML(apartmentId, tableData);
	});




    modal.appendChild(tableContainer);

	makeTableEditable(tableContainer);
    //document.body.appendChild(modal);






    // ✅ 색상 선택 블록 추가 (14개)
    const colorDiv = document.createElement('div');
    colorDiv.className = 'color-div';
    colorDiv.style.display = 'flex';
    colorDiv.style.flexWrap = 'wrap';
    colorDiv.style.marginTop = '10px';

    const colors = ['#000000', '#454648', '#474C4F', '#FF0000', '#FF6600', '#FFFF00', 
                    '#92D050', '#00B050', '#00B0F0', '#0070C0', '#000099', '#7030A0', 
                    '#CC3399', '#FF66CC'];

    colors.forEach(color => {
        const smallSquare = document.createElement('div');
        smallSquare.className = 'small-square';
        smallSquare.style.backgroundColor = color;
        smallSquare.style.width = '24px';
        smallSquare.style.height = '24px';
        smallSquare.style.margin = '2px';
        smallSquare.style.cursor = 'pointer';
        smallSquare.style.border = '1px solid #000';

        // ✅ 블록 클릭 시 배경색 변경
        smallSquare.onclick = () => {
            colorInput.value = color;
            colorPicker.value = color;
        };

        colorDiv.appendChild(smallSquare);
    });

    //modal.appendChild(colorDiv);

    // ✅ 배경색 선택 (컬러 선택기 + 직접 입력)
    const colorPickerWrapper = document.createElement('div');
    colorPickerWrapper.className = 'color-picker-wrapper';

    const colorPickerLabel = document.createElement('label');
    colorPickerLabel.textContent = '배경색 : ';
    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = defaultColor || '#1C32F7';

    const colorInput = document.createElement('input');
    colorInput.type = 'text';
    colorInput.className = 'color-input';
    colorInput.placeholder = '색상값 입력 #000000';
    colorInput.value = defaultColor || '#1C32F7';
    colorInput.style.width = '80px';
    colorInput.style.marginTop = '0px';

    colorPicker.oninput = () => {
        colorInput.value = colorPicker.value.toUpperCase();
    };

    colorPickerWrapper.appendChild(colorPickerLabel);
    colorPickerWrapper.appendChild(colorPicker);
    colorPickerWrapper.appendChild(colorInput);

    //modal.appendChild(colorPickerWrapper);

    colorInput.addEventListener('input', () => {
        if (/^#[0-9A-F]{6}$/i.test(colorInput.value)) {
            colorPicker.value = colorInput.value.toUpperCase();
        }
    });

    // ✅ 글자색 선택 (컬러 선택기 + 직접 입력)
    const textColorPickerWrapper = document.createElement('div');
    textColorPickerWrapper.className = 'color-picker-wrapper';

    const textColorPickerLabel = document.createElement('label');
    textColorPickerLabel.textContent = '글자색 : ';
    const textColorPicker = document.createElement('input');
	textColorPicker.type = 'color';
	defaultTextColor = defaultTextColor?.trim() || '#FFFFFF'; // ✅ 기본값 강제 적용
	textColorPicker.value = defaultTextColor;


	const textColorInput = document.createElement('input');
	textColorInput.type = 'text';
	textColorInput.className = 'color-input';
	textColorInput.placeholder = '색상값 입력 #FFFFFF';
	textColorInput.value = defaultTextColor;

    textColorInput.style.width = '80px';
    textColorInput.style.marginTop = '0px';

    textColorPicker.oninput = () => {
        textColorInput.value = textColorPicker.value.toUpperCase();
    };

    textColorInput.addEventListener('input', () => {
        if (/^#[0-9A-F]{6}$/i.test(textColorInput.value)) {
            textColorPicker.value = textColorInput.value.toUpperCase();
        }
    });

    textColorPickerWrapper.appendChild(textColorPickerLabel);
    textColorPickerWrapper.appendChild(textColorPicker);
    textColorPickerWrapper.appendChild(textColorInput);

    //modal.appendChild(textColorPickerWrapper);

    // ✅ 글자 크기 조절
    const fontSizeWrapper = document.createElement('div');
    fontSizeWrapper.className = 'font-size-wrapper';

    const fontSizeLabel = document.createElement('label');
    fontSizeLabel.textContent = '글자 크기 : ';
    const fontSizeInput = document.createElement('input');
    fontSizeInput.type = 'number';
    fontSizeInput.className = 'font-size-input';
    fontSizeInput.value = parseInt(defaultFontSize) || '13';
    fontSizeInput.style.width = '80px';

    fontSizeWrapper.appendChild(fontSizeLabel);
    fontSizeWrapper.appendChild(fontSizeInput);

    //modal.appendChild(fontSizeWrapper);



	const rowButtonContainer = document.createElement('div');
    rowButtonContainer.style.marginTop = '10px';


    // ✅ 버튼 컨테이너
    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '10px';
    buttonContainer.style.textAlign = 'right';

    const saveButton = document.createElement('button');
    saveButton.textContent = ' 확인 ';
    saveButton.style.marginRight = '10px';
	saveButton.onclick = () => {
		updateMarkerStyleAndSave(apartmentId, colorInput.value, textColorInput.value, fontSizeInput.value + 'px');

		const apartment = apartmentData.find(a => a.id === apartmentId);
		if (apartment) {
			// ✅ 혹시 렌더 전에 마커가 지도에 있으면 먼저 제거
			if (apartment.marker && typeof apartment.marker.setMap === "function") {
				apartment.marker.setMap(null);
				
			}
			delete apartmentMarkers[apartmentId]; // 👈 마커 관리 객체에서도 제거해야 함
			// ✅ 새로 렌더링 → 내부에서 apartment.marker에 새 마커 저장되도록
			renderSiseMapMarker(apartment);
		}

		closePopup();
		document.body.removeChild(modal);
	};


	const addRowButton = document.createElement('button');
    addRowButton.textContent = '행 추가';
    //addRowButton.onclick = () => addRowToTable(apartmentId);
    rowButtonContainer.appendChild(addRowButton);

    const removeRowButton = document.createElement('button');
    removeRowButton.textContent = '행 제거';
    //removeRowButton.onclick = () => removeRowFromTable(apartmentId);
    rowButtonContainer.appendChild(removeRowButton);

	addRowButton.onclick = () => addRowToTable(apartmentId, tableContainer);
	removeRowButton.onclick = () => removeRowFromTable(apartmentId, tableContainer);

    modal.appendChild(rowButtonContainer);



	const resetButton = document.createElement('button');
	resetButton.textContent = ' 초기화 ';
	resetButton.style.marginRight = '10px';
	resetButton.onclick = () => {
		const request = indexedDB.open("hongSise", 1);
		request.onsuccess = function(event) {
			const db = event.target.result;
			const transaction = db.transaction(["apartments"], "readwrite");
			const store = transaction.objectStore("apartments");
			store.delete(`${apartmentId}-시세1`);

			transaction.oncomplete = () => {
				console.log("✅ 초기화 완료 (IndexedDB 삭제됨)");

				const apartment = apartmentData.find(a => a.id === apartmentId);
				if (apartment) {
					// ✅ 마커가 지도에 있으면 제거
					if (apartment.marker && typeof apartment.marker.setMap === "function") {
						apartment.marker.setMap(null);
					
					}
					//delete apartmentMarkers[apartmentId]; // 👈 마커 관리 객체
					// ✅ 기존 차트도 제거
					const existing = document.querySelector(`[data-apartment-id='${apartmentId}']`);
					if (existing) {
						const chart = existing.closest('div[style*="position: absolute"]');
						if (chart && chart.parentNode) {
							chart.parentNode.removeChild(chart);
						}
					}

					// ✅ 새로 마커 렌더링
					renderSiseMapMarker(apartment);
				}

				// ✅ 모달 닫기
				closePopup();
				document.body.removeChild(modal);
			};
		};
	};


	buttonContainer.appendChild(resetButton);  // ⬅ 초기화 버튼 먼저
    buttonContainer.appendChild(saveButton);

    const cancelButton = document.createElement('button');
    cancelButton.textContent = ' 닫기 ';
    cancelButton.onclick = () => {
        document.body.removeChild(modal);
        closePopup();
    };
    buttonContainer.appendChild(cancelButton);

    modal.appendChild(buttonContainer);

    // ✅ 모달을 body에 추가
    document.body.appendChild(modal);



}

function addRowToTable(apartmentId, tableContainer) {
    const table = tableContainer.querySelector("table");
    if (table) {
        const newRow = table.insertRow();
        const rowIndex = table.rows.length - 1; // 새로 추가된 행의 인덱스

        for (let colIndex = 0; colIndex < table.rows[0].cells.length; colIndex++) {
            const newCell = newRow.insertCell();
            newCell.textContent = "";
            newCell.style.border = "1px solid black";
            newCell.style.padding = "0px";
            newCell.style.textAlign = "center";
            newCell.style.height = "24px";

            // ✅ 편집을 위해 필요한 dataset 추가
            newCell.dataset.id = apartmentId;
            newCell.dataset.row = rowIndex;
            newCell.dataset.col = colIndex;
        }

        // ✅ 새로 추가된 셀에도 편집 이벤트 적용
        makeTableEditable(tableContainer);

        // ✅ 저장
        saveTableToIndexedDB(apartmentId, tableContainer);
    }
}

function removeRowFromTable(apartmentId, tableContainer) {
    const table = tableContainer.querySelector("table");
    if (table && table.rows.length > 1) {
        table.deleteRow(table.rows.length - 1);
        saveTableToIndexedDB(apartmentId, tableContainer);
    }
}


function parsePriceDataFromTable(tableContainer) {
    const rows = tableContainer.querySelectorAll("tr");
    const parsed = [];

    rows.forEach(row => {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 3) {
            const 평형 = cells[0].textContent.trim();
            const 매매 = parseFloat(cells[1].textContent.trim());
            const 전세 = parseFloat(cells[2].textContent.trim());

            if (!isNaN(매매) && !isNaN(전세)) {
                parsed.push({ 평형, 매매, 전세 });
            }
        }
    });

    return parsed;
}


async function exportHongSiseToJSON() {
    try {
        const request = indexedDB.open("hongSise");

        request.onerror = function(event) {
            console.error("❌ hongSise DB 연결 실패:", event.target.error);
        };

        request.onsuccess = async function(event) {
            const db = event.target.result;
            const objectStoreNames = db.objectStoreNames;
            const exportData = {};

            const tx = db.transaction(objectStoreNames, "readonly");

            await Promise.all([...objectStoreNames].map(storeName => {
                return new Promise((resolve, reject) => {
                    const store = tx.objectStore(storeName);
                    const getAllRequest = store.getAll();

                    getAllRequest.onsuccess = () => {
                        exportData[storeName] = getAllRequest.result;
                        resolve();
                    };

                    getAllRequest.onerror = (e) => {
                        console.error(`❌ ${storeName} 가져오기 실패`, e);
                        reject(e);
                    };
                });
            }));

            // 저장할 파일 이름 생성
            const now = new Date();
            const formattedDate = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
            const formattedTime = `${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
            const defaultFilename = `시세지도Ver2_가격_백업_${formattedDate}_${formattedTime}.json`;

            // showSaveFilePicker를 이용해 사용자에게 저장 위치 선택 받기
            const handle = await window.showSaveFilePicker({
                suggestedName: defaultFilename,
                types: [
                    {
                        description: "JSON 파일",
                        accept: { "application/json": [".json"] }
                    }
                ]
            });

            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(exportData, null, 2));
            await writable.close();

            console.log("✅ hongSise DB 백업 완료:", defaultFilename);
        };
    } catch (error) {
        console.error("❌ hongSise 백업 중 오류 발생:", error);
    }
}



function importFromJSON(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        const data = JSON.parse(event.target.result);

        initIndexedDB().then(db => {
            const transaction = db.transaction(['apartments'], 'readwrite');
            const store = transaction.objectStore('apartments');

            data.forEach(item => {
                // ✅ 누락된 필드 보완
                if (!item.type) item.type = '시세1';
                if (!item.idType) item.idType = `${item.id}-${item.type}`;
                store.put(item);
            });

            transaction.oncomplete = function() {
				alert('✅ 시세 데이터를 성공적으로 가져왔습니다.');

				// ❗ 시세지도 활성화 상태일 경우, 마커 다시 그리기
				if (document.getElementById("toggleSiseMap").checked && window.map) {
					prevSiseMapState = "초기화";
					updateMarkers(window.map.getBounds());
				}
			};


            transaction.onerror = function(event) {
                console.error('❌ Import transaction error:', event.target.errorCode);
            };
        }).catch(error => {
            console.error('❌ Failed to initialize hongbu DB:', error);
        });
    };

    reader.readAsText(file);
}

function importFromJSONToHongSise(file) {
	const reader = new FileReader();

	reader.onload = function (event) {
		const data = JSON.parse(event.target.result);

		const request = indexedDB.open("hongSise");

		request.onerror = function (e) {
			console.error("❌ hongSise DB 열기 실패", e);
		};

		request.onsuccess = function (e) {
			const db = e.target.result;
			const storeNames = db.objectStoreNames;
			const tx = db.transaction(storeNames, "readwrite");

			Promise.all(
				Object.keys(data).map(storeName => {
					return new Promise((resolve, reject) => {
						if (!storeNames.contains(storeName)) {
							console.warn(`⚠️ hongSise DB에 ${storeName} store 없음`);
							return resolve();
						}

						const store = tx.objectStore(storeName);
						const items = data[storeName];

						items.forEach(item => {
							store.put(item);
						});

						resolve();
					});
				})
			)
				.then(() => {
					tx.oncomplete = () => {
						alert("✅ hongSise DB 데이터 가져오기 완료");

						if (document.getElementById("toggleSiseMap")?.checked && window.map) {
							prevSiseMapState = "초기화";
							updateMarkers(window.map.getBounds());
						}
					};
				})
				.catch(err => {
					console.error("❌ hongSise import 오류", err);
				});
		};
	};

	reader.readAsText(file);
}


// ✅ [1] hongSiseColor 백업 버튼
async function exportColorSettingsToJSON() {
  try {
    const db = await initColorSettingsDB(); // hongSiseColor DB 열기
    const transaction = db.transaction(["chartColor", "yearColor"], "readonly");

    const chartStore = transaction.objectStore("chartColor");
    const yearStore = transaction.objectStore("yearColor");

    const [chartRequest, yearRequest] = [chartStore.getAll(), yearStore.getAll()];

    chartRequest.onsuccess = () => {
      yearRequest.onsuccess = async () => {
        const chartData = chartRequest.result;
        const yearData = yearRequest.result;

        const backup = {
  chartColor: chartData,
  yearColor: yearData
};


        const jsonData = JSON.stringify(backup, null, 2);
        const now = new Date();
        const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;

        const handle = await window.showSaveFilePicker({
          suggestedName: `시세지도Ver2_색상설정_백업_${timestamp}.json`,
          types: [{
            description: 'JSON Files',
            accept: { 'application/json': ['.json'] }
          }]
        });

        const writable = await handle.createWritable();
        await writable.write(jsonData);
        await writable.close();

        alert("✅ 색상 설정이 백업되었습니다.");
      };
    };

    chartRequest.onerror = yearRequest.onerror = (e) => {
      console.error("❌ 색상 설정 백업 오류", e);
    };
  } catch (e) {
    console.error("❌ 색상 설정 백업 실패", e);
  }
}




// ✅ [2] hongSiseColor 복원 버튼
function importFromJSONForColor(file) {
	const reader = new FileReader();

	reader.onload = function (event) {
		try {
			const data = JSON.parse(event.target.result);
			const request = indexedDB.open("hongSiseColor"); // 반드시 2 이상으로 지정

			request.onerror = function (event) {
				console.error("❌ DB 연결 실패:", event);
				alert("❌ 색상 설정 복원 실패: DB 연결 실패");
			};

			request.onsuccess = function (event) {
				const db = event.target.result;

				const transaction = db.transaction(["chartColor", "yearColor"], "readwrite");

				// chartColor 복원
				const chartStore = transaction.objectStore("chartColor");
				if (Array.isArray(data.chartColor)) {
					data.chartColor.forEach(item => {
						chartStore.put(item);
					});
				}

				// yearColor 복원
				const yearStore = transaction.objectStore("yearColor");
				if (Array.isArray(data.yearColor)) {
					data.yearColor.forEach(item => {
						yearStore.put(item);
					});
				}

				transaction.oncomplete = function () {
					alert("✅ 색상 설정 복원 완료되었습니다.");
					location.reload(); // ✔ 새로고침하여 반영
				};

				transaction.onerror = function (event) {
					console.error("❌ 색상 설정 복원 실패:", event);
					alert("❌ 색상 설정 복원 실패: 트랜잭션 오류");
				};
			};

			request.onupgradeneeded = function (event) {
				const db = event.target.result;

				if (!db.objectStoreNames.contains("chartColor")) {
					db.createObjectStore("chartColor", { keyPath: "id" });
				}
				if (!db.objectStoreNames.contains("yearColor")) {
					db.createObjectStore("yearColor", { keyPath: "id" });
				}
			};
		} catch (error) {
			console.error("❌ 색상 설정 복원 실패:", error);
			alert("❌ 색상 설정 복원 실패: JSON 파싱 오류");
		}
	};

	reader.onerror = function () {
		alert("❌ 파일 읽기 실패");
	};

	reader.readAsText(file);
}





function resetColorSettingsDB() {
    const confirmReset = confirm("⚠️ 색상 설정을 초기화하면 복구할 수 없습니다. 백업을 권장드립니다.\n계속하시겠습니까?");
    if (!confirmReset) return;

    const request = indexedDB.open("hongSiseColor"); // ✅ 버전 명시하지 않음

    request.onerror = function (event) {
        console.error("❌ 색상 DB 연결 실패:", event);
        alert("❌ 색상 설정 초기화 실패: DB 연결 오류");
    };

    request.onsuccess = function (event) {
        const db = event.target.result;
        const tx = db.transaction(["chartColor", "yearColor"], "readwrite");

        const chartStore = tx.objectStore("chartColor");
        const yearStore = tx.objectStore("yearColor");

        chartStore.clear();
        yearStore.clear();

        tx.oncomplete = () => {
            alert("✅ 색상 설정이 초기화되었습니다.");
            window.priceColorSettings = [];
            window.yearColorSettings = [];

            if (window.map) updateMarkers(window.map.getBounds(), true);
        };

        tx.onerror = function (event) {
            console.error("❌ 색상 설정 초기화 실패:", event.target.error);
            alert("❌ 색상 초기화 중 오류가 발생했습니다.");
        };
location.reload(); // ✔ 새로고침하여 반영
    };
}


////////////////////////////////////////시세 차트/////////////////////////////////////////////////

function parsePriceDataFromTable(tableContainer) {
    const rows = tableContainer.querySelectorAll("tr");
    const parsed = [];

    rows.forEach(row => {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 2) {
            const 평형 = cells[0].textContent.trim();
            const 매매 = parseFloat(cells[1].textContent.trim());
            const 전세 = parseFloat(cells[2].textContent.trim());
			const 기타 = cells[3].textContent.trim();

            if (!isNaN(매매)) {
                parsed.push({ 평형, 매매, 전세, 기타 });
            }
        }
    });

    return parsed;
}

function getColorForPrice(price, settings) {
    // 가격 이상 조건을 만족하는 가장 낮은 설정 색상 사용
    for (let i = settings.length - 1; i >= 0; i--) {
        if (price >= settings[i].price) {
            return settings[i].color;
        }
    }
    // 해당 조건 없을 경우 기본값
    return "#cccccc";
}
function renderPriceChart(container, data) {
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.gap = "1px";

    const fallbackColors = ['#000000', '#454648', '#474C4F', '#FF0000', '#FF6600', '#FFFF00',
                            '#92D050', '#00B050', '#00B0F0', '#0070C0', '#000099', '#7030A0',
                            '#CC3399', '#FF66CC'];

    function getColorByPrice(price) {
		const priceFloor = Math.floor(price);

		if (Array.isArray(priceColorSettings) && priceColorSettings.length > 0) {
			// priceColorSettings가 있는 경우
			const exact = priceColorSettings.find(p => p.price === priceFloor);
			if (exact) return { bg: exact.bgColor, text: exact.textColor };

			// 정렬된 리스트
			const sorted = [...priceColorSettings].sort((a, b) => a.price - b.price);
			const min = sorted[0];
			const max = sorted[sorted.length - 1];

			if (priceFloor < min.price) {
				return { bg: min.bgColor, text: min.textColor }; // ✅ 최소값 적용
			}

			if (priceFloor > max.price) {
				return { bg: max.bgColor, text: max.textColor }; // ✅ 최대값 적용
			}

			// 중간 누락 구간인 경우: price 이하 중 가장 가까운 값
			for (let i = sorted.length - 1; i >= 0; i--) {
				if (sorted[i].price <= priceFloor) {
					return { bg: sorted[i].bgColor, text: sorted[i].textColor };
				}
			}
		} else {
			// fallback 색상
			const index = Math.min(Math.max(priceFloor - 3, 0), fallbackColors.length - 1);
			return { bg: fallbackColors[index], text: "#ffffff" };
		}
	}

//console.log(data)
    data.forEach(d => {

    if (isNaN(d.매매)) return; // 매매가 없는 경우는 건너뜀

    const card = document.createElement("div");
    card.style.display = "flex";
    card.style.flexDirection = "column";
    card.style.alignItems = "center";
    card.style.border = "1px solid black";
    card.style.borderRadius = "4px";
    card.style.overflow = "hidden";
    card.style.width = "32px";
    card.style.fontSize = "13px";
    card.style.boxShadow = "1px 1px 3px rgba(0,0,0,0.2)";

    // 평형 (상단)
    const top = document.createElement("div");
    top.textContent = d.평형;
    top.style.background = "white";
    top.style.color = "black";
    top.style.fontWeight = "bold";
    top.style.width = "100%";
    top.style.textAlign = "center";
    top.style.padding = "2px 0";

    // 색상
    const { bg, text } = getColorByPrice(d.매매);

    // 가격 영역 (하단)
    const bottom = document.createElement("div");
    bottom.style.background = bg;
    bottom.style.color = text;
    bottom.style.display = "flex";
    bottom.style.flexDirection = "column";
    bottom.style.alignItems = "center";
    bottom.style.justifyContent = "center";
    bottom.style.padding = "5px 0";
    bottom.style.width = "100%";

 // 매매
const 매매 = document.createElement("div");
매매.style.fontWeight = "bold";
매매.style.minHeight = "1.5em";
if (d.매매 !== undefined && d.매매 !== null && d.매매 !== "" && !isNaN(d.매매)) {
    매매.textContent = Number(d.매매).toFixed(1);
} else {
    매매.textContent = " ";
}
bottom.appendChild(매매);

// 전세
const 전세 = document.createElement("div");
전세.style.fontWeight = "bold";
전세.style.minHeight = "1.5em";
if (d.전세 !== undefined && d.전세 !== null && d.전세 !== "" && !isNaN(d.전세)) {
    전세.textContent = Number(d.전세).toFixed(1);
} else {
    전세.textContent = " ";
}
bottom.appendChild(전세);

// 기타
const 기타 = document.createElement("div");
기타.style.fontWeight = "bold";
기타.style.minHeight = "1.5em";
if (d.기타 !== undefined && d.기타 !== null && d.기타 !== "" && !isNaN(d.기타)) {
    기타.textContent = Number(d.기타).toFixed(1);
} else if(d.기타 !== undefined && d.기타 !== null && d.기타 !== ""){
	기타.textContent = d.기타;
} else {
    기타.textContent = " ";
}
bottom.appendChild(기타);

    card.appendChild(top);
    card.appendChild(bottom);
    wrapper.appendChild(card);
});


    container.innerHTML = "";
    container.appendChild(wrapper);
}




function getSavedOrDefaultTable(apartmentId) {
    // IndexedDB에서 기존 데이터 가져오기 시도
    // 없으면 기본 테이블 반환
    return new Promise((resolve) => {
        const request = indexedDB.open("hongSise", 1);
        request.onsuccess = function(event) {
            const db = event.target.result;
            const transaction = db.transaction(["apartments"], "readonly");
            const store = transaction.objectStore("apartments");
            const getRequest = store.get(`${apartmentId}-시세1`);
            getRequest.onsuccess = function(event) {
                if (getRequest.result && getRequest.result.table) {
                    resolve(getRequest.result.table);
                } else {
                    resolve(generateDefaultTable());
                }
            };
            getRequest.onerror = () => {
                resolve(generateDefaultTable());
            };
        };
        request.onerror = () => {
            resolve(generateDefaultTable());
        };
    });
}

///////////////////// 차트 색상 설정 /////////////////////

let priceColorSettings = [];
document.getElementById("priceColorSettingsBtn").addEventListener("click", () => {


  loadColorSettingsFromDB().then(settings => {
    if (settings) {
      applyColorSettings(settings); // 네가 정의한 함수
    }

  });


    if (document.getElementById("priceColorModal")) {
        document.body.removeChild(document.getElementById("priceColorModal")); // 중복 제거
    }

    const modal = document.createElement("div");
    modal.id = "priceColorModal";
    modal.style = `
        position: fixed;
        top: 30px;
        left: 50%;
        transform: translate(0%, 0%);
        background: white;
        border: 1px solid gray;
        padding: 15px;
        z-index: 10000;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        width: 400px;
        max-height: 90vh;
        overflow-y: auto;
    `;


    const saveBtn = document.createElement("button");
    saveBtn.innerText = "저장";
    saveBtn.style = "margin-top: 10px; padding: 5px 10px;";
    saveBtn.onclick = () => {
		const rows = modal.querySelectorAll('.color-setting-row');


		for (const row of rows) {
			const color = row.querySelector(".bg-color-hex")?.value;
			const textColor = row.querySelector(".text-color-hex")?.value;

			const hasAnyValue = row.querySelector(".price-input")?.value.trim() !== "" ;

			if (hasAnyValue && color == "" || textColor == ""){
				alert("금액이 있는 행의 배경색와 글자색을 확인해주세요");
				return; // ✅ 전체 함수 빠져나옴
			}
		}

		console.log("🔎 저장 전 rows 확인", rows);

		const settings = collectColorSettings(modal);
		console.log("🎯 수집된 설정:", settings);

		if (!settings || settings.length === 0) {
			console.warn('[경고] 저장할 색상 설정이 없습니다.');
			return;
		}

		const tx = window.colorDB.transaction('chartColor', 'readwrite');
		const store = tx.objectStore('chartColor');
		const data = { id: 'priceColorSettings', settings };

		const request = store.put(data);
		request.onsuccess = () => {
			console.log('✅ 색상 설정 저장 완료:', data);
		};
		request.onerror = e => {
			console.error('❌ 색상 설정 저장 실패', e);
		};

		priceColorSettings = settings;
		updateMarkers(window.map.getBounds(), true);
		document.body.removeChild(modal);
	};


	const closeButton = document.createElement("button");
	closeButton.innerText = "닫기";
	closeButton.style = "margin-top: 10px; padding: 5px 10px;";
	closeButton.onclick = () => {
		document.body.removeChild(modal);
	};


// ... 기존 saveBtn, closeBtn 이후에 추가

// 설정 초기화 버튼
const resetBtn = document.createElement("button");
	resetBtn.innerText = "설정 초기화";
	resetBtn.style = "margin-top: 10px; padding: 5px 10px;";
	resetBtn.onclick = () => {


  if (!window.colorDB) {
    alert("DB가 연결되지 않았습니다.");
    return;
  }

  const confirmed = confirm("금액대 색상 설정을 초기값으로 되돌리시겠습니까?");
  if (!confirmed) return;

  const tx = window.colorDB.transaction("chartColor", "readwrite");
  const store = tx.objectStore("chartColor");

  const deleteRequest = store.delete("priceColorSettings");

  deleteRequest.onsuccess = () => {
    console.log("🧹 기존 설정 삭제 완료");

    // ✅ 초기값 저장
    const saveRequest = store.put({
      id: "priceColorSettings",
      settings: defaultPriceColorSettings
    });

    saveRequest.onsuccess = () => {
      console.log("✅ 초기값 저장 완료");
      priceColorSettings = defaultPriceColorSettings;
      updateMarkers(window.map.getBounds(), true); // 마커 재렌더링
	  document.body.removeChild(modal);
document.getElementById("priceColorSettingsBtn").click();
      alert("✅ 기본값으로 초기화 완료");
    };

    saveRequest.onerror = (e) => {
      console.error("❌ 초기값 저장 실패", e);
      alert("초기값 저장 중 오류 발생");
    };
  };

  deleteRequest.onerror = (e) => {
    console.error("❌ 설정 삭제 실패", e);
    alert("초기화 중 오류 발생");
  };
};





	modal.appendChild(saveBtn); // 저장 버튼은 그 아래에

	modal.appendChild(closeButton);
	modal.appendChild(resetBtn);


    const title = document.createElement("h3");
    title.innerText = "💰 금액대별 색상 설정";
    title.style.marginTop = "10px";
	modal.appendChild(title);

	// 헤더 행 추가
	const header = document.createElement("div");
	header.style = "display: flex; align-items: center; margin-bottom: 8px; gap: 6px; font-weight: bold;";
	["억대", "배경색", "", "글자색", ""].forEach(text => {
		const label = document.createElement("div");
		label.textContent = text;
		label.style = "width: 70px;";
		header.appendChild(label);
	});
	modal.appendChild(header);


	const container = document.createElement("div");
	container.id = "colorSettingContainer";  // ✅ 반드시 이 ID 필요
	modal.appendChild(container);
	for (let i = 0; i < 20; i++) {
		const row = document.createElement("div");
		row.classList.add("color-setting-row");
		row.style = "display: flex; align-items: center; margin-bottom: 8px; gap: 6px;";

		// 금액대 입력
		const priceInput = document.createElement("input");
		priceInput.type = "number";
		priceInput.value = priceColorSettings[i]?.price || {}; // 3억부터
		priceInput.className = "price-input";
		priceInput.style = "width: 50px;";

		// 배경색 피커
		const bgColorPicker = document.createElement("input");
		bgColorPicker.type = "color";
		bgColorPicker.value = priceColorSettings[i]?.bgColor || "#000000";
		bgColorPicker.className = "bg-color-input";

		// 배경색 HEX 입력
		const bgColorInput = document.createElement("input");
		bgColorInput.type = "text";
		bgColorInput.value = bgColorPicker.value;
		bgColorInput.style = "width: 70px;";
		bgColorInput.className = "bg-color-hex";

		// 동기화
		bgColorPicker.addEventListener("input", () => bgColorInput.value = bgColorPicker.value);
		bgColorInput.addEventListener("input", () => bgColorPicker.value = bgColorInput.value);

		// 글자색 피커
		const textColorPicker = document.createElement("input");
		textColorPicker.type = "color";
		textColorPicker.value = priceColorSettings[i]?.textColor || "#ffffff";
		textColorPicker.className = "text-color-input";

		// 글자색 HEX 입력
		const textColorInput = document.createElement("input");
		textColorInput.type = "text";
		textColorInput.value = textColorPicker.value;
		textColorInput.style = "width: 70px;";
		textColorInput.className = "text-color-hex";

		// 동기화
		textColorPicker.addEventListener("input", () => textColorInput.value = textColorPicker.value);
		textColorInput.addEventListener("input", () => textColorPicker.value = textColorInput.value);

		// append 순서: 금액대, 배경색 피커 + hex, 글자색 피커 + hex
		row.appendChild(priceInput);
		row.appendChild(bgColorPicker);
		row.appendChild(bgColorInput);
		row.appendChild(textColorPicker);
		row.appendChild(textColorInput);

		modal.appendChild(row);
	}

	const notice = document.createElement("div");
	notice.textContent = "해당되는 억대의 설정값이 없을 경우 최소값과 최대값 색상으로 표현됩니다";
	notice.style = "font-size: 14px; color: gray; margin-top: 10px;";

	modal.appendChild(notice);


		document.body.appendChild(modal);
		makeModalDraggable(modal);
	});


let colorDB;

function initColorSettingsDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("hongSiseColor"); // 버전 반드시 증가

    request.onupgradeneeded = (event) => {
		  const db = event.target.result;
		  if (!db.objectStoreNames.contains("chartColor")) {
			db.createObjectStore("chartColor", { keyPath: "id" });
			console.log("✅ chartColor store created");
		  }
		  if (!db.objectStoreNames.contains("yearColor")) {
			db.createObjectStore("yearColor", { keyPath: "id" });
			console.log("✅ yearColor store created");
		  }
    };

    request.onsuccess = (event) => {
      window.colorDB = event.target.result;
      console.log("✅ DB opened");
      resolve(window.colorDB);
    };

    request.onerror = (event) => {
      console.error("❌ DB open failed", event);
      reject(event);
    };
  });
}






function saveColorSettingsToDB(settings) {
    if (!settings || settings.length === 0) {
        console.warn('[경고] 저장할 색상 설정이 없습니다.');
        return;
    }

    if (!colorDB) {
        console.error("❌ DB가 초기화되지 않음");
        return;
    }

    const tx = colorDB.transaction('chartColor', 'readwrite');
    const store = tx.objectStore('chartColor');

    const data = { id: 'priceColorSettings', settings };

    const request = store.put(data);

    request.onsuccess = () => {
        console.log('✅ 색상 설정 저장 완료:', data);
        // 🔄 저장한 데이터로 메모리 상태도 갱신
        priceColorSettings = [...settings];
    };

    request.onerror = (e) => {
        console.error('❌ 색상 설정 저장 실패', e);
    };
}


function applyColorSettings(settings) {
    console.log("💡 불러온 색상 설정:", settings);
    const rows = document.querySelectorAll(".color-setting-row");

    settings.forEach((setting, index) => {
        const row = rows[index];
        if (!row) return;

        const priceInput = row.querySelector(".price-input");
        const bgColorInput = row.querySelector(".bg-color-input");
        const textColorInput = row.querySelector(".text-color-input");

        if (priceInput) priceInput.value = setting.price;
        if (bgColorInput) bgColorInput.value = setting.bgColor;
        if (textColorInput) textColorInput.value = setting.textColor;
    });
}

//억대 색상 초기값
const defaultPriceColorSettings = [
  { price: 3, bgColor: "#000000", textColor: "#ffffff" },
  { price: 4, bgColor: "#454648", textColor: "#ffffff" },
  { price: 5, bgColor: "#474c4f", textColor: "#ffffff" },
  { price: 6, bgColor: "#ff0000", textColor: "#ffffff" },
  { price: 7, bgColor: "#ff6600", textColor: "#ffffff" },
  { price: 8, bgColor: "#ffff00", textColor: "#000000" },
  { price: 9, bgColor: "#92d050", textColor: "#ffffff" },
  { price: 10, bgColor: "#00b050", textColor: "#ffffff" },
  { price: 11, bgColor: "#00b0f0", textColor: "#ffffff" },
  { price: 12, bgColor: "#0070c0", textColor: "#ffffff" },
  { price: 13, bgColor: "#000099", textColor: "#ffffff" },
  { price: 14, bgColor: "#7030a0", textColor: "#ffffff" },
  { price: 15, bgColor: "#cc3399", textColor: "#ffffff" },
  { price: 16, bgColor: "#ff66cc", textColor: "#ffffff" }
];


function loadColorSettingsFromDB() {
  return new Promise((resolve, reject) => {


    const tx = window.colorDB.transaction("chartColor", "readwrite");  // readwrite 필요
    const store = tx.objectStore("chartColor");

    const request = store.get("priceColorSettings");

    request.onsuccess = () => {
      const result = request.result;
      if (result) {
        console.log("✅ 색상 설정 로드 성공", result.settings);
        resolve(result.settings);
      } else {
        console.log("ℹ️ 색상 설정 없음 → 기본값 저장");

        const defaultData = {
          id: "priceColorSettings",
          settings: defaultPriceColorSettings
        };
        store.put(defaultData);  // 기본값 저장

        resolve(defaultPriceColorSettings);  // 기본값 반환
      }
    };

    request.onerror = (event) => {
      console.error("❌ 색상 설정 로드 실패", event);
      reject(event);
    };
  });
}


function collectColorSettings() {
    const settings = [];
    const rows = document.querySelectorAll(".color-setting-row");

    rows.forEach(row => {
        const priceValue = row.querySelector(".price-input")?.value?.trim();
        const bgColor = row.querySelector(".bg-color-input")?.value;
        const textColor = row.querySelector(".text-color-input")?.value;

        if (priceValue !== "" && bgColor && textColor) {
            const price = parseInt(priceValue);
            if (!isNaN(price)) {
                settings.push({ price, bgColor, textColor });  // ✅ textColor 포함
            }
        }
    });

    console.log("[색상 설정 수집됨]", settings);
    return settings;
}


///////////////////// 연식 색상 설정 /////////////////////


async function showYearColorSettingsModal() {
    if (document.getElementById("yearColorModal")) {
        document.body.removeChild(document.getElementById("yearColorModal"));
    }

    const modal = document.createElement("div");
    modal.id = "yearColorModal";
    modal.style = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 1px solid gray;
        padding: 15px;
        z-index: 10000;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        width: 500px;
        max-height: 70vh;
        overflow-y: auto;
    `;

    const title = document.createElement("h3");
    title.innerText = "🏠 연식별 마커 색상 설정";
    title.style.marginTop = "10px";
    modal.appendChild(title);

    // 헤더
    const header = document.createElement("div");
header.style = "display: flex; gap: 10px; margin-bottom: 10px; font-weight: bold;";

// 각 열 스타일 클래스 정의 (CSS적용이 더 좋지만, JS로 직접 주는 방식)
const columnStyles = [
  "width: 85px;", // From
  "width: 70px;", // To
  "width: 150px;", // 색상 피커
  "width: 130px;", // 색상 피커
  
];

["시작년도", "종료년도", "배경색", "글자색"].forEach((text, i) => {
  const span = document.createElement("span");
  span.innerText = text;
  span.style = columnStyles[i] + "text-align: center;"; // 동일한 폭 부여
  header.appendChild(span);
});
modal.appendChild(header);


    // 기존 설정 최대 10개
    for (let i = 0; i < 10; i++) {
		const row = document.createElement("div");
		row.classList.add("year-color-setting-row");
		row.style = "display: flex; gap: 5px; margin-bottom: 6px;";

		const fromInput = document.createElement("input");
		fromInput.type = "number";
		fromInput.placeholder = "from";
		fromInput.style = "width: 70px;";
		fromInput.className = "year-from";
		fromInput.style.boxSizing = "border-box";
		fromInput.style.padding = "4px";
		fromInput.style.marginLeft = "2px";
		fromInput.style.border = "1px solid #000";


		const toInput = document.createElement("input");
		toInput.type = "number";
		toInput.placeholder = "to";
		toInput.style = "width: 80px;";
		toInput.className = "year-to";
		toInput.style.boxSizing = "border-box";
		toInput.style.padding = "4px";
		toInput.style.marginLeft = "2px";
		toInput.style.border = "1px solid #000";

		// ✅ 배경색
		const colorPicker = document.createElement("input");
		colorPicker.type = "color";
		colorPicker.value = "#000000";
		colorPicker.className = "year-color-picker";

		const colorInput = document.createElement("input");
		colorInput.type = "text";
		colorInput.value = "#000000";
		colorInput.style = "width: 80px;";
		colorInput.className = "year-color-hex";
		colorInput.style.boxSizing = "border-box";
		colorInput.style.padding = "4px";
		colorInput.style.marginLeft = "2px";
		colorInput.style.border = "1px solid #000";


		colorPicker.addEventListener("input", () => colorInput.value = colorPicker.value);
		colorInput.addEventListener("input", () => colorPicker.value = colorInput.value);

		// ✅ 글자색 (텍스트 색상)
		const textColorPicker = document.createElement("input");
		textColorPicker.type = "color";
		textColorPicker.value = "#ffffff";
		textColorPicker.className = "year-text-color-picker";

		const textColorInput = document.createElement("input");
		textColorInput.type = "text";
		textColorInput.value = "#ffffff";
		textColorInput.style = "width: 80px;";
		textColorInput.className = "year-text-color-hex";
		textColorInput.style.boxSizing = "border-box";
		textColorInput.style.padding = "4px";
		textColorInput.style.marginLeft = "2px";
		textColorInput.style.border = "1px solid #000";

		textColorPicker.addEventListener("input", () => textColorInput.value = textColorPicker.value);
		textColorInput.addEventListener("input", () => textColorPicker.value = textColorInput.value);

		row.appendChild(fromInput);
		row.appendChild(toInput);
		row.appendChild(colorPicker);
		row.appendChild(colorInput);
		row.appendChild(textColorPicker);   // ✅ 추가
		row.appendChild(textColorInput);   // ✅ 추가

		modal.appendChild(row);
	}


    const saveBtn = document.createElement("button");
    saveBtn.innerText = "저장";
    saveBtn.style = "margin-top: 10px;";
    saveBtn.onclick = async () => {
        const settings = [];
        const rows = modal.querySelectorAll(".year-color-setting-row");
		
		for (const row of rows) {
			const from = parseInt(row.querySelector(".year-from")?.value);
			const to = parseInt(row.querySelector(".year-to")?.value);
			const color = row.querySelector(".year-color-hex")?.value;
			const fontColor = row.querySelector(".year-text-color-hex")?.value;

			const hasAnyValue =
			row.querySelector(".year-from")?.value.trim() !== "" ||
			row.querySelector(".year-to")?.value.trim() !== "" 
			;



			if (hasAnyValue && (row.querySelector(".year-from")?.value.trim() == "" || 
								row.querySelector(".year-to")?.value.trim() == "" ||
								row.querySelector(".year-color-hex")?.value.trim() == "" ||
								row.querySelector(".year-text-color-hex")?.value.trim() == "")){

				alert("하나라도 값이 있는 경우 행의 모든 항목을 채워야 합니다");
				return; // ✅ 전체 함수 빠져나옴
			}

			if (!isNaN(from) && !isNaN(to) && color && fontColor) {
				settings.push({ from, to, color, fontColor });
			}
		}



		await saveYearColorSettingsToDB(settings);
        
        // 추후 DB 저장 함수 호출 가능
        document.body.removeChild(modal);
		
		console.log(window.yearColorSettings);
		updateMarkers(window.map.getBounds(), true);
    };

	const closeBtn = document.createElement("button");
    closeBtn.innerText = "닫기";
    closeBtn.style = "margin-top: 10px;";
    closeBtn.onclick = async () => {
        
        // 추후 DB 저장 함수 호출 가능
        document.body.removeChild(modal);
		
		
    };

	const resetBtn = document.createElement("button");
	resetBtn.innerText = "설정 초기화";
	resetBtn.style = "padding: 10px 10px;";
	resetBtn.onclick = () => {
	  // IndexedDB에서 연식 설정 삭제
	  const tx = window.colorDB.transaction("yearColor", "readwrite");
	  const store = tx.objectStore("yearColor");
	  const request = store.delete("yearColorSettings");

	  request.onsuccess = async() => {
		const confirmed = confirm("연식 색상 설정을 초기값으로 되돌리시겠습니까?");
	  if (!confirmed) return;

	  const defaultSettings = [...DEFAULT_YEAR_COLOR_SETTINGS]; // ✅ 기본값
	  await saveYearColorSettingsToDB(defaultSettings); // ✅ DB에 저장 완료까지 기다림

	  yearColorSettings = defaultSettings; // ✅ 메모리 반영
	  bindYearColorSettingsToModal(defaultSettings); // ✅ 모달에도 반영

	  // ✅ 마커 새로고침 (완전히 삭제 후 재생성)
	  updateMarkers(window.map.getBounds(), true);
	  };
	  request.onerror = () => {
		alert("초기화 실패");
	  };
	};

    modal.appendChild(saveBtn);
    modal.appendChild(closeBtn);
	modal.appendChild(resetBtn);

    document.body.appendChild(modal);

    makeModalDraggable(modal);


	bindYearColorSettingsToModal();


}




let yearColorSettings = [];

document.getElementById("yearColorSettingsBtn").addEventListener("click", () => {


showYearColorSettingsModal();

});



function saveYearColorSettingsToDB(settings) {
  return new Promise((resolve, reject) => {
    if (!window.colorDB) {
      console.error("❌ DB가 초기화되지 않음");
      reject("DB 미초기화");
      return;
    }

    const tx = window.colorDB.transaction("yearColor", "readwrite");
    const store = tx.objectStore("yearColor");
    const data = { id: "yearColorSettings", settings };

    const request = store.put(data);
    request.onsuccess = () => {
      console.log("✅ 연식 색상 설정 저장 완료:", [...settings]);
      window.yearColorSettings = [...settings];
      resolve(); // ✅ 저장 완료
    };
    request.onerror = (e) => {
      console.error("❌ 연식 색상 설정 저장 실패", e);
      reject(e);
    };
  });
}

const DEFAULT_YEAR_COLOR_SETTINGS = [
  { from: 1900, to: 1999, color: "#5c6267", fontColor: "#ffffff" },
  { from: 2000, to: 2009, color: "#f5ee2e", fontColor: "#000000" },
  { from: 2010, to: 2019, color: "#ee1a24", fontColor: "#ffffff" },
  { from: 2020, to: 2999, color: "#3e24d7", fontColor: "#ffffff" }
];


function loadYearColorSettingsFromDB() {
  return new Promise((resolve, reject) => {
    if (!window.colorDB) {
      console.error("❌ DB 초기화되지 않음");
      reject("DB 초기화 안됨");
      return;
    }

    const tx = window.colorDB.transaction("yearColor", "readwrite");
    const store = tx.objectStore("yearColor");

    const request = store.get("yearColorSettings");

    request.onsuccess = () => {
      const result = request.result;
      if (result) {
        console.log("✅ 연식 색상 설정 로드 성공", result.settings);
        resolve(result.settings);
      } else {
        console.log("ℹ️ 연식 설정 없음 → 기본값 저장");

        const defaultData = {
          id: "yearColorSettings",
          settings: DEFAULT_YEAR_COLOR_SETTINGS
        };
        store.put(defaultData);
        resolve(DEFAULT_YEAR_COLOR_SETTINGS);
      }
    };

    request.onerror = (event) => {
      console.error("❌ 연식 설정 로드 실패", event);
      reject(event);
    };
  });
}


function bindYearColorSettingsToModal() {
//console.log(window.yearColorSettings);
  const modal = document.getElementById("yearColorModal");
  if (!modal) return;

  const rows = modal.querySelectorAll(".year-color-setting-row");

  rows.forEach((row, index) => {
    const fromInput = row.querySelector(".year-from");
    const toInput = row.querySelector(".year-to");
    const bgColorPicker = row.querySelector(".year-color-picker");
    const bgColorHex = row.querySelector(".year-color-hex");
    const textColorPicker = row.querySelector(".year-text-color-picker");
    const textColorHex = row.querySelector(".year-text-color-hex");

    if (Array.isArray(window.yearColorSettings) && window.yearColorSettings[index]) {
      const setting = window.yearColorSettings[index];
      fromInput.value = setting.from ?? "";
      toInput.value = setting.to ?? "";
      bgColorPicker.value = setting.color ?? "#000000";
      bgColorHex.value = setting.color ?? "#000000";
      textColorPicker.value = setting.fontColor ?? "#FFFFFF";
      textColorHex.value = setting.fontColor ?? "#FFFFFF";
    } else {
      // 기본값 초기화
      fromInput.value = "";
      toInput.value = "";
      bgColorPicker.value = "#000000";
      bgColorHex.value = "#000000";
      textColorPicker.value = "#FFFFFF";
      textColorHex.value = "#FFFFFF";
    }
  });
}


</script>





</body>
</html>
