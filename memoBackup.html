<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>홍부 메모 백업 (모바일 최적화 · 10개 분할 · 지연생성 · 로딩팝업)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#f7f7f9; --card:#fff; --text:#222; --muted:#666; --brand:#4A90E2; --brand2:#357ABD; }
    html, body { height:100%; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans', Arial, sans-serif; margin:0; padding:24px; background:var(--bg); color:var(--text); }
    h1 { margin:0 0 14px; font-size:22px; }
    p  { margin:6px 0 14px; color:var(--muted) }
    .card { background:var(--card); border:1px solid #e9e9ef; border-radius:12px; padding:16px; box-shadow: 0 2px 8px rgba(0,0,0,.04); }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    label { font-size:14px; color:#333; display:flex; flex-direction:column; gap:6px; }
    select, button { font-size:14px; border-radius:8px; border:1px solid #d7d7de; padding:8px 10px; background:#fff; }
    select { min-width: 180px; }
    button { background:var(--brand); color:#fff; border:none; cursor:pointer; padding:10px 16px; font-weight:600; }
    button:hover { background:var(--brand2); }
    button.secondary { background:#fff; color:#333; border:1px solid #d7d7de; }
    .muted { color:var(--muted); font-size:13px; }
    .counter { font-size:13px; color:#333; margin-left:auto; }
    .downloads { display:flex; flex-direction:column; gap:8px; margin-top:12px; }
    .divider { height:1px; background:#eee; margin:12px 0; }

    /* 로딩 모달 */
    .modal {
      position: fixed; inset:0; display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.35); z-index: 9999;
    }
    .modal.show { display:flex; }
    .modal-card {
      background:#fff; color:#333; padding:18px 20px; border-radius:12px; min-width: 240px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18); text-align:center; font-size:14px;
    }
    .spinner {
      width:26px; height:26px; border-radius:50%;
      border:3px solid #e5e7eb; border-top-color: var(--brand);
      margin:0 auto 10px; animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <h1>📦 홍부 메모 백업</h1>
  <p>시도/시군구를 먼저 선택하세요. <span class="muted">목록에는 “메모 또는 사진이 실제로 존재하는 지역”만 표시됩니다.</span></p>

  <div class="card" id="filters">
    <div class="row" style="gap:12px">
      <label>시도
        <select id="sidoFilter"><option value="">전체</option></select>
      </label>
      <label>시군구
        <select id="sigunguFilter" disabled><option value="">전체</option></select>
      </label>
      <button id="refreshRegions" class="secondary">🔄 지역 새로고침</button>
      <span id="aptStatus" class="muted">(아파트 데이터 자동 로드 대기)</span>
      <span class="counter">선택된 메모: <b id="selCount">0</b>건</span>
    </div>
  </div>

  <div class="card" style="margin-top:14px">
    <div class="row">
      <button id="backupBtn">⬇️ 선택 메모 백업</button>
      <span class="muted">카카오톡 전송을 위해 10개씩 분할·다운로드(지연 생성) 합니다.</span>
    </div>
    <div class="divider"></div>
    <div id="downloadContainer" class="downloads"></div>
  </div>

  <!-- 처리중 모달 -->
  <div id="busyModal" class="modal" role="dialog" aria-modal="true" aria-live="polite">
    <div class="modal-card">
      <div class="spinner" aria-hidden="true"></div>
      <div id="busyText">처리 중입니다…</div>
    </div>
  </div>

  <script>
    // ==========================
    // IndexedDB
    // ==========================
    const DB_NAME = 'hongbuMemo';
    const DB_VERSION = 4;
    const STORE_NOTES = 'apartmentNotes';

    // ==========================
    // UI
    // ==========================
    const els = {
      sido: document.getElementById('sidoFilter'),
      sigungu: document.getElementById('sigunguFilter'),
      refresh: document.getElementById('refreshRegions'),
      status: document.getElementById('aptStatus'),
      selCount: document.getElementById('selCount'),
      downloads: document.getElementById('downloadContainer'),
      backup: document.getElementById('backupBtn'),
      modal: document.getElementById('busyModal'),
      busyText: document.getElementById('busyText'),
    };
    const setAptStatus = t => { els.status.textContent = t; };

    // 로딩 모달
    function showBusy(msg='처리 중입니다…') {
      els.busyText.textContent = msg;
      els.modal.classList.add('show');
    }
    function hideBusy() {
      els.modal.classList.remove('show');
    }

    // ==========================
    // 유틸
    // ==========================
    function fillOptions(selectEl, items) {
      const prev = selectEl.value;
      selectEl.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = '';
      optAll.textContent = '전체';
      selectEl.appendChild(optAll);
      (items || []).forEach(({ value, label }) => {
        const opt = document.createElement('option');
        opt.value = String(value ?? '');
        opt.textContent = String(label ?? value ?? '');
        selectEl.appendChild(opt);
      });
      if ([...selectEl.options].some(o => o.value === prev)) selectEl.value = prev;
    }

    function stripHtmlAndTrim(s) {
      return String(s ?? '')
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/gi, ' ')
        .trim();
    }

    function hasMemoContent(n) {
      const memoText = stripHtmlAndTrim(n?.memo);
      const imgs = Array.isArray(n?.images) ? n.images : [];
      return memoText.length > 0 || imgs.length > 0;
    }

    function noteIdOf(n) {
      return String(n?.id ?? n?.aptId ?? n?.apartmentId ?? '').trim();
    }

    // ==========================
    // DB 순회(스트리밍)
    // ==========================
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = () => reject(new Error('DB 열기 실패'));
      });
    }

    async function iterateNotes(visitor) {
      const db = await openDB();
      const tx = db.transaction([STORE_NOTES], 'readonly');
      const st = tx.objectStore(STORE_NOTES);
      await new Promise((resolve, reject) => {
        const req = st.openCursor();
        req.onsuccess = async e => {
          const cur = e.target.result;
          if (cur) {
            try { await visitor(cur.value); } catch (e) { console.error(e); }
            cur.continue();
          } else resolve();
        };
        req.onerror = () => reject(new Error('cursor 실패'));
      });
      db.close();
    }

    // ==========================
    // apt.json 인덱스(필요한 것만)
    // ==========================
    const aptIndex = new Map(); // aptId -> {sido, sidoNm, sigungu, sigunguNm}

    async function collectUsedAptIds() {
      const set = new Set();
      await iterateNotes(n => {
        if (!hasMemoContent(n)) return;
        const id = noteIdOf(n);
        if (id) set.add(id);
      });
      return set;
    }

    async function loadFilteredAptIndexFromSamePath() {
      showBusy('아파트 데이터(apt.json) 불러오는 중…');
      try {
        const usedIds = await collectUsedAptIds(); // 내용 있는 메모 기준
        const res = await fetch('apt.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();

        aptIndex.clear();
        const arr = Array.isArray(data) ? data :
          (Array.isArray(data?.apartments) ? data.apartments :
           Array.isArray(data?.data) ? data.data : []);
        for (const a of arr) {
          const id = String(a.id ?? a.apartmentId ?? a.aptId ?? '').trim();
          if (!id || !usedIds.has(id)) continue;
          aptIndex.set(id, {
            sido: String(a.sido ?? a.sidoCode ?? '').trim(),
            sidoNm: String(a.sidoNm ?? a.sidoName ?? '').trim(),
            sigungu: String(a.sigungu ?? a.sigunguCode ?? '').trim(),
            sigunguNm: String(a.sigunguNm ?? a.sigunguName ?? '').trim(),
          });
        }
        setAptStatus(`아파트 ${aptIndex.size}건 로딩됨 (필요 항목만)`);
        hideBusy();
        return true;
      } catch (e) {
        console.warn('apt.json 자동 로드 실패:', e);
        setAptStatus('(아파트 데이터 미로딩: apt.json 파일 위치를 확인하세요)');
        hideBusy();
        return false;
      }
    }

    function regionFromNoteViaApt(note) {
      const id = noteIdOf(note);
      if (!id) return null;
      const a = aptIndex.get(id);
      if (!a) return null;
      return {
        sidoCode: a.sido || '',
        sidoName: a.sidoNm || a.sido || '',
        sigunguCode: a.sigungu || '',
        sigunguName: a.sigunguNm || a.sigungu || '',
      };
    }

    // ==========================
    // 필터/카운트
    // ==========================
    async function buildRegionFiltersFromNotes(showModal=true) {
      if (showModal) showBusy('지역 목록을 구성하는 중…');

      if (aptIndex.size === 0) {
        els.sigungu.disabled = true;
        fillOptions(els.sido, []);
        await updateSelectedCount();
        if (showModal) hideBusy();
        return;
      }

      const bySido = new Map(); // sido -> { name, sigungu: Map(sig -> {name,count}), count }

      await iterateNotes(n => {
        if (!hasMemoContent(n)) return;
        const r = regionFromNoteViaApt(n);
        if (!r || !r.sidoCode) return;
        if (!bySido.has(r.sidoCode)) bySido.set(r.sidoCode, { name: r.sidoName || r.sidoCode, sigungu: new Map(), count: 0 });
        const s = bySido.get(r.sidoCode);
        s.count++;
        if (r.sigunguCode) {
          const cur = s.sigungu.get(r.sigunguCode) || { name: r.sigunguName || r.sigunguCode, count: 0 };
          cur.count++;
          s.sigungu.set(r.sigunguCode, cur);
        }
      });

      const sidoItems = Array.from(bySido.entries())
        .map(([code, { name, count }]) => ({ value: code, label: `${name} (${count}건)` }))
        .sort((a, b) => a.label.localeCompare(b.label, 'ko'));
      fillOptions(els.sido, sidoItems);

      const selSido = (els.sido.value || '').trim();
      if (selSido && bySido.has(selSido)) {
        const sigItems = Array.from(bySido.get(selSido).sigungu.entries())
          .map(([code, obj]) => ({ value: code, label: `${obj.name} (${obj.count}건)` }))
          .sort((a, b) => a.label.localeCompare(b.label, 'ko'));
        fillOptions(els.sigungu, sigItems);
        els.sigungu.disabled = false;
      } else {
        fillOptions(els.sigungu, []);
        els.sigungu.disabled = true;
      }

      await updateSelectedCount();
      if (showModal) hideBusy();
    }

    function noteMatchesSelection(note) {
      if (!hasMemoContent(note)) return false;
      const r = regionFromNoteViaApt(note) || {};
      const sSel = (els.sido.value || '').trim();
      const gSel = (els.sigungu.value || '').trim();
      if (sSel && String(r.sidoCode || '').trim() !== sSel) return false;
      if (gSel && String(r.sigunguCode || '').trim() !== gSel) return false;
      return true;
    }

    async function updateSelectedCount() {
      let cnt = 0;
      await iterateNotes(n => { if (noteMatchesSelection(n)) cnt++; });
      els.selCount.textContent = String(cnt);
      return cnt;
    }

    // ==========================
    // 백업 (10개 분할 · 지연 생성)
    // ==========================
    async function backupSelectedNotes() {
      showBusy('선택된 메모를 수집하는 중…');

      if (aptIndex.size === 0) {
        hideBusy();
        alert('apt.json이 로드되지 않았습니다.');
        return;
      }

      els.downloads.innerHTML = '';

      // 선택 조건에 맞는 "ID만" 수집(가벼움)
      const ids = [];
      await iterateNotes(n => {
        if (!noteMatchesSelection(n)) return;
        const id = noteIdOf(n);
        if (id) ids.push(id);
      });

      if (ids.length === 0) {
        hideBusy();
        alert('선택한 지역에 해당하는 메모가 없습니다.');
        return;
      }

      const selectedIdsSnapshot = ids.slice(); // 스냅샷 고정
      const chunkSize = 10; // PART당 메모 개수
      const totalParts = Math.ceil(selectedIdsSnapshot.length / chunkSize);

      const now = new Date();
      const koreaTime = new Date(now.getTime() + 9 * 60 * 60 * 1000);
      const ts = koreaTime.toISOString().replace(/T/, '_').replace(/:/g, '-').replace(/\..+/, '');

      const head = document.createElement('div');
      head.innerHTML = `<h3>📁 총 ${totalParts}개의 백업 파일 · 메모 ${selectedIdsSnapshot.length}건</h3>`;
      els.downloads.appendChild(head);

      // 파트 버튼들을 그리는 작업까지 완료되면 로딩 닫기
      for (let p = 1, i = 0; i < selectedIdsSnapshot.length; p++, i += chunkSize) {
        const startIdx = i;
        const endIdx = Math.min(i + chunkSize, selectedIdsSnapshot.length);
        const plannedCount = endIdx - startIdx;

        const btn = document.createElement('button');
        btn.className = 'secondary';
        btn.textContent = `⬇️ PART ${p} 다운로드 (${plannedCount}개)`;

        // 각 버튼에 스냅샷/범위를 캡처
        const partNo = p, sliceStart = startIdx, sliceEnd = endIdx;

        btn.onclick = async () => {
          showBusy(`PART ${partNo} 생성 중…`);
          const db = await openDB();
          const tx = db.transaction([STORE_NOTES], 'readonly');
          const st = tx.objectStore(STORE_NOTES);

          const sliceIds = selectedIdsSnapshot.slice(sliceStart, sliceEnd);
          const out = [];
          await Promise.all(sliceIds.map(id => new Promise(res => {
            const r = st.get(id);
            r.onsuccess = () => { if (r.result) out.push(r.result); res(); };
            r.onerror   = () => res();
          })));
          db.close();

          const json = JSON.stringify(out); // 용량 절감
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = url;
          a.download = `홍부_메모백업_${ts}_part${partNo}_${out.length}개.json`;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 800);
          hideBusy();
        };

        els.downloads.appendChild(btn);
      }

      hideBusy(); // 버튼 렌더링 완료
    }

    // ==========================
    // 이벤트 & 초기화
    // ==========================
    els.refresh.addEventListener('click', async () => {
      await loadFilteredAptIndexFromSamePath();
      await buildRegionFiltersFromNotes(true);
    });

    els.sido.addEventListener('change', async () => {
      // 시도 변경 시 시군구 목록을 다시 구성 (로딩 팝업 표시)
      await buildRegionFiltersFromNotes(true);
    });

    els.sigungu.addEventListener('change', async () => {
      showBusy('선택 조건을 반영하는 중…');
      await updateSelectedCount();
      hideBusy();
    });

    els.backup.addEventListener('click', backupSelectedNotes);

    (async function init() {
      await loadFilteredAptIndexFromSamePath();   // apt.json 자동 로드(필요 항목만)
      await buildRegionFiltersFromNotes(true);    // 초기 지역 목록 구성
    })();
  </script>
</body>
</html>
